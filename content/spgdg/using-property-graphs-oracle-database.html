<!DOCTYPE html
  SYSTEM "about:legacy-compat">

<!-- saved from url=(0023)https://docs.oracle.com -->

<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment.">
      <meta name="description" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment.">
      <title>Using Property Graphs in an Oracle Database Environment</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Property Graph Developer’s Guide">
      <meta property="og:description" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Property Graph Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 17.8.1">
      <link rel="alternate" href="spatial-and-graph-property-graph-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2017-10-11T16:07:51-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2017">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E85870-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/12.2">
      <meta name="dcterms.release" content="Release 12.2">
      <link rel="prev" href="property-graph-overview-spgdg.html" title="Previous" type="text/html">
      <link rel="next" href="using-inmemory-analyst-oracle-database.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">
            {
                "primary":
                {
                    "category":{
                      "short_name":"database",
                      "element_name":"Database",
                      "display_in_url":true
                    },
                    "suite":{
                      "short_name":"oracle",
                      "element_name":"Oracle",
                      "display_in_url":true
                    },
                    "product_group":{
                      "short_name":"not-applicable",
                      "element_name":"Not applicable",
                      "display_in_url":false
                    },
                    "product":{
                      "short_name":"oracle-database",
                      "element_name":"Oracle Database",
                      "display_in_url":true
                    },
                    "release":{
                      "short_name":"12.2",
                      "element_name":"Release 12.2",
                      "display_in_url":true
                    },
                    "platform":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    },
                    "component":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    }
                }
            }
            </script>
      
    <meta name="dcterms.title" content="Spatial and Graph Property Graph Developer's Guide">
    <meta name="dcterms.isVersionOf" content="SPGDG">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="property-graph-overview-spgdg.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="using-inmemory-analyst-oracle-database.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Property Graph Developer’s Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Using Property Graphs in an Oracle Database Environment</li>
            </ol>
            <a id="GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" name="GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604"></a><a id="BDSPA191"></a>
            
            <h2 id="SPGDG-GUID-4B5AF258-79BE-418D-84FF-9B8A692B8604" class="sect2"><span class="enumeration_chapter">2 </span>Using Property Graphs in an Oracle Database Environment
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter provides conceptual and usage information about creating, storing, and working with property graph data in an Oracle Database environment.</p>
            </div>
            <div>
               <p><strong>Topics:</strong></p>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808">About Property Graphs</a><br>Property graphs allow an easy association of properties (key-value pairs) with graph vertices and edges, and they enable analytical operations based on relationships across a massive set of data.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24">About Property Graph Data Formats</a><br>Several graph formats are supported for property graph data.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D">Property Graph Schema Objects for Oracle Database</a><br>The property graph PL/SQL and Java APIs use special Oracle Database schema objects.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED">Getting Started with Property Graphs</a><br>Follow these steps to get started with property graphs.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958">Using Java APIs for Property Graph Data</a><br>Creating a property graph involves using the Java APIs to create the property graph and objects in it.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-72E0D670-D477-4C0F-914C-8E70E45F9692">Managing Text Indexing for Property Graph Data</a><br>Indexes in Oracle Spatial and Graph property graph support allow fast retrieval of elements by a particular key/value or key/text pair. These indexes are created based on an element type (vertices or edges), a set of keys (and values), and an index type.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7">Access Control for Property Graph Data (Graph-Level and OLS)</a><br>The property graph feature in Oracle Spatial and Graph supports two access control and security models: graph level access control, and fine-grained security through integration with Oracle Label Security (OLS).
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7">Using the Groovy Shell with Property Graph Data</a><br>The Oracle Spatial and Graph property graph support includes a built-in Groovy shell (based on the original Gremlin Groovy shell script). With this command-line shell interface, you can explore the Java APIs.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE">Creating Property Graph Views on an RDF Graph</a><br>With Oracle Spatial and Graph, you can view RDF data as a property graph to execute graph analytics operations by creating property graph views over an RDF graph stored in Oracle Database.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00">Handling Property Graphs Using a Two-Tables Schema</a><br>For property graphs with relatively fixed, simple data structures, where you do not need the flexibility of <code class="codeph">&lt;graph_name&gt;VT$</code> and <code class="codeph">&lt;graph_name&gt;GE$</code>  key/value data tables for vertices and edges, you can use a two-tables schema to achieve better run-time performance. 
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB">Oracle Flat File Format Definition</a><br>A property graph can be defined in two flat files, specifically description files for the vertices and edges.
                  </li>
                  <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD">Example Python User Interface</a><br>The example Python scripts in <code class="codeph">$ORACLE_HOME/md/property_graph/pyopg/</code> can used with Oracle Spatial and Graph Property Graph, and you may want to change and enhance them (or copies of them) to suit your needs.
                  </li>
               </ul>
            </div>
            
            <div class="props_rev_3"><a id="GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808" name="GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808"></a><h3 id="SPGDG-GUID-E4951F06-3B5F-4B82-8B23-7D4F629DE808" class="sect3"><span class="enumeration_section">2.1 </span>About Property Graphs
               </h3>
               <div>
                  <p>Property graphs allow an easy association of properties (key-value pairs) with graph vertices and edges, and they enable analytical operations based on relationships across a massive set of data.</p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">What Are Property Graphs?</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D76CD113-5B02-417A-A91A-7063BC395C08">What Is Oracle Database Support for Property Graphs?</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2" name="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2"></a><h4 id="SPGDG-GUID-9BA44355-E97D-4E7A-81AA-269873E506B2" class="sect4"><span class="enumeration_section">2.1.1 </span>What Are Property Graphs?
                  </h4>
                  <div>
                     <p>A property graph consists of a set of objects or <span class="bold">vertices</span>, and a set of arrows or <span class="bold">edges</span> connecting the objects. Vertices and edges can have multiple properties, which are represented as key-value pairs.
                     </p>
                     <p>Each vertex has a unique identifier and can have:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A set of outgoing edges</p>
                        </li>
                        <li>
                           <p>A set of incoming edges</p>
                        </li>
                        <li>
                           <p>A collection of properties</p>
                        </li>
                     </ul>
                     <p>Each edge has a unique identifier and can have:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>An outgoing vertex</p>
                        </li>
                        <li>
                           <p>An incoming vertex</p>
                        </li>
                        <li>
                           <p>A text label that describes the relationship between the two vertices</p>
                        </li>
                        <li>
                           <p>A collection of properties</p>
                        </li>
                     </ul>
                     <p>The following figure illustrates a very simple property graph with two vertices and one edge. The two vertices have identifiers 1 and 2. Both vertices have properties <code class="codeph">name</code> and <code class="codeph">age</code>. The edge is from the outgoing vertex 1 to the incoming vertex 2. The edge has a text label <code class="codeph">knows</code> and a property <code class="codeph">type</code> identifying the type of relationship between vertices 1 and 2.
                     </p>
                     <div class="figure" id="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2__BHBBGAGE">
                        <p class="titleinfigure">Figure 2-1 Simple Property Graph Example</p><img src="img/two_vertices.png" alt="Description of Figure 2-1 follows" title="Description of Figure 2-1 follows" longdesc="img_text/two_vertices.html"><br><a href="img_text/two_vertices.html">Description of "Figure 2-1 Simple Property Graph Example"</a></div>
                     <!-- class="figure" -->
                     <p>Standards are not available for Big Data Spatial and Graph property graph data model, but it is similar to the W3C standards-based Resource Description Framework (RDF) graph data model. The property graph data model is simpler and much less precise than RDF. These differences make it a good candidate for use cases such as these:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Identifying influencers in a social network</p>
                        </li>
                        <li>
                           <p>Predicting trends and customer behavior</p>
                        </li>
                        <li>
                           <p>Discovering relationships based on pattern matching</p>
                        </li>
                        <li>
                           <p>Identifying clusters to customize campaigns</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-9BA44355-E97D-4E7A-81AA-269873E506B2__THEPROPERTYGRAPHDATAMODELTHATORACLE-3AC6C8FA">
                        <p class="notep1">Note:</p>
                        <p>The property graph data model that Oracle supports at the database side does not allow labels for vertices. However, you can treat the value of a designated vertex property as one or more labels.</p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="using-property-graphs-oracle-database.html#GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C">Specifying Labels for Vertices</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-D76CD113-5B02-417A-A91A-7063BC395C08" name="GUID-D76CD113-5B02-417A-A91A-7063BC395C08"></a><h4 id="SPGDG-GUID-D76CD113-5B02-417A-A91A-7063BC395C08" class="sect4"><span class="enumeration_section">2.1.2 </span>What Is Oracle Database Support for Property Graphs?
                  </h4>
                  <div>
                     <p>Property graphs are supported in Oracle Database, in addition to being supported for Big Data in Hadoop. This support consists of a set of PL/SQL packages, a data access layer, and an analytics layer.</p>
                     <p>The following figure provides an overview of the Oracle property graph architecture.</p>
                     <div class="figure" id="GUID-D76CD113-5B02-417A-A91A-7063BC395C08__BHBDDCAI">
                        <p class="titleinfigure">Figure 2-2 Oracle Property Graph Architecture</p><img src="img/pg_architecture_db.jpg" alt="Description of Figure 2-2 follows" title="Description of Figure 2-2 follows" longdesc="img_text/pg_architecture_db.html"><br><a href="img_text/pg_architecture_db.html">Description of "Figure 2-2 Oracle Property Graph Architecture"</a></div>
                     <!-- class="figure" -->
                  </div>
                  <div>
                     <p><strong>Topics:</strong></p>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D">In-Memory Analyst</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A">Data Access Layer</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C">Storage Management</a><br></li>
                     </ul>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D" name="GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D"></a><h5 id="SPGDG-GUID-EA9A6C3D-0946-41A5-BB79-A5118BF5AA1D" class="sect5"><span class="enumeration_section">2.1.2.1 </span>In-Memory Analyst
                     </h5>
                     <div>
                        <p>The in-memory analyst layer enables you to analyze property graphs using parallel in-memory execution. It provides over 35 analytic functions, including path calculation, ranking, community detection, and recommendations.</p>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A" name="GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A"></a><h5 id="SPGDG-GUID-69E5D72E-2EA2-4B6E-B52E-C397F820355A" class="sect5"><span class="enumeration_section">2.1.2.2 </span>Data Access Layer
                     </h5>
                     <div>
                        <p>The data access layer provides a set of Java APIs that you can use to create and drop property graphs, add and remove vertices and edges, search for vertices and edges using key-value pairs, create text indexes, and perform other manipulations. The Java APIs include an implementation of TinkerPop Blueprints graph interfaces for the property graph data model. The APIs also integrate with the Apache Lucene and Apache SolrCloud, which are widely-adopted open-source text indexing and search engines.</p>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C" name="GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C"></a><h5 id="SPGDG-GUID-F0741F29-0FE0-472F-886A-096B5FC17E1C" class="sect5"><span class="enumeration_section">2.1.2.3 </span>Storage Management
                     </h5>
                     <div>
                        <p>Property graphs are stored in Oracle Database. Tables are used internally to model the vertices and edges of property graphs.</p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" name="GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24"></a><h3 id="SPGDG-GUID-B6C28C47-656F-4193-B70E-D6EC555F9D24" class="sect3"><span class="enumeration_section">2.2 </span>About Property Graph Data Formats
               </h3>
               <div>
                  <p>Several graph formats are supported for property graph data.</p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B">GraphML Data Format</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-8F01B553-22F0-429E-9018-A1C6F3655508">GraphSON Data Format</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13">GML Data Format</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70">Oracle Flat File Format</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B" name="GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B"></a><h4 id="SPGDG-GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B" class="sect4"><span class="enumeration_section">2.2.1 </span>GraphML Data Format
                  </h4>
                  <div>
                     <p>The GraphML file format uses XML to describe graphs. The example in this topic shows a GraphML description of the property graph shown in <a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">What Are Property Graphs?</a>.
                     </p>
                     <div class="example" id="GUID-D85BDA74-F0E3-4590-874E-DEBFD95CE30B__BHBJAHIE">
                        <p class="titleinexample">Example 2-1 GraphML Description of a Simple Property Graph</p><pre class="oac_no_warn" dir="ltr">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"&gt;
    &lt;key id="name" for="node" attr.name="name" attr.type="string"/&gt;
    &lt;key id="age" for="node" attr.name="age" attr.type="int"/&gt;
    &lt;key id="type" for="edge" attr.name="type" attr.type="string"/&gt;
    &lt;graph id="PG" edgedefault="directed"&gt;
        &lt;node id="1"&gt;
            &lt;data key="name"&gt;Alice&lt;/data&gt;
            &lt;data key="age"&gt;31&lt;/data&gt;
        &lt;/node&gt;
        &lt;node id="2"&gt;
            &lt;data key="name"&gt;Bob&lt;/data&gt;
            &lt;data key="age"&gt;27&lt;/data&gt;
        &lt;/node&gt;
        &lt;edge id="3" source="1" target="2" label="knows"&gt;
            &lt;data key="type"&gt;friends&lt;/data&gt;
        &lt;/edge&gt;
    &lt;/graph&gt;
&lt;/graphml&gt;
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="http://graphml.graphdrawing.org/">GraphML File Format</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-8F01B553-22F0-429E-9018-A1C6F3655508" name="GUID-8F01B553-22F0-429E-9018-A1C6F3655508"></a><h4 id="SPGDG-GUID-8F01B553-22F0-429E-9018-A1C6F3655508" class="sect4"><span class="enumeration_section">2.2.2 </span>GraphSON Data Format
                  </h4>
                  <div>
                     <p>The GraphSON file format is based on JavaScript Object Notation (JSON) for describing graphs. The example in this topic shows a GraphSON description of the property graph shown in <a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">What Are Property Graphs?</a>.
                     </p>
                     <div class="example" id="GUID-8F01B553-22F0-429E-9018-A1C6F3655508__BHBHABBB">
                        <p class="titleinexample">Example 2-2 GraphSON Description of a Simple Property Graph</p><pre class="oac_no_warn" dir="ltr">{
    "graph": {
        "mode":"NORMAL",
        "vertices": [
            {
                "name": "Alice",
                "age": 31,
                "_id": "1",
                "_type": "vertex"
            },
            {
                "name": "Bob",
                "age": 27,
                "_id": "2",
                "_type": "vertex"
            }       
        ],
        "edges": [
            {
                "type": "friends",
                "_id": "3",
                "_type": "edge",
                "_outV": "1",
                "_inV": "2",
                "_label": "knows"
            }
        ]
    }
}</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library">GraphSON Reader and Writer Library</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13" name="GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13"></a><h4 id="SPGDG-GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13" class="sect4"><span class="enumeration_section">2.2.3 </span>GML Data Format
                  </h4>
                  <div>
                     <p>The Graph Modeling Language (GML) file format uses ASCII to describe graphs. The example in this topic shows a GML description of the property graph shown in <a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">What Are Property Graphs?</a>.
                     </p>
                     <div class="example" id="GUID-B6EB163B-C03F-4720-B57F-78ADEB657B13__BHBDFBBB">
                        <p class="titleinexample">Example 2-3 GML Description of a Simple Property Graph</p><pre class="oac_no_warn" dir="ltr">graph [
   comment "Simple property graph"
   directed 1
   IsPlanar 1
   node [
      id 1
      label "1"
      name "Alice"
      age 31
        ]
   node [
      id 2
      label "2"
      name "Bob"
      age 27
        ]
   edge [
      source 1
      target 2
      label "knows"
      type "friends"
        ]
      ]</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf">GML: A Portable Graph File Format" by Michael Himsolt</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70" name="GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70"></a><h4 id="SPGDG-GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70" class="sect4"><span class="enumeration_section">2.2.4 </span>Oracle Flat File Format
                  </h4>
                  <div>
                     <p>The Oracle flat file format exclusively describes property graphs. It is more concise and provides better data type support than the other file formats. The Oracle flat file format uses two files for a graph description, one for the vertices and one for edges. Commas separate the fields of the records.</p>
                     <div class="example" id="GUID-15A4AE0C-2AF6-459B-A3D5-432434ECAD70__ORACLEFLATFILEDESCRIPTIONOFASIMPLEP-1152EB16">
                        <p class="titleinexample">Example 2-4 Oracle Flat File Description of a Simple Property Graph</p>
                        <p>The following shows the Oracle flat files that describe the simple property graph example shown in <a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">What Are Property Graphs?</a>.
                        </p>
                        <p><span class="bold">Vertex file:</span></p><pre class="oac_no_warn" dir="ltr">1,name,1,Alice,,
1,age,2,,31,
2,name,1,Bob,,
2,age,2,,27,
</pre><p><span class="bold">Edge file:</span></p><pre class="oac_no_warn" dir="ltr">1,1,2,knows,type,1,friends,, </pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="using-property-graphs-oracle-database.html#GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" title="A property graph can be defined in two flat files, specifically description files for the vertices and edges.">Oracle Flat File Format Definition</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" name="GUID-728A5FBC-998C-4675-9C0A-31C9195B737D"></a><h3 id="SPGDG-GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" class="sect3"><span class="enumeration_section">2.3 </span>Property Graph Schema Objects for Oracle Database
               </h3>
               <div>
                  <p>The property graph PL/SQL and Java APIs use special Oracle Database schema objects.</p>
                  <p>Oracle Spatial and Graph lets store, query, manipulate, and query property graph data in Oracle Database. For example, to create a property graph named myGraph, you can use either the Java APIs (oracle.pg.rdbms.OraclePropertyGraph) or the PL/SQL APIs (MDSYS.OPG_APIS package).  </p>
                  <p>With the PL/SQL API: </p><pre class="pre codeblock"><code>BEGIN
     opg_apis.create_pg(
           'myGraph',  
           dop =&gt; 4,             -- degree of parallelism
           num_hash_ptns =&gt; 8,   -- number of hash partitions used to store the graph
           tbs =&gt; 'USERS',       -- tablespace
           options =&gt; 'COMPRESS=T'
           );
END;
/
</code></pre><p>With the Java API:</p><pre class="pre codeblock"><code>  cfg = GraphConfigBuilder
            .forPropertyGraphRdbms()
            .setJdbcUrl("jdbc:oracle:thin:@127.0.0.1:1521:orcl")  
            .setUsername("&lt;your_user_name&gt;")
            .setPassword("&lt;your_password&gt;")  
            .setName("myGraph") 
            .setMaxNumConnections(8) 
            .setLoadEdgeLabel(false) 
            .build();

  OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);
</code></pre><p>After the property graph <code class="codeph">myGraph</code> is established in the database, several tables are created automatically in the user's schema, with the graph name as the prefix and VT$ or GE$ as the suffix. For example, for a graph named <code class="codeph">myGraph</code>, table myGraphVT$ is created to store vertices and their properties (K/V pairs), and table myGraphGE$ is created to store edges and their properties.
                  </p>
                  <p>For simplicity, only simple graph names are allowed, and they are case insensitive.</p>
                  <p>Additional internal tables are created with SS$, IT$, and GT$ suffixes, to store graph snapshots, text index metadata, and graph skeleton (topological structure), respectively.</p>
                  <p>The definitions of tables myGraphVT$ and myGraphGE$ are as follows. They are important for SQL-based analytics and SQL-based property graph query. In both the VT$ and GE$ tables, VTS, VTE, and FE are reserved columns; column SL is for the security label; and columns K, T, V, VN, and VT together store all information about a property (K/V pair) of a graph element. In the VT$ table, VID is a long integer for storing the vertex ID. In the GE$ table, EID, SVID, and DVID are long integer columns for storing edge ID, source (from) vertex ID, and destination (to) vertex ID, respectively. </p><pre class="pre codeblock"><code>SQL&gt; describe myGraph<span class="bold">VT$</span>
 Name                       Null?    Type
 ----------------------------------------- -------- ----------------------------
 VID                       NOT NULL NUMBER
 K                                  NVARCHAR2(3100)
 T                                  NUMBER(38)
 V                                  NVARCHAR2(15000)
 VN                                 NUMBER
 VT                                 TIMESTAMP(6) WITH TIME ZONE
 SL                                 NUMBER
 VTS                                DATE
 VTE                                DATE
 FE                                 NVARCHAR2(4000)


SQL&gt; describe myGraph<span class="bold">GE$</span>
 Name                       Null?    Type
 ----------------------------------------- -------- ----------------------------
 EID                        NOT NULL NUMBER
 SVID                       NOT NULL NUMBER
 DVID                       NOT NULL NUMBER
 EL                                  NVARCHAR2(3100)
 K                                   NVARCHAR2(3100)
 T                                   NUMBER(38)
 V                                   NVARCHAR2(15000)
 VN                                  NUMBER
 VT                                  TIMESTAMP(6) WITH TIME ZONE
 SL                                  NUMBER
 VTS                                 DATE
 VTE                                 DATE
 FE                                  NVARCHAR2(4000)
</code></pre><p>In the property graph schema design, a property value is stored in the VN column if the value has numeric data type (long, int, double, float, and so on), in the VT column if the value is a timestamp, or in the V column for Strings, boolean and other serializable data types. For better Oracle Text query support, a literal representation of the property value is saved in the V column even if the data type is numeric or timestamp. To differentiate all the supported data types, an integer ID is saved in the T column. </p>
                  <p>The K column in both VT$ and GE$ tables stores the property key. Each edge must have a label of String type, and the labels are stored in the EL column of the GE$ table.</p>
                  <p>For performance and scalability, both VT$ and GE$ tables are hash partitioned based on IDs, and the number of partitions is customizable. The number of partitions should be a value that is power of 2 (2, 4, 8, 16, and so on). The partitions are named sequentially starting from "p1", so for a property graph created with 8 partitions, the set of partitions will be "p1", "p2", ..., "p8".</p>
                  <p>To support international characters, NVARCHAR columns are used in VT$ and GE$ tables. Oracle highly recommends UTF8 as the default database character set. In addition, the V column has a size of 15000, which <span class="bold">requires </span> the enabling of 32K VARCHAR (<code class="codeph">MAX_STRING_SIZE&nbsp;=&nbsp;EXTENDED</code>).
                  </p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2">Default Indexes on Vertex (VT$) and Edge (GE$) Tables</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-10626028-5648-4BCB-9992-2E6488C1DA13">Flexibility in the Property Graph Schema</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2" name="GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2"></a><h4 id="SPGDG-GUID-78D0CA44-DA26-43BC-ABD8-64548544BCA2" class="sect4"><span class="enumeration_section">2.3.1 </span>Default Indexes on Vertex (VT$) and Edge (GE$) Tables
                  </h4>
                  <div>
                     <p>For query performance, several indexes on property graph tables are created by default. The index names follow the same convention as the table names, including using the graph name as the prefix. For example, for the property graph <code class="codeph">myGraph</code>, the following local indexes are created:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A unique index <code class="codeph">myGraphXQV$</code> <code class="codeph">on myGraphVT$(VID, K)</code></p>
                        </li>
                        <li>
                           <p>A unique index <code class="codeph">myGraphXQE$</code> on <code class="codeph">myGraphGE$(EID, K)</code></p>
                        </li>
                        <li>
                           <p>An index <code class="codeph">myGraphXSE$</code> on <code class="codeph">myGraphGE$(SVID, DVID, EID, VN)</code></p>
                        </li>
                        <li>
                           <p>An index <code class="codeph">myGraphXDE$</code> on <code class="codeph">myGraphGE$(DVID, SVID, EID, VN)</code></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-10626028-5648-4BCB-9992-2E6488C1DA13" name="GUID-10626028-5648-4BCB-9992-2E6488C1DA13"></a><h4 id="SPGDG-GUID-10626028-5648-4BCB-9992-2E6488C1DA13" class="sect4"><span class="enumeration_section">2.3.2 </span>Flexibility in the Property Graph Schema
                  </h4>
                  <div>
                     <p>The property graph schema design does not use a catalog or centralized repository of any kind. Each property graph is separately stored and managed by a schema of user's choice. A user's schema may have one or more property graphs.</p>
                     <p>This design provides considerable flexibility to users. For example:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Additional indexes can be added on demand.</p>
                        </li>
                        <li>
                           <p>Different property graphs can have a different set of indexes or compression options for the base tables.</p>
                        </li>
                        <li>
                           <p>Different property graphs can have different numbers of hash partitions.</p>
                        </li>
                        <li>
                           <p>You can even drop the XSE$ or XDE$ index for a property graph; however, for integrity you should keep the unique constraints.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED" name="GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED"></a><h3 id="SPGDG-GUID-E754CCD1-FB01-4644-A028-FEEA0ED683ED" class="sect3"><span class="enumeration_section">2.4 </span>Getting Started with Property Graphs
               </h3>
               <div>
                  <p>Follow these steps to get started with property graphs.</p>
                  <ol>
                     <li><span>The first time you use property graphs, ensure that the software is installed and operational.</span></li>
                     <li><span>Create your Java programs, using the classes provided in the Java API. </span></li>
                  </ol>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="using-property-graphs-oracle-database.html#GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" title="Creating a property graph involves using the Java APIs to create the property graph and objects in it.">Using Java APIs for Property Graph Data</a></li>
                     </ul>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" name="GUID-734D16D3-E8AA-4097-B644-14D80A4C7958"></a><h3 id="SPGDG-GUID-734D16D3-E8AA-4097-B644-14D80A4C7958" class="sect3"><span class="enumeration_section">2.5 </span>Using Java APIs for Property Graph Data
               </h3>
               <div>
                  <p>Creating a property graph involves using the Java APIs to create the property graph and objects in it.</p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44">Overview of the Java APIs</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-6212D301-F439-4B4B-A36F-73194D404979">Parallel Loading of Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC">Parallel Retrieval of Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469">Using an Element Filter Callback for Subgraph Extraction</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4">Using Optimization Flags on Reads over Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36">Adding and Removing Attributes of a Property Graph Subgraph</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68">Getting Property Graph Metadata</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43">Merging New Data into an Existing Property Graph</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470">Opening and Closing a Property Graph Instance</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344">Creating Vertices</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01">Creating Edges</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417">Deleting Vertices and Edges</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34">Reading a Graph from a Database into an Embedded In-Memory Analyst</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C">Specifying Labels for Vertices</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7">Building an In-Memory Graph</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F">Dropping a Property Graph</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44" name="GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44"></a><h4 id="SPGDG-GUID-85A4E0F7-0C3C-411D-912A-FD4744FADE44" class="sect4"><span class="enumeration_section">2.5.1 </span>Overview of the Java APIs
                  </h4>
                  <div>
                     <p>The Java APIs that you can use for property graphs include the following:</p>
                  </div>
                  <div>
                     <p><strong>Topics:</strong></p>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138">Oracle Spatial and Graph Property Graph Java APIs</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328">TinkerPop Blueprints Java APIs</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84">Oracle Database Property Graph Java APIs</a><br></li>
                     </ul>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138" name="GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138"></a><h5 id="SPGDG-GUID-42D0F0B5-43A6-47E7-AEA9-B18A6A27D138" class="sect5"><span class="enumeration_section">2.5.1.1 </span>Oracle Spatial and Graph Property Graph Java APIs
                     </h5>
                     <div>
                        <p>Oracle Spatial and Graph property graph support provides database-specific APIs for Oracle Database. The data access layer API (<code class="codeph">oracle.pg.*</code>) implements TinkerPop Blueprints APIs, text search, and indexing for property graphs stored in Oracle Database.
                        </p>
                        <p>To use the Oracle Spatial and Graph API, import the classes into your Java program:</p><pre class="oac_no_warn" dir="ltr">import oracle.pg.common.*;
import oracle.pg.text.*;
import oracle.pg.rdbms.*;
import oracle.pgx.config.*;
import oracle.pgx.common.types.*;
</pre><p>Also include <a href="using-property-graphs-oracle-database.html#GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328">TinkerPop Blueprints Java APIs</a>.
                        </p>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328" name="GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328"></a><h5 id="SPGDG-GUID-5EC28F8B-49CA-42FB-A070-823C43BD9328" class="sect5"><span class="enumeration_section">2.5.1.2 </span>TinkerPop Blueprints Java APIs
                     </h5>
                     <div>
                        <p>TinkerPop Blueprints supports the property graph data model. The API provides utilities for manipulating graphs, which you use primarily through the Spatial and Graph property graph data access layer Java APIs.</p>
                        <p>To use the Blueprints APIs, import the classes into your Java program:</p><pre class="oac_no_warn" dir="ltr">import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.Edge;</pre></div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="http://www.tinkerpop.com/docs/javadocs/blueprints/2.3.0/index.html">Blueprints: A Property Graph Model Interface API</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84" name="GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84"></a><h5 id="SPGDG-GUID-7D4751AA-40D6-4B4C-A117-1D639B342E84" class="sect5"><span class="enumeration_section">2.5.1.3 </span>Oracle Database Property Graph Java APIs
                     </h5>
                     <div>
                        <p>The Oracle Database property graph Java APIs enable you to create and populate  a property graph stored in Oracle Database.</p>
                        <p>To use these Java APIs, import the classes into your Java program. For example:</p><pre class="oac_no_warn" dir="ltr">import oracle.pg.rdbms.*; 
import java.sql.*;
</pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6212D301-F439-4B4B-A36F-73194D404979" name="GUID-6212D301-F439-4B4B-A36F-73194D404979"></a><h4 id="SPGDG-GUID-6212D301-F439-4B4B-A36F-73194D404979" class="sect4"><span class="enumeration_section">2.5.2 </span>Parallel Loading of Graph Data
                  </h4>
                  <div>
                     <p>A Java API is provided for performing parallel loading of graph data.</p>
                     <p>Oracle Spatial and Graph supports loading graph data into Oracle Database. Graph data can be loaded into the property graph using the following approaches:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Vertices and/or edges can be added incrementally using the <code class="codeph">graph.addVertex(Object id)/graph.addEdge(Object id)</code> APIs.
                           </p>
                        </li>
                        <li>
                           <p>Graph data can be loaded from a file in Oracle flat-File format in parallel using the <code class="codeph">OraclePropertyGraphDataLoader </code>API.
                           </p>
                        </li>
                        <li>
                           <p>A property graph in GraphML, GML, or GraphSON can be loaded using  <code class="codeph">GMLReader</code>, <code class="codeph">GraphMLReader</code>, and <code class="codeph">GraphSONReader</code>, respectively.
                           </p>
                        </li>
                     </ul>
                     <p>This topic focuses on the parallel loading of a property graph in Oracle-defined flat file format.</p>
                     <p>Parallel data loading provides an optimized solution to data loading where the vertices (or edges) input streams are split into multiple chunks and loaded into Oracle Database in parallel. This operation involves two main overlapping phases: </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Splitting. The vertices and edges input streams are split into multiple chunks and saved into a temporary input stream. The number of chunks is determined by the degree of parallelism specified</p>
                        </li>
                        <li>
                           <p>Graph loading. For each chunk, a loader thread is created to process information about the vertices (or edges) information and to load the data into the property graph tables.</p>
                        </li>
                     </ul>
                     <p><code class="codeph">OraclePropertyGraphDataLoader</code> supports parallel data loading using several different options:
                     </p>
                  </div>
                  <div>
                     <p><strong>Topics:</strong></p>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7">JDBC-Based Data Loading</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3">External Table-Based Data Loading</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F">SQL*Loader-Based Data Loading</a><br></li>
                     </ul>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7" name="GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7"></a><h5 id="SPGDG-GUID-40B77BBF-9FEC-412A-8A3F-8DB41993E4C7" class="sect5"><span class="enumeration_section">2.5.2.1 </span>JDBC-Based Data Loading
                     </h5>
                     <div>
                        <p>JDBC-based data loading uses Java Database Connectivity (JDBC) APIs to load the graph data into Oracle Database. In this option, the vertices (or edges) in the given input stream will be spread among multiple chunks by the splitter thread. Each chunk will be processed by a different loader thread that inserts all the elements in the chunk into a temporary work table using JDBC batching. The number of splitter and loader threads used is determined by the degree of parallelism (DOP) specified by the user.</p>
                        <p>After all the graph data is loaded into the temporary work tables, all the data stored in the temporary work tables is loaded into the property graph VT$ and GE$ tables. </p>
                        <p>The following example loads the graph data from a vertex and edge files in Oracle-defined flat-file format using a JDBC-based parallel data loading with a degree of parallelism of 48.</p><pre class="pre codeblock"><code>    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    opgdl = OraclePropertyGraphDataLoader.getInstance(); 
    opgdl.loadData(opg, szOPVFile, szOPEFile, 48 /* DOP */, 1000 /* batch size */, true /* rebuild index flag */, "pddl=t,pdml=t" /* options */); 
);
</code></pre><p>To optimize the performance of the data loading operations, a set of flags and hints can be specified when calling the JDBC-based data loading. These hints include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">DOP:</span>  The degree of parallelism to use when loading the data. This parameter determines the number of chunks to generate when splitting the file as well as the number of loader threads to use when loading the data into the property graph VT$ and GE$ tables.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Batch Size:</span>  An integer specifying the batch size to use for Oracle update statements in batching mode. The default batch size used in the JDBC-based data loading is 1000.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Rebuild index:</span> If this flag is set to <code class="codeph">true</code>, the data loader will disable all the indexes and constraints defined over the property graph where the data will be loaded. After all the data is loaded into the property graph, all the indexes and constraints will be rebuilt.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Load options:</span> An option (or multiple options delimited by commas) to optimize the data loading operations. These options include:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>NO_DUP=T: Assumes the input data does not have invalid duplicates. In a valid property graph, each vertex (edge) can at most have one value for a given property key. In an invalid property graph, a vertex (edge) may have two or more values for a particular key. As an example, a vertex, v, has two key/value pairs: name/"John" and name/"Johnny" and they share the same key. </p>
                                 </li>
                                 <li>
                                    <p>PDML=T: Enables parallel execution for DML operations for the database session used in the data loader.  This hint is used to improve the performance of long-running batching jobs.</p>
                                 </li>
                                 <li>
                                    <p>PDDL=T: Enables parallel execution for DDL operations for the database session used in the data loader. This hint is used to improve the performance of long-running batching jobs.</p>
                                 </li>
                                 <li>
                                    <p>KEEP_WORK_TABS=T: Skips cleaning and deleting the working tables after the data loading is complete. This is for debugging use only.</p>
                                 </li>
                                 <li>
                                    <p>KEEP_TMP_FILES=T: Skips removing the temporary splitter files after the data loading is complete. This is for debug only.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Splitter Flag:</span> An integer value defining the type of files or streams used in the splitting phase to generate the data chunks used in the graph loading phase. The temporary files can be created as regular files (0), named pipes (1), or piped streams (2). By default, JDBC-based data loading uses 
                              </p>
                              <p>Piped streams to handle intermediate data chunksPiped streams are for JDBC-based loader only. They are purely in-memory and efficient, and do not require any files created on the operating system.</p>
                              <p>Regular files consume space on the local operating system, while named pipes appear as empty files on the local operating system. Note that not every operating system has support for named pipes.</p>
                           </li>
                           <li>
                              <p><span class="bold">Split File Prefix:</span> The prefix used for the temporary files or pipes created when the splitting phase is generating the data chunks for the graph loading. By default, the prefix “OPG_Chunk” is used for regular files and “OPG_Pipe” is used for named pipes. 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Tablespace:</span> The name of the tablespace where all the temporary work tables will be created.
                              </p>
                           </li>
                        </ul>
                        <p>Subtopics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>JDBC-Based Data Loading with Multiple Files</p>
                           </li>
                           <li>
                              <p>JDBC-Based Data Loading with Partitions</p>
                           </li>
                           <li>
                              <p>JDBC-based Parallel Data Loading Using Fine-Tuning</p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3">JDBC-Based Data Loading with Multiple Files</p>
                           <p>JDBC-based data loading also supports loading vertices and edges from multiple files or input streams into the database. The following code fragment loads multiple vertex and edge files using the parallel data loading APIs. In the example, two string arrays szOPVFiles and szOPEFiles are used to hold the input files. </p><pre class="pre codeblock"><code>    String[] szOPVFiles = new String[] {"../../data/connections-p1.opv", 
                                        "../../data/connections-p2.opv"}; 
    String[] szOPEFiles = new String[] {"../../data/connections-p1.ope",                          
                                        "../../data/connections-p2.ope"}; 
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    opgdl = OraclePropertyGraphDataLoader.getInstance(); 
    opgdl.loadData(opg, szOPVFiles, szOPEFiles, 48 /* DOP */,
                   1000 /* batch size */, 
                   true /* rebuild index flag */, 
                   "pddl=t,pdml=t" /* options */); 
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3">JDBC-Based Data Loading with Partitions</p>
                           <p>When dealing with graph data from thousands to hundreds of thousands elements, the JDBC-based data loading API allows loading the graph data in Oracle Flat file format into Oracle Database using logical partitioning.</p>
                           <p>Each partition represents a subset of vertices (or edges) in the graph data file of size is approximately the number of distinct element IDs in the file divided by the number of partitions. Each partition is identified by an integer ID in the range of [0, Number of partitions &#x2013; 1]. </p>
                           <p>To use parallel data loading with partitions, you must specify the total number of logical partitions to use and the partition offset (start ID) in addition to the base parameters used in the <code class="codeph">loadData</code> API. To fully load a graph data file or input stream into the database, you must execute the data loading operation as many times as the defined number of partitions. For example, to load the graph data from a file using two partitions, there should be two data loading API calls using an offset of 0 and 1. Each call to the data loader can be processed using multiple threads or a separate Java client on a single system or multiple systems.
                           </p>
                           <p>Note that this approach is intended to be used with a single vertex file (or input stream) and a single edge file (or input stream). Additionally, this option requires disabling the indices and constraints on vertices and edges. These indices and constraints must be rebuilt after <span class="bold"><span class="italic">all</span></span> partitions have been loaded.
                           </p>
                           <p>The following example loads the graph data using two partitions. Each partition is loaded by one Java process <code class="codeph">DataLoaderWorker</code>. To coordinate multiple workers, a coordinator process named DataLoaderCoordinator is used. This example does the following
                           </p>
                           <ol>
                              <li>
                                 <p>Disables all indexes and constraints,</p>
                              </li>
                              <li>
                                 <p>Creates a temporary working table, loaderProgress, that records the data loading progress (that is, how many workers have finished their work. All <code class="codeph">DataLoaderWorker</code> processes start loading data after the working table is created.
                                 </p>
                              </li>
                              <li>
                                 <p>Increments the progress by 1.</p>
                              </li>
                              <li>
                                 <p>Keeps polling (using the <code class="codeph">DataLoaderCoordinator</code> process) the progress until  all <code class="codeph">DataLoaderWorker</code> processes are done.
                                 </p>
                              </li>
                              <li>
                                 <p>Rebuilds all indexes and constraints.</p>
                              </li>
                           </ol>
                           <p>Note: In <code class="codeph">DataLoaderWorker</code>,  the flag <code class="codeph">SKIP_INDEX</code> should be set to <code class="codeph">true</code> and the flag <code class="codeph">rebuildIndx</code> should be set to <code class="codeph">false</code>. 
                           </p><pre class="pre codeblock"><code>// start DataLoaderCoordinator, set dop = 8 and number of partitions = 2
java DataLoaderCoordinator  jdbcUrl  user password pg 8 2
// start the first DataLoaderWorker, set dop = 8, number of partitions = 2, partition offset = 0
java DataLoaderWorker jdbcUrl user password pg  8 2 0
// start the first DataLoaderWorker, set dop = 8, number of partitions = 2, partition offset = 1
java DataLoaderWorker jdbcUrl user password pg  8 2 1
</code></pre><p>The <code class="codeph">DataLoaderCoordinator</code> first disables all indexes and constraints. It then creates a table named loaderProgress and inserts one row with column progress = 0.
                           </p><pre class="pre codeblock"><code>public class DataLoaderCoordinator {
        public static void main(String[] szArgs) {
          String jdbcUrl = szArgs[0];
          String user = szArgs[1];
          String password = szArgs[2];
          String graphName = szArgs[3];
          int dop = Integer.parseInt(szArgs[4]);
          int numLoaders = Integer.parseInt(szArgs[5]);

          Oracle oracle = null;
          OraclePropertyGraph opg = null;
          try {
            oracle = new Oracle(jdbcUrl, user, password);
            OraclePropertyGraphUtils.dropPropertyGraph(oracle, graphName);
            opg = OraclePropertyGraph.getInstance(oracle, graphName);

            List&lt;String&gt; vIndices = opg.disableVertexTableIndices();
            List&lt;String&gt; vConstraints = opg.disableVertexTableConstraints();
            List&lt;String&gt; eIndices = opg.disableEdgeTableIndices();
            List&lt;String&gt; eConstraints = opg.disableEdgeTableConstraints();

            String szStmt = null;
            try {
              szStmt = "drop table loaderProgress";
              opg.getOracle().executeUpdate(szStmt);
            }
            catch (SQLException ex) {
              if (ex.getErrorCode() == 942) {
                // table does not exist. ignore
              }
              else {
                throw new OraclePropertyGraphException(ex);
              }
            }

            szStmt = "create table loaderProgress (progress integer)";
            opg.getOracle().executeUpdate(szStmt);
            szStmt = "insert into loaderProgress (progress) values (0)";
            opg.getOracle().executeUpdate(szStmt);
            opg.getOracle().getConnection().commit();
            while (true) {
              if (checkLoaderProgress(oracle) == numLoaders) {
                break;
              } else {
                Thread.sleep(1000);
              }
            }

            opg.rebuildVertexTableIndices(vIndices, dop, null);
            opg.rebuildVertexTableConstraints(vConstraints, dop, null);
            opg.rebuildEdgeTableIndices(eIndices, dop, null);
            opg.rebuildEdgeTableConstraints(eConstraints, dop, null);
          }
          catch (IOException ex) {
            throw new OraclePropertyGraphException(ex);
          }
          catch (SQLException ex) {
            throw new OraclePropertyGraphException(ex);
          }
          catch (InterruptedException ex) {
            throw new OraclePropertyGraphException(ex);
          }
          catch (Exception ex) {
            throw new OraclePropertyGraphException(ex);
          }
          finally {
            try {
              if (opg != null) {
                opg.shutdown();
              }
              if (oracle != null) {
                oracle.dispose();
              }
            }
            catch (Throwable t) {
              System.out.println(t);
            }
          }

        }

        private static int checkLoaderProgress(Oracle oracle) {
          int result = 0;
          ResultSet rs = null;

          try {
            String szStmt = "select progress from loaderProgress";
            rs = oracle.executeQuery(szStmt);
            if (rs.next()) {
              result =  rs.getInt(1);
            }

          }
          catch (Exception ex) {
            throw new OraclePropertyGraphException(ex);
          }
          finally {
            try {
              if (rs != null) {
                rs.close();
              }
	    }
            catch (Throwable t) {
              System.out.println(t);
            }
          }
          return result;
        }
}
     
public class DataLoaderWorker {

        public static void main(String[] szArgs) {
          String jdbcUrl = szArgs[0];
          String user = szArgs[1];
          String password = szArgs[2];
          String graphName = szArgs[3];
          int dop = Integer.parseInt(szArgs[4]);
          int numLoaders = Integer.parseInt(szArgs[5]);
          int offset = Integer.parseInt(szArgs[6]);

          Oracle oracle = null;
          OraclePropertyGraph opg = null;

          try {
            oracle = new Oracle(jdbcUrl, user, password);
            opg = OraclePropertyGraph.getInstance(oracle, graphName, 8, dop, null/*tbs*/, ",SKIP_INDEX=T,");
            OraclePropertyGraphDataLoader opgdal = OraclePropertyGraphDataLoader.getInstance();

            while (true) {
              if (checkLoaderProgress(oracle) == 1) {
                break;
              } else {
                Thread.sleep(1000);
              }
            }

            String opvFile = "../../../data/connections.opv";
            String opeFile = "../../../data/connections.ope";
            opgdal.loadData(opg, opvFile, opeFile, dop, numLoaders, offset, 1000, false, null, "pddl=t,pdml=t");

            updateLoaderProgress(oracle);
          }
          catch (SQLException ex) {
            throw new OraclePropertyGraphException(ex);
          }
          catch (InterruptedException ex) {
            throw new OraclePropertyGraphException(ex);
          }
          finally {
            try {
              if (opg != null) {
                opg.shutdown();
              }
              if (oracle != null) {
                oracle.dispose();
              }
            }
            catch (Throwable t) {
              System.out.println(t);
            }
          }
        }

        private static int checkLoaderProgress(Oracle oracle) {
          int result = 0;
          ResultSet rs = null;

          try {
            String szStmt = "select count(*) from loaderProgress";
            rs = oracle.executeQuery(szStmt);
            if (rs.next()) {
              result = rs.getInt(1);
            }
          }
          catch (SQLException ex) {
            if (ex.getErrorCode() == 942) {
              // table does not exist. ignore
            } else {
              throw new OraclePropertyGraphException(ex);
            }
          }
          finally {
            try {
              if (rs != null) {
                rs.close();
              }
            }
            catch (Throwable t) {
              System.out.println(t);
            }
          }
          return result;
        }

        private static void updateLoaderProgress(Oracle oracle) {
          ResultSet rs = null;

          try {
            String szStmt = "update loaderProgress set progress = progress + 1";
            oracle.executeUpdate(szStmt);
            oracle.getConnection().commit();
          }
          catch (Exception ex) {
            throw new OraclePropertyGraphException(ex);
          }
          finally {
            try {
              if (rs != null) {
                rs.close();
              }
            }
            catch (Throwable t) {
              System.out.println(t);
            }
          }
        }
}</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3">JDBC-based Parallel Data Loading Using Fine-Tuning</p>
                           <p>JDBC-based data loading supports fine-tuning the subset of data from a line to be loaded, as well as the ID offset to use when loading the elements into the property graph instance. You can specify the subset of data to load from a file by specifying the maximum number of lines to read from the file and the offset line number (start position) for both vertices and edges. This way, data will be loaded from the offset line number until the maximum number of lines has been read. IIf the maximum line number is -1, the loading process will scan the data until reaching the end of file.</p>
                           <p>Because multiple graph data files may have some ID collisions or overlap, the JDBC-based data loading allows you to define a vertex and edge ID offset. This way, the ID of each loaded vertex will be the sum of the original vertex ID and the given vertex ID offset. Similarly, the ID of each loaded edge will be generated from the sum of the original edge ID and the given edge ID offset. Note that the vertices and edge files must be correlated, because the in/out vertex ID for the loaded edges will be modified with respect to the specified vertex ID offset. This operation is supported only in data loading using a single logical partition.</p>
                           <p>The following code fragment loads the first 100 vertices and edges lines from the given graph data file. In this example, an ID offset 0 is used, which indicates no ID adjustment is performed.</p><pre class="pre codeblock"><code>    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 
    // Run the data loading using fine tuning 
    long lVertexOffsetlines = 0; 
    long lEdgeOffsetlines = 0; 
    long lVertexMaxlines = 100; 
    long lEdgeMaxlines = 100;
    long lVIDOffset = 0;
    long lEIDOffset = 0;
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
    
    opgdl.loadData(opg, szOPVFile, szOPEFile, 
                   lVertexOffsetlines /* offset of lines to start loading from 
              partition, default 0 */, 
                   lEdgeOffsetlines /* offset of lines to start loading from 
                   partition, default 0 */, 
      lVertexMaxlines /* maximum number of lines to start loading from 
                        partition, default -1 (all lines in partition) */, 
      lEdgeMaxlines /* maximum number of lines to start loading from 
                       partition, default -1 (all lines in partition) */, 
      lVIDOffset /* vertex ID offset: the vertex ID will be original 
                    vertex ID + offset, default 0 */, 
      lEIDOffset /* edge ID offset: the edge ID will be original edge ID 
                    + offset, default 0 */, 
      4 /* DOP */, 
      1 /* Total number of partitions, default 1 */, 
      0 /* Partition to load: from 0 to totalPartitions - 1, default 0 */, 
      OraclePropertyGraphDataLoader.PIPEDSTREAM /* splitter flag */, 
      "chunkPrefix" /* prefix: the prefix used to generate split chunks 
                       for regular files or named pipes */, 
      1000 /* batch size: batch size of Oracle update in batching mode. 
              Default value is 1000 */, 
      true /* rebuild index */, 
      null /* table space name*/,
      "pddl=t,pdml=t" /* options: enable parallel DDL and DML */);
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3" name="GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3"></a><h5 id="SPGDG-GUID-4AB847C3-7EE6-4C18-B4AF-0F885277EBA3" class="sect5"><span class="enumeration_section">2.5.2.2 </span>External Table-Based Data Loading
                     </h5>
                     <div>
                        <p>External table-based data loading uses an external table to load the graph data into Oracle Database.  External table loading allows users to access the data in external sources as if it were in a regular relational table in the database. In this case, the vertices (or edges) in the given input stream will be spread among multiple chunks by the splitter thread. Each chunk will be processed by a different loader thread that is in charge of passing  all the elements in the chunk to Oracle Database. The number of splitter and loader threads used is determined by the degree of parallelism (DOP) specified by the user.</p>
                        <p>After the external tables are automatically created by the data loading logic, the loader will read from the external tables and load all the data into the property graph schema tables (VT$ and GE$). </p>
                        <p>External-table based data loading requires a directory object where the files read by the external tables will be stored. This directory can be created by running the following scripts in a SQL*Plus environment:</p><pre class="pre codeblock"><code>create or replace directory tmp_dir as '/tmppath/';
grant read, write on directory tmp_dir to public;
</code></pre><p>The following code fragment loads the graph data from a vertex and edge files in Oracle Flat-file format using an external table-based parallel data loading with a degree of parallelism of 48.</p><pre class="pre codeblock"><code>    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 
    String szExtDir = "tmp_dir";
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    opgdl = OraclePropertyGraphDataLoader.getInstance(); 
    opgdl.loadDataWithExtTab(opg, szOPVFile, szOPEFile, 48 /*DOP*/, 
                             true /*named pipe flag: setting the flag to true will use 
                                   named pipe based splitting; otherwise, regular file 
                                   based splitting would be used*/, 
                             szExtDir /* database directory object */, 
                             true /*rebuild index */, 
                             "pddl=t,pdml=t,NO_DUP=T" /*options */);
</code></pre><p>To optimize the performance of the data loading operations, a set of flags and hints can be specified when calling the External table-based data loading. These hints include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">DOP:</span> The degree of parallelism to use when loading the data. This parameter determines the number of chunks to generate when splitting the file, as well as the number of loader threads to use when loading the data into the property graph VT$ and GE$ tables.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Rebuild index:</span> If this flag is set to <code class="codeph">true</code>, the data loader will disable all the indexes and constraints defined over the property graph where the data will be loaded. After all the data is loaded into the property graph, all the indexes and constraints will be rebuilt.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Load options:</span> An option (or multiple options delimited by commas) to optimize the data loading operations. These options include:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>NO_DUP=T: Chooses a faster way to load the data into the property graph tables as no validation for duplicate Key/value pairs will be conducted.</p>
                                 </li>
                                 <li>
                                    <p>PDML=T: Enables parallel execution for DML operations for the database session used in the data loader.  This hint is used to improve the performance of long-running batching jobs.</p>
                                 </li>
                                 <li>
                                    <p>PDDL=T: Enables parallel execution for DDL operations for the database session used in the data loader. This hint is used to improve the performance of long-running batching jobs.</p>
                                 </li>
                                 <li>
                                    <p>KEEP_WORK_TABS=T: Skips cleaning and deleting the working tables after the data loading is complete. This is for debugging use only.</p>
                                 </li>
                                 <li>
                                    <p>KEEP_TMP_FILES=T: Skips removing the temporary splitter files after the data loading is complete. This is for debugging use only.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><span class="bold">Splitter Flag:</span> An integer value defining the type of files or streams used in the splitting phase to generate the data chunks used in the graph loading phase. The temporary files can be created as regular files (0) or named pipes (1).
                              </p>
                              <p>By default, External table-based data loading uses regular files to handle temporary files for data chunks. Named pipes can only be used on operating system that supports them. It is generally a good practice to use regular files together with DBFS.</p>
                           </li>
                           <li>
                              <p><span class="bold">Split File Prefix:</span> The prefix used for the temporary files or pipes created when the splitting phase is generating the data chunks for the graph loading. By default, the prefix “Chunk” is used for regular files and “Pipe” is used for named pipes.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Tablespace:</span> The name of the tablespace where all the temporary work tables will be created.
                              </p>
                           </li>
                        </ul>
                        <p>As with the JDBC-based data loading, external table-based data loading supports parallel data loading using a single file, multiple files, partitions, and fine-tuning.</p>
                        <p>Subtopics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>External Table-Based Data Loading with Multiple Files</p>
                           </li>
                           <li>
                              <p>External table-based Data Loading with Partitions</p>
                           </li>
                           <li>
                              <p>External Table-Based Parallel Data Loading Using Fine-Tuning</p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3">External Table-Based Data Loading with Multiple Files</p>
                           <p>External table-based data loading also supports loading vertices and edges from multiple files or input streams into the database. The following code fragment loads multiple vertex and edge files using the parallel data loading APIs. In the example, two string arrays <code class="codeph">szOPVFiles</code> and <code class="codeph">szOPEFiles</code> are used to hold the input files.
                           </p><pre class="pre codeblock"><code>    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 
    String szExtDir = "tmp_dir";
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    opgdl = OraclePropertyGraphDataLoader.getInstance(); 
    opgdl.loadDataWithExtTab(opg, szOPVFile, szOPEFile, 48 /* DOP */, 
                             true /* named pipe flag */, 
                             szExtDir /* database directory object */, 
                             true /* rebuild index flag */, 
                             "pddl=t,pdml=t" /* options */);
</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3">External table-based Data Loading with Partitions</p>
                           <p>When dealing with a very large property graph, the external table-based data loading API allows loading the graph data in Oracle flat file format into Oracle Database using logical partitioning. Each partition represents a subset of vertices (or edges) in the graph data file of size that is approximately the number of distinct element IDs in the file divided by the number of partitions. Each partition is identified by an integer ID in the range of [0, Number of partitions &#x2013; 1].</p>
                           <p>To use parallel data loading with partitions, you must specify the total number of partitions to use and the partition offset besides the base parameters used in the <code class="codeph">loadDataWithExtTab</code> API. To fully load a graph data file or input stream into the database, you must execute the data loading operation as many times as the defined number of partitions. For example, to load the graph data from a file using two partitions, there should be two data loading API calls using an offset of 0 and 1. Each call to the data loader can be processed using multiple threads or a separate Java client on a single system or multiple systems.
                           </p>
                           <p>Note that this approach is intended to be used with a single vertex file (or input stream) and a single edge file (or input stream). Additionally, this option requires disabling the indexes and constraints on vertices and edges. These indices and constraints must be rebuilt after all partitions have been loaded.</p>
                           <p>The example for JDBC-based data loading with partitions can be easily migrated to work as external-table based loading with partitions. The only needed changes are to replace API <code class="codeph">loadData()</code> with <code class="codeph">loadDataWithExtTab()</code>, and supply some additional input parameters such as the database directory object.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3">External Table-Based Parallel Data Loading Using Fine-Tuning</p>
                           <p>External table-based data loading also supports fine-tuning the subset of data from a line to be loaded, as well as the ID offset to use when loading the elements into the property graph instance. You can specify the subset of data to load from a file by specifying the maximum number of lines to read from the file as well as the offset line number for both vertices and edges. This way, data will be loaded from the offset line number until the maximum number of lines has been read. If the maximum line number is -1, the loading process will scan the data until reaching the end of file.</p>
                           <p>Because graph data files may have some ID collisions, the external table-based data loading allows you to define a vertex and edge ID offset. This way, the ID of each loaded vertex will be obtained from the sum of the original vertex ID with the given vertex ID offset. Similarly, the ID of each loaded edge will be generated from the sum of the original edge ID with the given edge ID offset. Note that the vertices and edge files must be correlated, because the in/out vertex ID for the loaded edges will be modified with respect to the specified vertex ID offset. This operation is supported only in a data loading using a single partition.</p>
                           <p>The following code fragment loads the first 100 vertices and edges from the given graph data file. In this example, no ID offset is provided.</p><pre class="pre codeblock"><code>    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 

    // Run the data loading using fine tuning 
    long lVertexOffsetlines = 0; 
    long lEdgeOffsetlines = 0; 
    long lVertexMaxlines = 100; 
    long lEdgeMaxlines = 100;
    long lVIDOffset = 0;
    long lEIDOffset = 0;
    String szExtDir = "tmp_dir";

    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
    
    opgdl.loadDataWithExtTab(opg, szOPVFile, szOPEFile, 
                             lVertexOffsetlines /* offset of lines to start loading 
                                                   from partition, default 0 */, 
                             lEdgeOffsetlines /* offset of lines to start loading from 
                                                 partition, default 0 */, 
                             lVertexMaxlines /* maximum number of lines to start 
                                                loading from partition, default -1 
                                               (all lines in partition) */, 
                             lEdgeMaxlines /* maximum number of lines to start loading 
                                              from partition, default -1 (all lines in 
                                              partition) */, 
                             lVIDOffset /* vertex ID offset: the vertex ID will be 
                                          original vertex ID + offset, default 0 */, 
                             lEIDOffset /* edge ID offset: the edge ID will be 
                                          original edge ID + offset, default 0 */, 
                             4 /* DOP */, 
                             1 /* Total number of partitions, default 1 */, 
                             0 /* Partition to load (from 0 to totalPartitions - 1, 
                                  default 0) */, 
                             OraclePropertyGraphDataLoader.NAMEDPIPE 
                             /* splitter flag */, 
                             "chunkPrefix" /* prefix */, 
                             szExtDir /* database directory object */, 
                             true /* rebuild index flag */, 
                             "pddl=t,pdml=t" /* options */);
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F" name="GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F"></a><h5 id="SPGDG-GUID-9E4F7C89-A28B-4F54-8132-C6F2F8395A6F" class="sect5"><span class="enumeration_section">2.5.2.3 </span>SQL*Loader-Based Data Loading
                     </h5>
                     <div>
                        <p>SQL*Loader-based data loading uses Oracle SQL*Loader to load the graph data into Oracle Database. SQL*Loader loads data from external files into Oracle Database tables. In this case, the vertices (or edges) in the given input stream will be spread among multiple chunks by the splitter thread. Each chunk will be processed by a different loader thread that inserts all the elements in the chunk into a temporary work table using SQL*Loader. The number of splitter and loader threads used is determined by the degree of parallelism (DOP) specified by the user.</p>
                        <p>After all the graph data is loaded into the temporary work table, the graph loader will load all the data stored in the temporary work tables into the property graph VT$ and GE$ tables.</p>
                        <p>The following code fragment loads the graph data from a vertex and edge files in Oracle flat-file format using a SQL-based parallel data loading with a degree of parallelism of 48. To use the APIs, the path to the SQL*Loader must be specified.</p><pre class="pre codeblock"><code>    String szUser = "username";
    String szPassword = "password";
    String szDbId = "db12c"; /*service name of the database*/
    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 
    String szSQLLoaderPath = "&lt;YOUR_ORACLE_HOME&gt;/bin/sqlldr";
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 

    opgdl = OraclePropertyGraphDataLoader.getInstance(); 
    opgdl.loadDataWithSqlLdr(opg, szUser, szPassword, szDbId, 
                             szOPVFile, szOPEFile, 
                             48 /* DOP */, 
                             true /*named pipe flag */, 
                             szSQLLoaderPath /* SQL*Loader path: the path to 
                                                bin/sqlldr*/, 
                             true /*rebuild index */, 
                             "pddl=t,pdml=t" /* options */);
</code></pre><p>As with JDBC-based data loading, SQL*Loader-based data loading supports parallel data loading using a single file, multiple files, partitions, and fine-tuning.</p>
                        <p>Subtopics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>SQL*Loader-Based Data Loading with Multiple Files</p>
                           </li>
                           <li>
                              <p>SQL*Loader-Based Data Loading with Partitions</p>
                           </li>
                           <li>
                              <p>SQL*Loader-Based Parallel Data Loading Using Fine-Tuning</p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3">SQL*Loader-Based Data Loading with Multiple Files</p>
                           <p>SQL*Loader-based data loading supports loading vertices and edges from multiple files or input streams into the database. The following code fragment loads multiple vertex and edge files using the parallel data loading APIs. In the example, two string arrays <code class="codeph">szOPVFiles</code> and <code class="codeph">szOPEFiles</code> are used to hold the input files.
                           </p><pre class="pre codeblock"><code>    String szUser = "username";
    String szPassword = "password";
    String szDbId = "db12c"; /*service name of the database*/
    String[] szOPVFiles = new String[] {"../../data/connections-p1.opv", 
                                        "../../data/connections-p2.opv"}; 
    String[] szOPEFiles = new String[] {"../../data/connections-p1.ope", 
                                        "../../data/connections-p2.ope"}; 
    String szSQLLoaderPath = "../../../dbhome_1/bin/sqlldr";
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 

    opgdl = OraclePropertyGraphDataLoader.getInstance(); 
    opgdl. loadDataWithSqlLdr (opg, szUser, szPassword, szDbId, 
                               szOPVFiles, szOPEFiles, 
                               48 /* DOP */, 
                               true /* named pipe flag */, 
                               szSQLLoaderPath /* SQL*Loader path */, 
                               true /* rebuild index flag */, 
                               "pddl=t,pdml=t" /* options */);</code></pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3">SQL*Loader-Based Data Loading with Partitions</p>
                           <p>When dealing with a large property graph, the SQL*Loader-based data loading API allows loading the graph data in Oracle flat-file format into Oracle Database using logical partitioning. Each partition represents a subset of vertices (or edges) in the graph data file of size that is approximately the number of distinct element IDs in the file divided by the number of partitions. Each partition is identified by an integer ID in the range of [0, Number of partitions &#x2013; 1]. </p>
                           <p>To use parallel data loading with partitions, you must specify the total number of partitions to use and the partition offset, in addition to the base parameters used in the <code class="codeph">loadDataWithSqlLdr</code> API. To fully load a graph data file or input stream into the database, you must execute the data loading operation as many times as the defined number of partitions. For example, to load the graph data from a file using two partitions, there should be two data loading API calls using an offset of 0 and 1. Each call to the data loader can be processed using multiple threads or a separate Java client on a single system or multiple systems.
                           </p>
                           <p>Note that this approach is intended to be used with a single vertex file (or input stream) and a single edge file (or input stream). Additionally, this option requires disabling the indexes and constraints on vertices and edges. These indexes and constraints must be rebuilt after all partitions have been loaded.</p>
                           <p>The example for JDBC-based data loading with partitions can be easily migrated to work as SQL*Loader- based loading with partitions. The only changes needed are to replace API <code class="codeph">loadData()</code> with <code class="codeph">loadDataWithSqlLdr()</code>, and supply some additional input parameters such as the location of SQL*Loader.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3">SQL*Loader-Based Parallel Data Loading Using Fine-Tuning</p>
                           <p>SQL Loader-based data loading supports fine-tuning the subset of data from a line to be loaded, as well as the ID offset to use when loading the elements into the property graph instance. You can specify the subset of data to load from a file by specifying the maximum number of lines to read from the file and the offset line number for both vertices and edges. This way, data will be loaded from the offset line number until the maximum number of lines has been read. If the maximum line number is -1, the loading process will scan the data until reaching the end of file.</p>
                           <p>Because graph data files may have some ID collisions, the SQL Loader-based data loading allows you to define a vertex and edge ID offset. This way, the ID of each loaded vertex will be obtained from the sum of the original vertex ID with the given vertex ID offset. Similarly, the ID of each loaded edge will be generated from the sum of the original edge ID with the given edge ID offset. Note that the vertices and edge files must be correlated, because the in/out vertex ID for the loaded edges will be modified with respect to the specified vertex ID offset.  This operation is supported only in a data loading using a single partition.</p>
                           <p>The following code fragment loads the first 100 vertices and edges from the given graph data file. In this example, no ID offset is provided.</p><pre class="pre codeblock"><code>    String szUser = "username";
    String szPassword = "password";
    String szDbId = "db12c"; /* service name of the database */
    String szOPVFile = "../../data/connections.opv"; 
    String szOPEFile = "../../data/connections.ope"; 
    String szSQLLoaderPath = "../../../dbhome_1/bin/sqlldr";
    
    // Run the data loading using fine tuning 
    long lVertexOffsetlines = 0; 
    long lEdgeOffsetlines = 0; 
    long lVertexMaxlines = 100; 
    long lEdgeMaxlines = 100;
    long lVIDOffset = 0;
    long lEIDOffset = 0;
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance( args, szGraphName); 
    OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
    
    opgdl.loadDataWithSqlLdr(opg, szUser, szPassword, szDbId, 
                             szOPVFile, szOPEFile, 
                             lVertexOffsetlines /* offset of lines to start loading 
                                                   from partition, default 0*/, 
                             lEdgeOffsetlines /* offset of lines to start loading from 
                                                 partition, default 0*/, 
                             lVertexMaxlines /* maximum number of lines to start 
                                                loading from partition, default -1 
                                                (all lines in partition)*/, 
                             lEdgeMaxlines /* maximum number of lines to start loading 
                                              from partition, default -1 (all lines in 
                                              partition) */, 
                             lVIDOffset /* vertex ID offset: the vertex ID will be 
                                           original vertex ID + offset, default 0 */, 
                             lEIDOffset /* edge ID offset: the edge ID will be 
                                           original edge ID + offset, default 0 */, 
                             48 /* DOP */, 
                             1 /* Total number of partitions, default 1 */, 
                             0 /* Partition to load (from 0 to totalPartitions - 1, 
                                  default 0) */, 
                             OraclePropertyGraphDataLoader.NAMEDPIPE 
                             /* splitter flag */, 
                             "chunkPrefix" /* prefix */, 
                             szSQLLoaderPath /* SQL*Loader path: the path to 
                                                bin/sqlldr*/, 
                             true /* rebuild index */,
                             "pddl=t,pdml=t" /* options */);
</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC" name="GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC"></a><h4 id="SPGDG-GUID-5CC8B971-DDCD-46CF-86EF-CDFD69E20FDC" class="sect4"><span class="enumeration_section">2.5.3 </span>Parallel Retrieval of Graph Data
                  </h4>
                  <div>
                     <p>The parallel property graph query provides a simple Java API to perform parallel scans on vertices (or edges). Parallel retrieval is an optimized solution taking advantage of the distribution of the data across table partitions, so each partition is queried using a separate database connection.</p>
                     <p>Parallel retrieval will produce an array where each element holds all the vertices (or edges) from a specific partition (split). The subset of shards queried will be separated by the given start split ID and the size of the connections array provided. This way, the subset will consider splits in the range of [start, start - 1 + size of connections array]. Note that an integer ID (in the range of [0, N - 1]) is assigned to all the splits in the vertex table with N splits.</p>
                     <p>The following code loads a property graph, opens an array of connections, and executes a parallel query to retrieve all vertices and edges using the opened connections. The number of calls to the <code class="codeph">getVerticesPartitioned (getEdgesPartitioned)</code> method is controlled by the total number of splits and the number of connections used.
                     </p><pre class="pre codeblock"><code>OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create connections used in parallel query
Oracle[] oracleConns = new Oracle[dop];
Connection[]   conns = new Connection[dop];
for (int i = 0; i &lt; dop; i++) { 
  oracleConns[i] = opg.getOracle().clone();
  conns[i] = oracleConns[i].getConnection();
}

long lCountV = 0;
// Iterate over all the vertices’ partitionIDs to count all the vertices
for (int partitionID = 0; partitionID &lt; opg.getVertexPartitionsNumber(); 
     partitionID += dop) { 
  Iterable&lt;Vertex&gt;[] iterables 
        = opg.getVerticesPartitioned(conns /* Connection array */, 
                                     true /* skip store to cache */, 
                                     partitionID /* starting partition */); 
  lCountV += consumeIterables(iterables); /* consume iterables using 
                                             threads */
}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCountV);

long lCountE = 0;
// Iterate over all the edges’ partitionIDs to count all the edges
for (int partitionID = 0; partitionID &lt; opg.getEdgeTablePartitionIDs(); 
     partitionID += dop) { 
  Iterable&lt;Edge&gt;[] iterables 
          = opg.getEdgesPartitioned(conns /* Connection array */, 
                                    true /* skip store to cache */, 
                                    partitionID /* starting partitionID */); 
  lCountE += consumeIterables(iterables); /* consume iterables using 
                                             threads */
}

// Count all edges
System.out.println("Edges found using parallel query: " + lCountE);

// Close the connections to the database after completed
for (int idx = 0; idx &lt; conns.length; idx++) { 
   conns[idx].close();
}
</code></pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469" name="GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469"></a><h4 id="SPGDG-GUID-216595F2-BBA0-4FAB-AC6C-1FDF25D46469" class="sect4"><span class="enumeration_section">2.5.4 </span>Using an Element Filter Callback for Subgraph Extraction
                  </h4>
                  <div>
                     <p>Oracle Spatial and Graph provides support for an easy subgraph extraction using user-defined element filter callbacks. An element filter callback defines a set of conditions that a vertex (or an edge) must meet in order to keep it in the subgraph. Users can define their own element filtering by implementing the <code class="codeph">VertexFilterCallback</code> and <code class="codeph">EdgeFilterCallback</code> API interfaces.
                     </p>
                     <p>The following code fragment implements a <code class="codeph">VertexFilterCallback</code> that validates if a vertex does not have a political role and its origin is the United States.
                     </p><pre class="oac_no_warn" dir="ltr">/**
* VertexFilterCallback to retrieve a vertex from the United States 
* that does not have a political role 
*/
private static class NonPoliticianFilterCallback 
implements VertexFilterCallback
{
@Override
public boolean keepVertex(OracleVertexBase vertex) 
{
String country = vertex.getProperty("country");
String role = vertex.getProperty("role");

if (country != null &amp;&amp; country.equals("United States")) {
if (role == null || !role.toLowerCase().contains("political")) {
return true;
}
}

return false;
}

public static NonPoliticianFilterCallback getInstance()
{
return new NonPoliticianFilterCallback();
}
}
</pre><p>The following code fragment implements an <code class="codeph">EdgeFilterCallback</code> that uses the <code class="codeph">VertexFilterCallback</code> to keep only edges connected to the given input vertex, and whose connections are not politicians and come from the United States.
                     </p><pre class="oac_no_warn" dir="ltr">/**
 * EdgeFilterCallback to retrieve all edges connected to an input 
 * vertex with "collaborates" label, and whose vertex is from the 
 * United States with a role different than political
*/
private static class CollaboratorsFilterCallback 
implements EdgeFilterCallback
{
private VertexFilterCallback m_vfc;
private Vertex m_startV;

public CollaboratorsFilterCallback(VertexFilterCallback vfc, 
 Vertex v) 
{
m_vfc = vfc;
m_startV = v; 
}

@Override
public boolean keepEdge(OracleEdgeBase edge) 
{
if ("collaborates".equals(edge.getLabel())) {
if (edge.getVertex(Direction.IN).equals(m_startV) &amp;&amp; 
m_vfc.keepVertex((OracleVertex) 
edge.getVertex(Direction.OUT))) {
return true;
}
else if (edge.getVertex(Direction.OUT).equals(m_startV) &amp;&amp; 
 m_vfc.keepVertex((OracleVertex) 
edge.getVertex(Direction.IN))) {
return true;
}
}

return false;
}

public static CollaboratorsFilterCallback
getInstance(VertexFilterCallback vfc, Vertex v)
{
return new CollaboratorsFilterCallback(vfc, v);
}

}
</pre><p>Using the filter callbacks previously defined, the following code fragment loads a property graph, creates an instance of the filter callbacks and later gets all of Barack Obama’s collaborators who are not politicians and come from the United States.</p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// VertexFilterCallback to retrieve all people from the United States // who are not politicians
<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance();
</span>
// Initial vertex: Barack Obama
Vertex v = opg.getVertices("name", "Barack Obama").iterator().next();

// EdgeFilterCallback to retrieve all collaborators of Barack Obama 
// from the United States who are not politicians
<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance(npvfc, v);
</span>
Iterable&lt;&lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges((String[])null /* Match any 
of the properties */,
cefc /* Match the 
EdgeFilterCallback */
);</span>
Iterator&lt;&lt;Edge&gt; iter = obamaCollabs.iterator();

System.out.println("\n\n--------Collaborators of Barack Obama from " +
 " the US and non-politician\n\n");
long countV = 0;
while (iter.hasNext()) {
Edge edge = iter.next(); // get the edge
// check if obama is the IN vertex
if (edge.getVertex(Direction.IN).equals(v)) {
 System.out.println(edge.getVertex(Direction.OUT) + "(Edge ID: " + 
 edge.getId() + ")"); // get out vertex
}
else {
System.out.println(edge.getVertex(Direction.IN)+ "(Edge ID: " + 
 edge.getId() + ")"); // get in vertex
}

countV++;
}
</pre><p>By default, all reading operations such as get all vertices, get all edges (and parallel approaches) will use the filter callbacks associated with the property graph using the methods <code class="codeph">opg.setVertexFilterCallback(vfc)</code> and <code class="codeph">opg.setEdgeFilterCallback(efc)</code>. If there is no filter callback set, then all the vertices (or edges) and edges will be retrieved.
                     </p>
                     <p>The following code fragment uses the default edge filter callback set on the property graph to retrieve the edges.</p><pre class="oac_no_warn" dir="ltr">// VertexFilterCallback to retrieve all people from the United States // who are not politicians
<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance();
</span>
// Initial vertex: Barack Obama
Vertex v = opg.getVertices("name", "Barack Obama").iterator().next();

// EdgeFilterCallback to retrieve all collaborators of Barack Obama 
// from the United States who are not politicians
<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance(npvfc, v);

opg.setEdgeFilterCallback(cefc);
</span>
Iterable&lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges()</span>;
Iterator&lt;Edge&gt; iter = obamaCollabs.iterator();

System.out.println("\n\n--------Collaborators of Barack Obama from " +
 " the US and non-politician\n\n");
long countV = 0;
while (iter.hasNext()) {
Edge edge = iter.next(); // get the edge
// check if obama is the IN vertex
if (edge.getVertex(Direction.IN).equals(v)) {
 System.out.println(edge.getVertex(Direction.OUT) + "(Edge ID: " + 
 edge.getId() + ")"); // get out vertex
}
else {
System.out.println(edge.getVertex(Direction.IN)+ "(Edge ID: " + 
 edge.getId() + ")"); // get in vertex
}

countV++;
}
</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4" name="GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4"></a><h4 id="SPGDG-GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4" class="sect4"><span class="enumeration_section">2.5.5 </span>Using Optimization Flags on Reads over Property Graph Data
                  </h4>
                  <div>
                     <p>Oracle Spatial and Graph provides support for optimization flags to improve graph iteration performance. Optimization flags allow processing vertices (or edges) as objects with none or minimal information, such as ID, label, and/or incoming/outgoing vertices. This way, the time required to process each vertex (or edge) during iteration is reduced.</p>
                     <p>The following table shows the optimization flags available when processing vertices (or edges) in a property graph.</p>
                     <div class="tblformal" id="GUID-D33E2232-BE9C-444D-BC5C-2B4E62CAF2C4__OPTIMIZATIONFLAGSANDDESCRIPTIONSFOR-110D35B6">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Optimization flags and descriptions for processing vertices (or edges) in a property graph. Column 1 is Optimization Flags and column 2 is Description." frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d2789e2423"><span class="bold">Optimization Flag</span></th>
                                 <th align="left" valign="bottom" width="20%" id="d2789e2426"><span class="bold">Description</span></th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d2789e2431" headers="d2789e2423 ">DO_NOT_CREATE_OBJECT</td>
                                 <td align="left" valign="top" width="20%" headers="d2789e2431 d2789e2426 ">Use a predefined constant object when processing vertices or edges.</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d2789e2436" headers="d2789e2423 ">JUST_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d2789e2436 d2789e2426 ">Construct edge objects with ID only when processing edges.</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d2789e2441" headers="d2789e2423 ">JUST_LABEL_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d2789e2441 d2789e2426 ">Construct edge objects with ID and label only when processing edges.</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d2789e2446" headers="d2789e2423 ">JUST_LABEL_VERTEX_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d2789e2446 d2789e2426 ">Construct edge objects with ID, label, and in/out vertex IDs only when processing edges</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d2789e2451" headers="d2789e2423 ">JUST_VERTEX_EDGE_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d2789e2451 d2789e2426 ">Construct edge objects with just ID and in/out vertex IDs when processing edges.</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d2789e2456" headers="d2789e2423 ">JUST_VERTEX_ID</td>
                                 <td align="left" valign="top" width="20%" headers="d2789e2456 d2789e2426 ">Construct vertex objects with ID only when processing vertices.</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>The following code fragment uses a set of optimization flags to retrieve only all the IDs from the vertices and edges in the property graph. The objects retrieved by reading all vertices and edges will include only the IDs and no Key/Value properties or additional information.</p><pre class="oac_no_warn" dir="ltr">import oracle.pg.common.OraclePropertyGraphBase.OptimizationFlag;
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 


// Optimization flag to retrieve only vertices IDs
<span class="bold">OptimizationFlag optFlagVertex = OptimizationFlag.JUST_VERTEX_ID;
</span>
// Optimization flag to retrieve only edges IDs
<span class="bold">OptimizationFlag optFlagEdge = OptimizationFlag.JUST_EDGE_ID;
</span>
// Print all vertices
Iterator&lt;Vertex&gt; vertices = 
<span class="bold">opg.getVertices((String[])null /* Match any of the 
properties */,
null /* Match the VertexFilterCallback */, 
optFlagVertex /* optimization flag */ 
).iterator();
</span>
System.out.println("----- Vertices IDs----");
long vCount = 0;
while (vertices.hasNext()) {
OracleVertex v = vertices.next();
System.out.println((Long) v.getId());
vCount++;
}
System.out.println("Vertices found: " + vCount);


// Print all edges
Iterator&lt;Edge&gt; edges =
<span class="bold">opg.getEdges((String[])null /* Match any of the properties */,
null /* Match the EdgeFilterCallback */, 
optFlagEdge /* optimization flag */ 
).iterator();
</span>
System.out.println("----- Edges ----");
long eCount = 0;
while (edges.hasNext()) {
Edge e = edges.next();
System.out.println((Long) e.getId());
eCount++;
}
System.out.println("Edges found: " + eCount);
</pre><p>By default, all reading operations such as get all vertices, get all edges (and parallel approaches) will use the optimization flag associated with the property graph using the method <code class="codeph">opg.setDefaultVertexOptFlag(optFlagVertex)</code> and <code class="codeph">opg.setDefaultEdgeOptFlag(optFlagEdge)</code>. If the optimization flags for processing vertices and edges are not defined, then all the information about the vertices and edges will be retrieved.
                     </p>
                     <p>The following code fragment uses the default optimization flags set on the property graph to retrieve only all the IDs from its vertices and edges.</p><pre class="oac_no_warn" dir="ltr">import oracle.pg.common.OraclePropertyGraphBase.OptimizationFlag;

// Optimization flag to retrieve only vertices IDs
OptimizationFlag optFlagVertex = OptimizationFlag.JUST_VERTEX_ID;

// Optimization flag to retrieve only edges IDs
OptimizationFlag optFlagEdge = OptimizationFlag.JUST_EDGE_ID;

<span class="bold">opg.setDefaultVertexOptFlag(optFlagVertex);
opg.setDefaultEdgeOptFlag(optFlagEdge);
</span>
Iterator&lt;Vertex&gt; vertices = <span class="bold">opg.getVertices().iterator();</span>
System.out.println("----- Vertices IDs----");
long vCount = 0;
while (vertices.hasNext()) {
OracleVertex v = vertices.next();
System.out.println((Long) v.getId());
vCount++;
}
System.out.println("Vertices found: " + vCount);


// Print all edges
Iterator&lt;Edge&gt; edges = <span class="bold">opg.getEdges().iterator();
</span>System.out.println("----- Edges ----");
long eCount = 0;
while (edges.hasNext()) {
Edge e = edges.next();
System.out.println((Long) e.getId());
eCount++;
}
System.out.println("Edges found: " + eCount);
</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36" name="GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36"></a><h4 id="SPGDG-GUID-991EA4C2-1DC0-413F-BF3C-D7B71537AA36" class="sect4"><span class="enumeration_section">2.5.6 </span>Adding and Removing Attributes of a Property Graph Subgraph
                  </h4>
                  <div>
                     <p>Oracle Spatial and Graph supports updating attributes (key/value pairs) to a subgraph of vertices and/or edges by using a user-customized operation callback. An operation callback defines a set of conditions that a vertex (or an edge) must meet in order to update it (either add or remove the given attribute and value). </p>
                     <p>You can define your own attribute operations by implementing the <code class="codeph">VertexOpCallback</code> and <code class="codeph">EdgeOpCallback</code> API interfaces. You must override the <code class="codeph">needOp</code> method, which defines the conditions to be satisfied by the vertices (or edges) to be included in the update operation, as well as the <code class="codeph">getAttributeKeyName</code> and <code class="codeph">getAttributeKeyValue</code> methods, which return the key name and value, respectively, to be used when updating the elements.
                     </p>
                     <p>The following code fragment implements a <code class="codeph">VertexOpCallback</code> that operates over the <code class="codeph">obamaCollaborator</code> attribute associated only with Barack Obama collaborators. The value of this property is specified based on the role of the collaborators.
                     </p><pre class="oac_no_warn" dir="ltr">private static class CollaboratorsVertexOpCallback 
<span class="bold">implements VertexOpCallback</span>
{
private OracleVertexBase m_obama;
private List&lt;Vertex&gt; m_obamaCollaborators;

public CollaboratorsVertexOpCallback(OraclePropertyGraph opg)
{
// Get a list of Barack Obama'sCollaborators
m_obama = (OracleVertexBase) opg.getVertices("name", 
 "Barack Obama")
.iterator().next();

Iterable&lt;Vertex&gt; iter = m_obama.getVertices(Direction.BOTH, 
"collaborates");
m_obamaCollaborators = OraclePropertyGraphUtils.listify(iter);
}

public static CollaboratorsVertexOpCallback 
getInstance(OraclePropertyGraph opg)
{
return new CollaboratorsVertexOpCallback(opg);
}

/**
 * Add attribute if and only if the vertex is a collaborator of Barack 
 * Obama
*/
@Override
public boolean <span class="bold">needOp(OracleVertexBase v)</span>
{
return m_obamaCollaborators != null &amp;&amp; 
 m_obamaCollaborators.contains(v);
}

@Override
public String <span class="bold">getAttributeKeyName(OracleVertexBase v)</span>
{
return "obamaCollaborator";
}

/**
 * Define the property's value based on the vertex role
 */
@Override
public Object <span class="bold">getAttributeKeyValue(OracleVertexBase v)</span>
{
String role = v.getProperty("role");
role = role.toLowerCase();
if (role.contains("political")) {
return "political";
}
else if (role.contains("actor") || role.contains("singer") ||
 role.contains("actress") || role.contains("writer") ||
 role.contains("producer") || role.contains("director")) {
return "arts";
}
else if (role.contains("player")) {
return "sports";
}
else if (role.contains("journalist")) {
return "journalism";
}
else if (role.contains("business") || role.contains("economist")) {
return "business";
}
else if (role.contains("philanthropist")) {
return "philanthropy";
}
return " ";
}
}
</pre><p>The following code fragment implements an <code class="codeph">EdgeOpCallback</code> that operates over the <code class="codeph">obamaFeud</code> attribute associated only with Barack Obama feuds. The value of this property is specified based on the role of the collaborators.
                     </p><pre class="oac_no_warn" dir="ltr">private static class FeudsEdgeOpCallback 
<span class="bold">implements EdgeOpCallback</span>
{
private OracleVertexBase m_obama;
private List&lt;Edge&gt; m_obamaFeuds;

public FeudsEdgeOpCallback(OraclePropertyGraph opg)
{
// Get a list of Barack Obama's feuds
m_obama = (OracleVertexBase) opg.getVertices("name", 
 "Barack Obama")
.iterator().next();

Iterable&lt;Vertex&gt; iter = m_obama.getVertices(Direction.BOTH, 
"feuds");
m_obamaFeuds = OraclePropertyGraphUtils.listify(iter);
}

public static FeudsEdgeOpCallback getInstance(OraclePropertyGraph opg)
{
return new FeudsEdgeOpCallback(opg);
}

/**
 * Add attribute if and only if the edge is in the list of Barack Obama's 
 * feuds
*/
@Override
public boolean <span class="bold">needOp(OracleEdgeBase e)</span>
{
return m_obamaFeuds != null &amp;&amp; m_obamaFeuds.contains(e);
}

@Override
public String <span class="bold">getAttributeKeyName(OracleEdgeBase e)</span>
{
return "obamaFeud";
}

/**
 * Define the property's value based on the in/out vertex role
 */
@Override
public Object <span class="bold">getAttributeKeyValue(OracleEdgeBase e)</span>
{
OracleVertexBase v = (OracleVertexBase) e.getVertex(Direction.IN);
if (m_obama.equals(v)) {
v = (OracleVertexBase) e.getVertex(Direction.OUT);
}
String role = v.getProperty("role");
role = role.toLowerCase();

if (role.contains("political")) {
return "political";
}
else if (role.contains("actor") || role.contains("singer") ||
 role.contains("actress") || role.contains("writer") ||
 role.contains("producer") || role.contains("director")) {
return "arts";
}
else if (role.contains("journalist")) {
return "journalism";
}
else if (role.contains("player")) {
return "sports";
}
else if (role.contains("business") || role.contains("economist")) {
return "business";
}
else if (role.contains("philanthropist")) {
return "philanthropy";
}
return " ";
}
}
</pre><p>Using the operations callbacks defined previously, the following code fragment loads a property graph, creates an instance of the operation callbacks, and later adds the attributes into the pertinent vertices and edges using the <code class="codeph">addAttributeToAllVertices</code> and <code class="codeph">addAttributeToAllEdges</code> methods in <code class="codeph">OraclePropertyGraph</code>.
                     </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create the vertex operation callback
<span class="bold">CollaboratorsVertexOpCallback cvoc = CollaboratorsVertexOpCallback.getInstance(opg);</span>

// Add attribute to all people collaborating with Obama based on their role
<span class="bold">opg.addAttributeToAllVertices(cvoc, true /** Skip store to Cache */, dop);</span>

// Look up for all collaborators of Obama
Iterable&lt;Vertex&gt; collaborators = opg.getVertices("obamaCollaborator", "political");
System.out.println("Political collaborators of Barack Obama " + getVerticesAsString(collaborators));

collaborators = opg.getVertices("obamaCollaborator", "business");
System.out.println("Business collaborators of Barack Obama " + 
getVerticesAsString(collaborators));

// Add an attribute to all people having a feud with Barack Obama to set
// the type of relation they have
<span class="bold">FeudsEdgeOpCallback feoc = FeudsEdgeOpCallback.getInstance(opg);
opg.addAttributeToAllEdges(feoc, true /** Skip store to Cache */, dop);</span>

// Look up for all feuds of Obama
Iterable&lt;Edge&gt; feuds = opg.getEdges("obamaFeud", "political");
System.out.println("\n\nPolitical feuds of Barack Obama " + getEdgesAsString(feuds));

feuds = opg.getEdges("obamaFeud", "business");
System.out.println("Business feuds of Barack Obama " + 
getEdgesAsString(feuds));
</pre><p>The following code fragment defines an implementation of <code class="codeph">VertexOpCallback</code> that can be used to remove vertices having value philanthropy for attribute <code class="codeph">obamaCollaborator</code>, then call the API <code class="codeph">removeAttributeFromAllVertices</code>; It also defines an implementation of <code class="codeph">EdgeOpCallback</code> that can be used to remove edges having value business for attribute <code class="codeph">obamaFeud</code>, then call the API <code class="codeph">removeAttributeFromAllEdges</code>.
                     </p><pre class="oac_no_warn" dir="ltr">System.out.println("\n\nRemove 'obamaCollaborator' property from all the" + 
 "philanthropy collaborators");
PhilanthropyCollaboratorsVertexOpCallback pvoc = PhilanthropyCollaboratorsVertexOpCallback.getInstance();

<span class="bold">opg.removeAttributeFromAllVertices(pvoc);</span>

System.out.println("\n\nRemove 'obamaFeud' property from all the" + "business feuds");
BusinessFeudsEdgeOpCallback beoc = BusinessFeudsEdgeOpCallback.getInstance();

<span class="bold">opg.removeAttributeFromAllEdges(beoc);</span>

/**
 * Implementation of a EdgeOpCallback to remove the "obamaCollaborators" 
 * property from all people collaborating with Barack Obama that have a 
 * philanthropy role
 */
private static class PhilanthropyCollaboratorsVertexOpCallback implements VertexOpCallback
{
  public static PhilanthropyCollaboratorsVertexOpCallback getInstance()
  {
     return new PhilanthropyCollaboratorsVertexOpCallback();
  }
  
  /**
   * Remove attribute if and only if the property value for   
   * obamaCollaborator is Philanthropy
   */
  @Override
  public boolean needOp(OracleVertexBase v)
  {
    String type = v.getProperty("obamaCollaborator");
    return type != null &amp;&amp; type.equals("philanthropy");
  }

  @Override
  public String getAttributeKeyName(OracleVertexBase v)
  {
    return "obamaCollaborator";
  }

  /**
   * Define the property's value. In this case can be empty
   */
  @Override
  public Object getAttributeKeyValue(OracleVertexBase v)
  {
    return " ";
  }
}

/**
 * Implementation of a EdgeOpCallback to remove the "obamaFeud" property
 * from all connections in a feud with Barack Obama that have a business role
 */
private static class BusinessFeudsEdgeOpCallback implements EdgeOpCallback
{
  public static BusinessFeudsEdgeOpCallback getInstance()
  {
    return new BusinessFeudsEdgeOpCallback();
  }

  /**
   * Remove attribute if and only if the property value for obamaFeud is       
   * business
   */
  @Override
  public boolean needOp(OracleEdgeBase e)
  {
    String type = e.getProperty("obamaFeud");
    return type != null &amp;&amp; type.equals("business");
  }

 @Override
 public String getAttributeKeyName(OracleEdgeBase e)
 {
   return "obamaFeud";
 }

 /**
  * Define the property's value. In this case can be empty
  */
  @Override
  public Object getAttributeKeyValue(OracleEdgeBase e)
  {
    return " ";
  }
}
</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68" name="GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68"></a><h4 id="SPGDG-GUID-F97996AC-8DE0-4F8A-9789-09FF1A473B68" class="sect4"><span class="enumeration_section">2.5.7 </span>Getting Property Graph Metadata
                  </h4>
                  <div>
                     <p>You can get graph metadata and statistics, such as all graph names in the database; for each graph, getting the minimum/maximum vertex ID, the minimum/maximum edge ID, vertex property names, edge property names, number of splits in graph vertex, and the edge table that supports parallel table scans.</p>
                     <p>The following code fragment gets the metadata and statistics of the existing property graphs stored in an Oracle database.</p><pre class="oac_no_warn" dir="ltr">// Get all graph names in the database
List&lt;String&gt; graphNames = OraclePropertyGraphUtils.getGraphNames(dbArgs);

for (String graphName : graphNames) {
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args, 
graphName);

System.err.println("\n Graph name: " + graphName);
System.err.println(" Total vertices: " + 
 <span class="bold">opg.countVertices(dop)</span>);
 
System.err.println(" Minimum Vertex ID: " + 
 <span class="bold">opg.getMinVertexID(dop)</span>);
System.err.println(" Maximum Vertex ID: " + 
 <span class="bold">opg.getMaxVertexID(dop)</span>);

Set&lt;String&gt; propertyNamesV = new HashSet&lt;String&gt;();
<span class="bold">opg.getVertexPropertyNames(dop, 0 /* timeout,0 no timeout */,
 propertyNamesV);</span>

System.err.println(" Vertices property names: " + 
getPropertyNamesAsString(propertyNamesV));

System.err.println("\n\n Total edges: " + <span class="bold">opg.countEdges(dop)</span>);
System.err.println(" Minimum Edge ID: " + <span class="bold">opg.getMinEdgeID(dop)</span>);
System.err.println(" Maximum Edge ID: " + <span class="bold">opg.getMaxEdgeID(dop)</span>);

Set&lt;String&gt; propertyNamesE = new HashSet&lt;String&gt;();
<span class="bold">opg.getEdgePropertyNames(dop, 0 /* timeout,0 no timeout */, 
 propertyNamesE);</span>

System.err.println(" Edge property names: " +
getPropertyNamesAsString(propertyNamesE));

System.err.println("\n\n Table Information: ");
System.err.println("Vertex table number of splits: " + 
 (<span class="bold">opg.getVertexPartitionsNumber()</span>));
System.err.println("Edge table number of splits: " + 
 (<span class="bold">opg.getEdgePartitionsNumber()</span>));
}</pre></div>
               </div>
               <div class="sect3"><a id="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43" name="GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43"></a><h4 id="SPGDG-GUID-0D1255E4-CE0B-4E2F-B78F-BAF569B7DE43" class="sect4"><span class="enumeration_section">2.5.8 </span>Merging New Data into an Existing Property Graph
                  </h4>
                  <div>
                     <p>In addition to loading graph data into an empty property graph in Oracle Database, you can merge new graph data into an existing (empty or non-empty) graph. As with data loading, data merging splits the input vertices and edges into multiple chunks and merges them with the existing graph in database in parallel.</p>
                     <p>When doing the merging, the flows are different depends on whether there is an overlap between new graph data and existing graph data. <span class="italic">Overlap</span> here means that the same key of a graph element may have different values in the new and existing graph data. For example, key <code class="codeph">weight</code> of the vertex with ID 1 may have value 0.8 in the new graph data and value 0.5 in the existing graph data. In this case, you must specify whether the new value or the existing value should be used for the key.
                     </p>
                     <p>The following options are available for graph data merging: JDB-based, external table-based, and SQL loader-based merging.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>JDBC-Based Graph Data Merging</p>
                        </li>
                        <li>
                           <p>External Table-Based Data Merging</p>
                        </li>
                        <li>
                           <p>SQL Loader-Based Data Merging</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3"><span class="bold">JDBC-Based Graph Data Merging</span></p>
                        <p>JDBC-based data merging uses Java Database Connectivity (JDBC) APIs to load the new graph data into Oracle Database and then merge the new graph data into an existing graph.</p>
                        <p>The following example merges the new graph data from vertex and edge files szOPVFile and szOPEFile in Oracle-defined Flat-file format with an existing graph named opg, using a JDBC-based data merging with a DOP (degree of parallelism) of 48, batch size of 1000, and specified data merging options.</p><pre class="pre codeblock"><code>String szOPVFile = "../../data/connectionsNew.opv"; 
String szOPEFile = "../../data/connectionsNew.ope"; 
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance(); 
opgdl.mergeData(opg, szOPVFile, szOPEFile, 
     48 /*DOP*/, 
     1000 /*Batch Size*/, 
     true /*Rebuild index*/,  
     "pdml=t, pddl=t, no_dup=t, use_new_val_for_dup_key=t" /*Merge options*/);
</code></pre><p>To optimize the performance of the data merging operations, a set of flags and hints can be specified in the merging options parameter when calling the JDBC-based data merging. These hints include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">DOP:</span> The degree of parallelism to use when merging the data. This parameter determines the number of chunks to generate when splitting the file, as well as the number of loader threads to use when merging the data into the property graph VT$ and GE$ tables.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Batch Size:</span> An integer specifying the batch size to use for Oracle JDBC statements in batching mode.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Rebuild index:</span> If set to true, the data loader will disable all the indexes and constraints defined over the property graph into which the data will be loaded. After all the data is merged into the property graph, all the original indexes and constraints will be rebuilt and enabled.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Merge options: </span>An option (or multiple options separated by commas) to optimize the data merging operations. These options include:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>PDML=T: enables parallel execution for DML operations for the database session used in the data loader.  This hint is used to improve the performance of long-running batching jobs.</p>
                                 </li>
                                 <li>
                                    <p>PDDL=T: enables parallel execution for DDL operations for the database session used in the data loader. This hint is used to improve the performance of long-running batching jobs.</p>
                                 </li>
                                 <li>
                                    <p>NO_DUP=T: assumes the input new graph data does not have invalid duplicates. In a valid property graph, each vertex (or edge) can at most have one value for a given property key. In an invalid property graph, a vertex (or edge) may have two or more values for a particular key. As an example, a vertex, v, has two key/value pairs: name/"John" and name/"Johnny", and they share the same key.</p>
                                 </li>
                                 <li>
                                    <p>OVERLAP=F: assumes there is no overlap between new graph data and existing graph data. That is, there is no key with multiple distinct values in the new and existing graph data.</p>
                                 </li>
                                 <li>
                                    <p>USE_NEW_VAL_FOR_DUP_KEY=T: if there is overlap between new graph data and existing graph data, use the value in the new graph data; otherwise, use the value in the existing graph data.</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3">External Table-Based Data Merging</p>
                        <p>External table-based data merging uses an external table to load new graph data into Oracle Database and then merge the new graph data into an existing graph.</p>
                        <p>External-table based data merging requires a directory object, where the files read by the external tables will be stored. This directory can be created using the following SQL*Plus statements:</p><pre class="pre codeblock"><code>create or replace directory tmp_dir as '/tmppath/';
grant read, write on directory tmp_dir to public;
</code></pre><p>The following example merges the new graph data from a vertex and edge files szOPVFile and szOPEFile in Oracle flat-file format with an existing graph opg using an external table-based data merging, a DOP (degree of parallelism) of 48, and specified merging options.</p><pre class="pre codeblock"><code>String szOPVFile = "../../data/connectionsNew.opv"; 
String szOPEFile = "../../data/connectionsNew.ope"; 
String szExtDir = "tmp_dir";
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance(); 
opgdl.mergeDataWithExtTab(opg, szOPVFile, szOPEFile, 
     48 /*DOP*/, 
     true /*Use Named Pipe for splitting*/, 
     <span class="bold">szExtDir</span> /*database directory object*/, 
     true /*Rebuild index*/,  
     "pdml=t, pddl=t, no_dup=t, use_new_val_for_dup_key=t" /*Merge options*/);
</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3">SQL Loader-Based Data Merging</p>
                        <p>SQL loader-based data merging uses Oracle SQL*Loader to load the new graph data into Oracle Database and then merge the new graph data into an existing graph.</p>
                        <p>The following example merges the new graph data from a vertex and edge files szOPVFile and szOPEFile in Oracle Flat-file format with an existing graph opg using an SQL loader -based data merging with a DOP (degree of parallelism) of 48 and the specified merging options. To use the APIs, the path to the SQL*Loader needs to be specified.</p><pre class="pre codeblock"><code>String szUser = "username";
String szPassword = "password";
String szDbId = "db12c"; /*service name of the database*/ 
String szOPVFile = "../../data/connectionsNew.opv"; 0
String szOPEFile = "../../data/connectionsNew.ope"; 
String szSQLLoaderPath = "&lt;YOUR_ORACLE_HOME&gt;/bin/sqlldr";    
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance(); 
opgdl.mergeDataWithSqlLdr(opg, szUser, szPassword, szDbId, szOPVFile, szOPEFile, 
     48 /*DOP*/, 
     true /*Use Named Pipe for splitting*/, 
     szSQLLoaderPath /* SQL*Loader path: the path to bin/sqlldr */, 
     true /*Rebuild index*/,  
     "pdml=t, pddl=t, no_dup=t, use_new_val_for_dup_key=t" /*Merge options*/);
</code></pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470" name="GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470"></a><h4 id="SPGDG-GUID-4B2A2CB6-FE53-4C92-A915-4673D355F470" class="sect4"><span class="enumeration_section">2.5.9 </span>Opening and Closing a Property Graph Instance
                  </h4>
                  <div>
                     <p>When describing a property graph, use these Oracle Property Graph classes to open and close the property graph instance properly:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getInstance</code>: Opens an instance of an Oracle property graph. This method has two parameters, the connection information and the graph name. The format of the connection information depends on whether you use HBase or Oracle NoSQL Database as the backend database.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.clearRepository</code>: Removes all vertices and edges from the property graph instance.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.shutdown</code>: Closes the graph instance.
                           </p>
                        </li>
                     </ul>
                     <p>For Oracle Database, the&nbsp;<code class="codeph">OraclePropertyGraph.getInstance</code>&nbsp;method uses an Oracle instance to manage the database connection. <code class="codeph">OraclePropertyGraph</code> has a set of constructors that let you set the graph name, number of hash partitions, degree of parallelism, tablespace, and options for storage (such as compression). For example:
                     </p><pre class="pre codeblock"><code>import oracle.pg.rdbms.*;
Oracle oracle = new Oracle(jdbcURL, username, password);

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(oracle, graphName);
opg.clearRepository(); 
//     .
//     .  Graph description
//     .
// Close the graph instance
opg.shutdown();
</code></pre><p>If the in-memory analyst functions are required for an application, you should use&nbsp;<code class="codeph">GraphConfigBuilder</code>&nbsp;to create a graph&nbsp;for Oracle Database, and instantiate&nbsp;<code class="codeph">OraclePropertyGraph</code>&nbsp;with that graph name&nbsp;as an argument. For example, the following code snippet constructs a graph&nbsp;<code class="codeph">config</code>, gets an&nbsp;<code class="codeph">OraclePropertyGraph</code>&nbsp;instance, loads some data into that graph, and gets an in-memory analyst.
                     </p><pre class="pre codeblock"><code>import oracle.pgx.config.*;
import oracle.pgx.api.*;
import oracle.pgx.common.types.*;

...
 
PgNosqlGraphConfig cfg = GraphConfigBuilder. forPropertyGraphRdbms ()
       .setJdbcUrl("jdbc:oracle:thin:@&lt;hostname&gt;:1521:&lt;sid&gt;")
       .setUsername("&lt;username&gt;").setPassword("&lt;password&gt;")
       .setName(szGraphName)
       .setMaxNumConnections(8)
       .addEdgeProperty("lbl", PropertyType.STRING, "lbl")
       .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000")
       .build();
 
  OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);  
 
  String szOPVFile = "../../data/connections.opv";
  String szOPEFile = "../../data/connections.ope";
 
  // perform a parallel data load
  OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
  opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, "PDML=T,PDDL=T,NO_DUP=T,"); 
 
  ...
  PgxSession session = Pgx.createSession("session-id-1");
  PgxGraph g = session.readGraphWithProperties(cfg);

  Analyst analyst = session.createAnalyst();
  ...
</code></pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344" name="GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344"></a><h4 id="SPGDG-GUID-08F8D5A9-F070-487A-A4E2-221CDDA39344" class="sect4"><span class="enumeration_section">2.5.10 </span>Creating Vertices
                  </h4>
                  <div>
                     <p>To create a vertex, use these Oracle Property Graph methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.addVertex</code>: Adds a vertex instance to a graph.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OracleVertex.setProperty</code>: Assigns a key-value property to a vertex.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.commit</code>: Saves all changes to the property graph instance.
                           </p>
                        </li>
                     </ul>
                     <p>The following code fragment creates two vertices named <code class="codeph">V1</code> and <code class="codeph">V2</code>, with properties for age, name, weight, height, and sex in the <code class="codeph">opg</code> property graph instance. The <code class="codeph">v1</code> properties set the data types explicitly.
                     </p><pre class="oac_no_warn" dir="ltr">// Create vertex v1 and assign it properties as key-value pairs
Vertex v1 = opg.addVertex(1l);
  v1.setProperty("age",  Integer.valueOf(31));
  v1.setProperty("name", "Alice");
  v1.setProperty("weight", Float.valueOf(135.0f));
  v1.setProperty("height", Double.valueOf(64.5d));
  v1.setProperty("female", Boolean.TRUE);
  
Vertex v2 = opg.addVertex(2l);
  v2.setProperty("age",  27);
  v2.setProperty("name", "Bob");
  v2.setProperty("weight", Float.valueOf(156.0f));
  v2.setProperty("height", Double.valueOf(69.5d));
  v2.setProperty("female", Boolean.FALSE); </pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01" name="GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01"></a><h4 id="SPGDG-GUID-82E59D39-5C57-4987-9BC4-22369A9DBF01" class="sect4"><span class="enumeration_section">2.5.11 </span>Creating Edges
                  </h4>
                  <div>
                     <p>To create an edge, use these Oracle Property Graph methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.addEdge</code>: Adds an edge instance to a graph.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OracleEdge.setProperty</code>: Assigns a key-value property to an edge.
                           </p>
                        </li>
                     </ul>
                     <p>The following code fragment creates two vertices (<code class="codeph">v1</code> and <code class="codeph">v2</code>) and one edge (<code class="codeph">e1</code>).
                     </p><pre class="oac_no_warn" dir="ltr">// Add vertices v1 and v2
Vertex v1 = opg.addVertex(1l);
v1.setProperty("name", "Alice");
v1.setProperty("age", 31);

Vertex v2 = opg.addVertex(2l);  
v2.setProperty("name", "Bob");
v2.setProperty("age", 27);

// Add edge e1
Edge e1 = opg.addEdge(1l, v1, v2, "knows");
e1.setProperty("type", "friends");</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417" name="GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417"></a><h4 id="SPGDG-GUID-0FC2511D-0E43-41B7-B2D1-77ECBEF6A417" class="sect4"><span class="enumeration_section">2.5.12 </span>Deleting Vertices and Edges
                  </h4>
                  <div>
                     <p>You can remove vertex and edge instances individually, or all of them simultaneously. Use these methods:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.removeEdge</code>: Removes the specified edge from the graph.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.removeVertex</code>: Removes the specified vertex from the graph.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.clearRepository</code>: Removes all vertices and edges from the property graph instance.
                           </p>
                        </li>
                     </ul>
                     <p>The following code fragment removes edge <code class="codeph">e1</code> and vertex <code class="codeph">v1</code> from the graph instance. The adjacent edges will also be deleted from the graph when removing a vertex. This is because every edge must have an beginning and ending vertex. After removing the beginning or ending vertex, the edge is no longer a valid edge.
                     </p><pre class="oac_no_warn" dir="ltr">// Remove edge e1
opg.removeEdge(e1);

// Remove vertex v1
opg.removeVertex(v1);
</pre><p>The <code class="codeph">OraclePropertyGraph.clearRepository</code> method can be used to remove all contents from an <code class="codeph">OraclePropertyGraph</code> instance. However, use it with care because this action cannot be reversed.
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34" name="GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34"></a><h4 id="SPGDG-GUID-454C00B5-9662-4C19-BF4D-FD8B1C503E34" class="sect4"><span class="enumeration_section">2.5.13 </span>Reading a Graph from a Database into an Embedded In-Memory Analyst
                  </h4>
                  <div>
                     <p>You can read a graph from Oracle Database into an in-memory analyst that is embedded in the same client Java application (a single JVM). For the following example, a correct <code class="codeph">java.io.tmpdir</code> setting is required.
                     </p><pre class="pre codeblock"><code>int dop = 8;                    // need customization
Map&lt;PgxConfig.Field, Object&gt; confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;();
confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false);
confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop);   // 
confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, dop); // &lt;= # of physical cores
confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2);
confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);  // no timeout set
confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);  // no timeout set

PgRdbmsGraphConfig cfg = GraphConfigBuilder.forPropertyGraphRdbms().setJdbcUrl("jdbc:oracle:thin:@&lt;your_db_host&gt;:&lt;db_port&gt;:&lt;db_sid&gt;")
     .setUsername("&lt;username&gt;")
     .setPassword("&lt;password&gt;")
     .setName("&lt;graph_name&gt;")
     .setMaxNumConnections(8)
     .setLoadEdgeLabel(false)
     .build();
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);
ServerInstance localInstance = Pgx.getInstance();
localInstance.startEngine(confPgx);
PgxSession session = localInstance.createSession("session-id-1"); // Put your session description here.

Analyst analyst = session.createAnalyst();

// The following call will trigger a read of graph data from the database
PgxGraph pgxGraph = session.readGraphWithProperties(opg.getConfig());

long triangles = analyst.countTriangles(pgxGraph, false);
System.out.println("triangles " + triangles);

// Remove edge e1
opg.removeEdge(e1);

// Remove vertex v1
opg.removeVertex(v1);
</code></pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C" name="GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C"></a><h4 id="SPGDG-GUID-DCDC3B41-4679-4525-A3E1-44BF8C86187C" class="sect4"><span class="enumeration_section">2.5.14 </span>Specifying Labels for Vertices
                  </h4>
                  <div>
                     <p>The database and data access layer do not provide labels for vertices; however, you can treat the value of a designated vertex property as one or more labels. Such a transformation is relevant only to the in-memory analyst.</p>
                     <p>In the following example, a property "<code class="codeph">country</code>" is specified in a call to <code class="codeph">setUseVertexPropertyValueAsLabel()</code>, and the comma delimiter "<code class="codeph">,</code>" is specified in a call to <code class="codeph">setPropertyValueDelimiter()</code>. These two together imply that values of the <code class="codeph">country</code> vertex property will be treated as vertex labels separated by a comma. For example, if vertex X has a string value <code class="codeph">"US"</code> for its country property, then its vertex label will be <code class="codeph">US</code>; and if vertex Y has a string value <code class="codeph">"UK,CN"</code>, then it will have two labels: <code class="codeph">UK</code> and <code class="codeph">CN</code>.
                     </p><pre class="pre codeblock"><code>GraphConfigBuilder.forPropertyGraph... 
   .setName("&lt;your_graph_name&gt;")
   ...
  .setUseVertexPropertyValueAsLabel("country")
  .setPropertyValueDelimiter(",")
  .build();
</code></pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="using-property-graphs-oracle-database.html#GUID-9BA44355-E97D-4E7A-81AA-269873E506B2">What Are Property Graphs?</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7" name="GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7"></a><h4 id="SPGDG-GUID-A34FD5F5-EE5F-4956-9630-4C5B02DB6CF7" class="sect4"><span class="enumeration_section">2.5.15 </span>Building an In-Memory Graph
                  </h4>
                  <div>
                     <p>In addition to <a href="using-inmemory-analyst-oracle-database.html#GUID-4D385F44-4DE9-4223-BEE5-06E1479FAE06">Reading Graph Data into Memory</a>, you can create an in-memory graph programmatically. This can simplify development when the size of graph is small or when the content of the graph is highly dynamic. The key Java class is <code class="codeph">GraphBuilder</code>, which can accumulate a set of vertices and edges added with the <code class="codeph">addVertex</code> and <code class="codeph">addEdge</code> APIs. After all changes are made, an in-memory graph instance (<code class="codeph">PgxGraph</code>) can be created by the <code class="codeph">GraphBuilder</code>.
                     </p>
                     <p>The following Java code snippet illustrates a graph construction flow. Note that there are no explicit calls to <code class="codeph">addVertex</code>, because any vertex that does not already exist will be added dynamically as its adjacent edges are created.
                     </p><pre class="pre codeblock"><code>import oracle.pgx.api.*;

PgxSession session = Pgx.createSession("example");
GraphBuilder&lt;Integer&gt; builder = session.newGraphBuilder();

builder.addEdge(0, 1, 2);
builder.addEdge(1, 2, 3);
builder.addEdge(2, 2, 4);
builder.addEdge(3, 3, 4);
builder.addEdge(4, 4, 2);

PgxGraph graph = builder.build();
</code></pre><p>To construct a graph with vertex properties, you can use <code class="codeph">setProperty</code> against the vertex objects created.
                     </p><pre class="pre codeblock"><code>PgxSession session = Pgx.createSession("example");
GraphBuilder&lt;Integer&gt; builder = session.newGraphBuilder();

builder.addVertex(1).setProperty("double-prop", 0.1);
builder.addVertex(2).setProperty("double-prop", 2.0);
builder.addVertex(3).setProperty("double-prop", 0.3);
builder.addVertex(4).setProperty("double-prop", 4.56789);

builder.addEdge(0, 1, 2);
builder.addEdge(1, 2, 3);
builder.addEdge(2, 2, 4);
builder.addEdge(3, 3, 4);
builder.addEdge(4, 4, 2);

PgxGraph graph = builder.build();
</code></pre><p>To use long integers as vertex and edge identifiers, specify <code class="codeph">IdType.LONG</code> when getting a new instance of <code class="codeph">GraphBuilder</code>. For example:
                     </p><pre class="pre codeblock"><code>import oracle.pgx.common.types.IdType;
GraphBuilder&lt;Long&gt; builder = session.newGraphBuilder(IdType.LONG);
</code></pre><p>During edge construction, you can directly use vertex objects that were previously created in a call to <code class="codeph">addEdge</code>.
                     </p><pre class="pre codeblock"><code>v1 = builder.addVertex(1l).setProperty("double-prop", 0.5)
v2 = builder.addVertex(2l).setProperty("double-prop", 2.0)

builder.addEdge(0, v1, v2)
</code></pre><p>As with vertices, edges can have properties. The following example sets the edge label by using <code class="codeph">setLabel</code>:
                     </p><pre class="pre codeblock"><code>builder.addEdge(4, v4, v2).setProperty("edge-prop", "edge_prop_4_2").setLabel("label")</code></pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F" name="GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F"></a><h4 id="SPGDG-GUID-E17BCADE-4BC9-41D7-A54E-5612C4C6531F" class="sect4"><span class="enumeration_section">2.5.16 </span>Dropping a Property Graph
                  </h4>
                  <div>
                     <p>To drop a property graph from the database, use the <code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code> method. This method has two parameters, the connection information and the graph name. For example:
                     </p><pre class="pre codeblock"><code>// Drop the graph
Oracle oracle = new Oracle(jdbcUrl, username, password);
OraclePropertyGraphUtils.dropPropertyGraph(oracle, graphName);
</code></pre><p>You can also drop a property graph using the PL/SQL API. For example:</p><pre class="pre codeblock"><code>EXECUTE opg_apis.drop_pg('my_graph_name');</code></pre></div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" name="GUID-72E0D670-D477-4C0F-914C-8E70E45F9692"></a><h3 id="SPGDG-GUID-72E0D670-D477-4C0F-914C-8E70E45F9692" class="sect3"><span class="enumeration_section">2.6 </span>Managing Text Indexing for Property Graph Data
               </h3>
               <div>
                  <p>Indexes in Oracle Spatial and Graph property graph support allow fast retrieval of elements by a particular key/value or key/text pair. These indexes are created based on an element type (vertices or edges), a set of keys (and values), and an index type.</p>
                  <p>Two types of indexing structures are supported.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Automatic text indexes provide automatic indexing of vertices or edges by a set of property keys. Their main purpose is to enhance query performance on vertices and edges based on particular key/value pairs.</p>
                     </li>
                     <li>
                        <p>Manual text indexes enable you to define multiple indexes over a designated set of vertices and edges of a property graph. You must specify what graph elements go into the index.</p>
                     </li>
                  </ul>
                  <p>Oracle Spatial and Graph provides APIs to create manual and automatic text indexes over property graphs stored in Oracle Database. Indexes are managed using the available open-source search engines Apache Lucene and SolrCloud, and Oracle Text, a proprietary search and analysis engine. The rest of this section focuses on how to create text indexes using the property graph capabilities of the Data Access Layer.</p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67">Configuring a Text Index for Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B">Using Automatic Indexes for Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC">Using Manual Indexes for Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F175FF6A-5E87-4499-8086-95069168C88B">Executing Search Queries Over a Property Graph’s Text Indexes</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">Handling Data Types</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3">Uploading a Collection's SolrCloud Configuration to Zookeeper</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E">Updating Configuration Settings on Text Indexes for Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52">Using Parallel Query on Text Indexes for Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26">Using Native Query Objects on Text Indexes for Property Graph Data</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-F0D99092-49A0-434E-9827-C672CC18F64C">Using Native Query Results on Text Indexes for Property Graph Data</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67" name="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67"></a><h4 id="SPGDG-GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67" class="sect4"><span class="enumeration_section">2.6.1 </span>Configuring a Text Index for Property Graph Data
                  </h4>
                  <div>
                     <p>The configuration of a text index is defined using an <code class="codeph">OracleIndexParameters</code> object. This object includes information about the index such as search engine, location, number of directories (or shards), and degree of parallelism. 
                     </p>
                     <p>By default, text indexes are configured based on the&nbsp;<code class="codeph">OracleIndexParameters</code>&nbsp;associated with the property graph using the method&nbsp;<code class="codeph">opg.setDefaultIndexParameters(indexParams)</code>. The initial creation of the automatic index delimits the configuration and text search engine for future indexed keys. 
                     </p>
                     <p>Indexes can also be created by specifying a different set of parameters. The following code fragment creates an automatic text index over an existing property graph using a Lucene engine with a physical directory.</p><pre class="oac_no_warn" dir="ltr">// Create an OracleIndexParameters object to get Index configuration (search engine, etc).
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(args)  
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex("name", Vertex.class, indexParams.getParameters());
</pre><p>If you want to modify the initial configuration of a text index, you may need first to drop the existing graph and recreate the index using the new configuration.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Configuring Text Indexes Using the Apache Lucene Search Engine</p>
                        </li>
                        <li>
                           <p>Configuring Text Indexes Using the SolrCloud Search Engine</p>
                        </li>
                        <li>
                           <p>Configuring Text Indexes Using Oracle Text</p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67__CONFIGURINGTEXTINDEXESUSINGTHEAPACH-4E761B9A">
                        <p class="subhead3">Configuring Text Indexes Using the Apache Lucene Search Engine</p>
                        <p>A text index using Apache Lucene Search engine uses a <code class="codeph">LuceneIndexParameters</code> configuration object. The configuration parameters for indexes using a Lucene Search engine include:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Number of directories:</span> an integer specifying the number of Apache Lucene directories to use for the automatic index. Using multiple directories provides storage and performance scalability. The default value is set to 1.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Batch Size:</span>  an integer specifying the batch size to use for document batching in Apache Lucene. The default batch size used is 10000.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Commit Batch Size:</span> an integer specifying the number of document to add into the Apache Lucene index before a commit operation is executed. The default commit batch size used is 500000.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Data type handling flag:</span> a Boolean specifying if Apache Lucene data types handling is enabled. Enabling data types handling fasten up lookups over numeric and date time data types.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Directory names:</span> a string array specifying the base path location where the Apache Lucene directories will be created. 
                              </p>
                           </li>
                        </ul>
                        <p>The following code fragment creates the configuration for a text index using Apache Lucene Search Engine with a physical directory.</p><pre class="oac_no_warn" dir="ltr">OracleIndexParameters indexParams = 
      OracleIndexParameters.buildFS(4, 4, 10000, 50000, true, 
                                   "/home/data/text-index");
</pre><p>Oracle Spatial and Graph extends the Apache Lucene capabilities by using a DBFS directory to store all Apache Lucene directories and data files.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67__CONFIGURINGTEXTINDEXESUSINGTHESOLRC-4E76215A">
                        <p class="subhead3">Configuring Text Indexes Using the SolrCloud Search Engine</p>
                        <p>A text index using SolrCloud Search engine uses a <code class="codeph">SolrIndexParameters</code> object behind the scenes to identify the SolrCloud host name, the number of shards, and replication factor used during the index construction.  The configuration parameters for indexes using a SolrCloud Search engine include:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Configuration name:</span> the name of the Zookeeper directory where the SolrCloud configuration files for Oracle Property Graph are stored, such as <span class="italic">opgconfig</span>. The configuration files include the required field’s schema (schema.xml) and storage settings (<code class="codeph">solrconfig.xml</code>).
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Server URL:</span> the SolrCloud server URL used to connect to the SolrCloud service, such as<span class="italic">http://localhost:2181/solr</span></p>
                           </li>
                           <li>
                              <p><span class="bold">SolrCloud Node Set:</span> the host names of the nodes in the SolrCloud service where the collection’s shards will be stored, such as <span class="italic">node01:8983_solr,node02:8983_solr,node03:8983_solr</span>. If the value is set to null, then the collection will be created using all the SolrCloud nodes available in the service.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Zookeeper Timeout</span>: a positive integer representing the timeout (in seconds) used to wait for a Zookeeper connection. 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Number of shards:</span> the number of shards to create for the text index collection. If the SolrCloud configuration is using an HDFS directory, the number of shards must not exceed the number of SolrCloud nodes specified in the SolrCloud node set.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Replication factor:</span> the replication factor used in the SolrCloud collection. The default value is set to <span class="italic">1</span>.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Maximum shards per node:</span> the maximum number of shards that can be created on each SolrCloud node. Note that this value must not be smaller than number of shards/# of nodes in the SolrCloud Node set.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">DOP:</span> the degree of parallelism to use when reading the vertices (or edges) from the property graph and indexing the K/V pairs. The default value is set to <span class="italic">1</span>. 
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Batch Size:</span>  an integer specifying the batch size to use for document batching in Apache SolrCloud. The default batch size used is 10000.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Commit Batch Size:</span> an integer specifying the number of document to add into the Apache SolrCloud index before a commit operation is executed. The default commit batch size used is 500000.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Write timeout:</span> the timeout (in seconds) used to wait for an index operation to be completed. If the index operation was unsuccessful due to a communication error, the operation will be tried out again until the timeout is reached or the operation completes.
                              </p>
                           </li>
                        </ul>
                        <p>The following code fragment creates the configuration for a text index using SolrCloud.</p><pre class="oac_no_warn" dir="ltr">String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr"
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                     "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
</pre><p>When using SolrCloud, you must first load a collection's configuration for the text indexes into Apache Zookeeper, as described in <a href="using-property-graphs-oracle-database.html#GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3">Uploading a Collection's SolrCloud Configuration to Zookeeper</a>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-17FBB50B-DF01-4C07-9617-A89F7CACBA67__CONFIGURINGTEXTINDEXESUSINGORACLETE-4E7625EB">
                        <p class="subhead3">Configuring Text Indexes Using Oracle Text</p>
                        <p>Oracle Spatial and Graph supports automatic text indexes using Oracle Text. Oracle Text uses standard SQL to index, search, and analyze text values stored in the V column of the vertices (or edges) table. Because Oracle Text indexes all the existing K/V pairs of the vertices (or edges) in the property graph, this option can be used <span class="bold"><span class="italic">only</span></span> with automatic text indexes and must use a wildcard ("*") indexed key parameter during the index creation.
                        </p>
                        <p>Because the property graph feature uses an NVARCHAR typed column for a better support of Unicode, it is highly recommended that UTF8 (AL32UTF8) be used as the database character set.</p>
                        <p>To create an Oracle Text index on the vertices table (or edges table),&nbsp;the ALTER SESSION privilege is required. The following example grants the privilege.</p><pre class="pre codeblock"><code>SQL&gt; grant alter session to &lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>If customization is required,&nbsp;grant EXECUTE on CTX_DDL, as in the following example.</p><pre class="pre codeblock"><code>SQL&gt; grant execute on ctx_ddl to &lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>A text index using Oracle Text uses an <code class="codeph">OracleTextIndexParameters</code> object.  The configuration parameters for indexes using a Oracle Text include:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span class="bold">Preference owner:</span> the owner of the preference.
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">Data store:</span> the datastore preference specifying how the text values are stored. A datastore preference can be created using ctx_ddl.create_preference API as follows:
                              </p><pre class="pre codeblock"><code>SQL&gt; -- The following requires access privilege to CTX_DDL
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_DATASTORE', 'DIRECT_DATASTORE');
</code></pre><p>If the value is set to NULL, then the index will be created with CTXSYS.DEFAULT_DATASORE. This preference uses a DIRECT_DATASTORE type.</p>
                           </li>
                           <li>
                              <p><span class="bold">Filter:</span> the filter preference determining how text is filtered for indexing. A filter preference can be created using <code class="codeph">ctx_ddl.create_preference</code>, as follows:
                              </p><pre class="pre codeblock"><code>SQL&gt; -- The following requires access privilege to CTX_DDL
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_FILTER', 'AUTO_FILTER');
</code></pre><p>If the value is set to NULL, then the index will be created with CTXSYS.NULL_FILTER. This preference uses a NULL_FILTER type.</p>
                           </li>
                           <li>
                              <p><span class="bold">Storage:</span> the storage preference specifying table space and creation parameters for tables associated with a Text index. A storage preference can be created using <code class="codeph">ctx_ddl.create_preference</code>, as follows:
                              </p><pre class="pre codeblock"><code>SQL&gt; -- The following requires access privilege to CTX_DDL
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_STORAGE', 'BASIC_STORAGE');
</code></pre><p>If the value is set to NULL, then the index will be created with CTXSYS.DEFAULT_STORAGE. This preference uses a BASIC_STORAGE type.</p>
                           </li>
                           <li>
                              <p><span class="bold">Word list:</span> the word list preference specifying the enabled query options. These query options may include stemming, fuzzy matching, substring, and prefix indexing. A data store preference can be created using <code class="codeph">ctx_ddl.create_preference</code>, as follows:
                              </p><pre class="pre codeblock"><code>SQL&gt; -- The following example enables stemming and fuzzy matching for English.
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_WORDLIST', 'BASIC_WORDLIST');
</code></pre><p>If the value is set to NULL, then the index will be created with CTXSYS.DEFAULT_WORDLIST. This preference uses the language stemmer for your database language. </p>
                           </li>
                           <li>
                              <p><span class="bold">Stop list:</span> the stop list preference specifying the list of words that are not meant to be indexed. A stop list preference can be created using <code class="codeph">ctx_ddl.create_stoplist</code> .
                              </p>
                              <p>If the value is set to NULL, then the index will be created with CTXSYS.DEFAULT_STOPLIST. This preference uses the stoplist of your database language.</p>
                           </li>
                           <li>
                              <p><span class="bold">Lexer:</span> the lexer preference specifying the language of the text to be indexed. A lexer preference can be created using <code class="codeph">ctx_ddl.create_preference</code>, as follows:
                              </p><pre class="pre codeblock"><code>SQL&gt; -- The following requires access privilege to CTX_DDL
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_AUTO_LEXER', 'AUTO_LEXER');
</code></pre><p>If the value is set to NULL, then the index will be created with CTXSYS.DEFAULT_LEXER. This preference uses a BASIC_LEXER type with additional options based on the language used at installation time.</p>
                           </li>
                        </ul>
                        <p>The following code fragment creates the configuration for a text index using Oracle Text with default options and OPG_AUTO_LEXER.</p><pre class="oac_no_warn" dir="ltr">String prefOwner = "scott";
String datastore = (String) null;
String filter = (String) null;
String storage = (String) null;
String wordlist = (String) null;
String stoplist = (String) null;
String lexer = "OPG_AUTO_LEXER";
String options = (String) null;

OracleIndexParameters params 
                  = OracleTextIndexParameters.buildOracleText(prefOwner,               
                                                              datastore, 
                                                              filter, 
                                                              storage, 
                                                              wordlist, 
                                                              stoplist, 
                                                              lexer, 
                                                              dop, 
                                                              options);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B" name="GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B"></a><h4 id="SPGDG-GUID-469E1B26-DE30-4AFA-801E-BA14AB30214B" class="sect4"><span class="enumeration_section">2.6.2 </span>Using Automatic Indexes for Property Graph Data
                  </h4>
                  <div>
                     <p>An automatic text index provides automatic indexing of vertices or edges by a set of property keys. Its main purpose is to increase the speed of lookups over vertices and edges based on particular key/value pair. If an automatic index for the given key is enabled, then key/value pair lookups will be performed as a text search against the index instead of as a database lookup.</p>
                     <p>When specifying an automatic index over a property graph, use the following methods to create, remove, and manipulate an automatic index:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.createKeyIndex(String key, Class elementClass, Parameter[] parameters)</code>: Creates an automatic index for all elements of type <code class="codeph">elementClass</code> by the given property key. The index is configured based on the specified parameters.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.createKeyIndex(String[] keys, Class elementClass, Parameter[] parameters)</code>: Creates an automatic index for all elements of type <code class="codeph">elementClass</code> by using a set of property keys. The index is configured based on the specified parameters.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.dropKeyIndex(String key, Class elementClass)</code>: Drops the automatic index for all elements of type <code class="codeph">elementClass</code> for the given property key. 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.dropKeyIndex(String[] keys, Class elementClass)</code>: Drops the automatic index for all elements of type <code class="codeph">elementClass</code> for the given set of property keys.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getAutoIndex(Class elementClass)</code>: Gets an index instance of the automatic index for type <code class="codeph">elementClass</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getIndexedKeys(Class elementClass)</code>: Gets the set of indexed keys currently used in an automatic index for all elements of type <code class="codeph">elementClass</code>.
                           </p>
                        </li>
                     </ul>
                     <p>The supplied example ExampleRDBMS6 creates a property graph from an input file, creates an automatic text index on vertices, and executes some text search queries using Apache Lucene.</p>
                     <p>The following code fragment creates an automatic index over an existing property graph's vertices with these property keys: name, role, religion, and country. The automatic text index will be stored under four subdirectories under the <code class="codeph">/home/data/text-index</code> directory. Apache Lucene data types handling is enabled. This example uses a DOP (parallelism) of 4 for re-indexing tasks.
                     </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(…);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, "PDML=T,PDDL=T,NO_DUP=T,"); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
// number of connections to database, batch size, commit size, 
// enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(4, 4, 10000, 50000, true, 
             "/home/data/text-index ");
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class);
</pre><p>By default, indexes are configured based on the <code class="codeph">OracleIndexParameters</code> associated with the property graph using the method <code class="codeph">opg.setDefaultIndexParameters(indexParams</code>).
                     </p>
                     <p>Indexes can also be created by specifying a different set of parameters. This is shown in the following code snippet.</p><pre class="oac_no_warn" dir="ltr">// Create an OracleIndexParameters object to get Index configuration (search engine, etc).
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(args)  
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex("name", Vertex.class, indexParams.getParameters());
</pre><p>The code fragment in the next example executes a query over all vertices to find all matching vertices with the key/value pair <code class="codeph">name:Barack Obama</code>. This operation will execute a lookup into the text index.
                     </p>
                     <p>Additionally, wildcard searches are supported by specifying the parameter <code class="codeph">useWildCards</code> in the <code class="codeph">getVertices</code> API call. Wildcard search is only supported when automatic indexes are enabled for the specified property key. For details on text search syntax using Apache Lucene, see <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html"><code class="codeph">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</code></a>.
                     </p><pre class="oac_no_warn" dir="ltr">// Find all vertices with name Barack Obama. 
    Iterator&lt;Vertices&gt; vertices = opg.getVertices("name", "Barack Obama").iterator();
    System.out.println("----- Vertices with name Barack Obama -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
 
   // Find all vertices with name including keyword "Obama"
   // Wildcard searching is supported.
    boolean useWildcard = true;
    Iterator&lt;Vertices&gt; vertices = opg.getVertices("name", "*Obama*").iterator();
    System.out.println("----- Vertices with name *Obama* -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
</pre><p>The preceding code example produces output like the following:</p><pre class="oac_no_warn" dir="ltr">----- Vertices with name Barack Obama-----
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 1
 
----- Vertices with name *Obama* -----
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 1</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC" name="GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC"></a><h4 id="SPGDG-GUID-C56AB70D-CB45-4208-84D8-6C5DBF67A8FC" class="sect4"><span class="enumeration_section">2.6.3 </span>Using Manual Indexes for Property Graph Data
                  </h4>
                  <div>
                     <p>Manual indexes support the definition of multiple indexes over the vertices and edges of a property graph. A manual index requires that you manually put, get, and remove elements from the index.</p>
                     <p>When describing a manual index over a property graph, use the following methods to add, remove, and manipulate a manual index:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.createIndex(String name, Class elementClass, Parameter[] parameters)</code>: Creates a manual index with the specified name for all elements of type <code class="codeph">elementClass</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.dropIndex(String name)</code>: Drops the given manual index. 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getIndex(String name, Class elementClass)</code>: Gets an index instance of the given manual index for type <code class="codeph">elementClass</code>.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OraclePropertyGraph.getIndices()</code>: Gets an array of index instances for all manual indexes created in the property graph.
                           </p>
                        </li>
                     </ul>
                     <p>The example code in this topic creates a manual text index on edges, puts some data into the index, and executes some text search queries using Apache SolrCloud.</p>
                     <p>When using SolrCloud, you must first load a collection's configuration for the text indexes into Apache Zookeeper, as described in <a href="using-property-graphs-oracle-database.html#GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3">Uploading a Collection's SolrCloud Configuration to Zookeeper</a>.
                     </p>
                     <p>The following code fragment creates a manual text index over an existing property graph using four shards, one shard per node, and a replication factor of 1. The number of shards corresponds to the number of nodes in the SolrCloud cluster.</p><pre class="oac_no_warn" dir="ltr"> String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, "PDML=T,PDDL=T,NO_DUP=T,"); 
    
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
   // number of connections to database, batch size, commit size, 
         // write timeout (in secs)
             String configName = "opgconfig";
             String solrServerUrl = "nodea:2181/solr"
             String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                                  "nodec:8983_solr,noded:8983_solr";
 
         int zkTimeout = 15;
         int numShards = 4;
         int replicationFactor = 1;
         int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
 
// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
          }
</pre><p>The next code fragment executes a query over the manual index to get all edges with the key/value pair c<code class="codeph">ollaboratesWith:Beyonce</code>. Additionally, wildcards search can be supported by specifying the parameter <code class="codeph">useWildCards</code> in the get API call.
                     </p><pre class="oac_no_warn" dir="ltr">// Find all edges with collaboratesWith Beyonce. 
   // Wildcard searching is supported using true parameter.
    edges = index.get("collaboratesWith", "Beyonce").iterator();
    System.out.println("----- Edges with name Beyonce -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
 
// Find all vertices with name including Bey*. 
   // Wildcard searching is supported using true parameter.
    edges = index.get("collaboratesWith", "*Bey*", true).iterator();
    System.out.println("----- Edges with collaboratesWith Bey* -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: " + countE);
</pre><p>The preceding code example produces output like the following:</p><pre class="oac_no_warn" dir="ltr">----- Edges with name Beyonce -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
 
----- Edges with collaboratesWith Bey* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-F175FF6A-5E87-4499-8086-95069168C88B" name="GUID-F175FF6A-5E87-4499-8086-95069168C88B"></a><h4 id="SPGDG-GUID-F175FF6A-5E87-4499-8086-95069168C88B" class="sect4"><span class="enumeration_section">2.6.4 </span>Executing Search Queries Over a Property Graph’s Text Indexes
                  </h4>
                  <div>
                     <p>Oracle Spatial and Graph provides a set of utilities to execute text search queries over automatic and manual text indexes. These utilities vary from querying based on a particular key/value pair, to executing a text search over a single or multiple keys (with extended query options such as wildcards, fuzzy searches, and range queries).</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Executing Search Queries Over a Text Index Using Apache Lucene</p>
                        </li>
                        <li>
                           <p>Executing Search Queries Over a Text Index Using SolrCloud</p>
                        </li>
                        <li>
                           <p>Executing Search Queries Over a Text Index Using Oracle Text</p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-F175FF6A-5E87-4499-8086-95069168C88B__EXECUTINGSEARCHQUERIESOVERATEXTINDE-4E7901CD">
                        <p class="subhead3">Executing Search Queries Over a Text Index Using Apache Lucene</p>
                        <p>The following code fragment creates an automatic index using Apache Lucene, and executes a query over the text index by specifying a particular key/value pair.</p><pre class="oac_no_warn" dir="ltr">// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
               OraclePropertyGraphDataLoader.getInstance();

opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, 
               "PDML=T,PDDL=T,NO_DUP=T,"); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
// number of connections to database, batch size, commit size, 
// enable datatypes, location)
OracleIndexParameters indexParams = 
            OracleIndexParameters.buildFS(4, 4, 10000, 50000, true, 
                                          "/home/data/text-index ");
opg.setDefaultIndexParameters(indexParams);

// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
while (edges.hasNext()) {
  Edge edge = edges.next();
  Vertex vIn = edge.getVertex(Direction.IN);
  index.put("collaboratesWith", vIn.getProperty("name"), edge);
  index.put("country", vIn.getProperty("country"), edge);
}
 
// Wildcard searching is supported using true parameter.
Iterator&lt;Edge&gt; edges = index.get("country", "United States").iterator();
System.out.println("----- Edges with query: " + queryExpr + " -----");
long countE = 0;
while (edges.hasNext()) {
  System.out.println(edges.next());
  countE++;
}
System.out.println("Edges found: "+ countE);
</pre><p>In this case, the text index will produce a search query out of the key and value objects. If the <code class="codeph">useWildcards</code> flag is not specified or enabled, then results retrieved will include only exact matches.  If the value object is a numeric or date time value, the produced query will be an inclusive range query where the lower and upper limit is defined by the value. Only numeric or date time matches will be retrieved.
                        </p>
                        <p>On the other hand, if the value is a string then all matching key/value pairs will be retrieved no matter their data type. The resulting text query of this type of queries is a Boolean query with a set of optional search terms, one for each supported data type. Further details on data type handling can be found in <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">Handling Data Types</a>.
                        </p>
                        <p>This way, the previous code produces a query expression&nbsp;<span class="italic">country1:"United States" OR country9:"United States" OR … OR countryE:"United States"</span>&nbsp;(if Lucene's data type handling is enabled), or<span class="italic">country:"1United States" OR country:"2United States" OR … OR country:"EUnited States"</span> (if Lucene's data type handling is disabled).
                        </p>
                        <p>Using a String value object with wildcards enabled requires that the value be written using Apache Lucene syntax. For details on text search syntax using Apache Lucene, see https://lucene.apache.org/core/2_9_4/queryparsersyntax.html<a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</a>.
                        </p>
                        <p>You can filter the date type of the matching key/value pairs by specifying the data type class to execute the query against. The following code fragment executes a query over the text index using a single key/value pair with String data type only. The following code produces a query expression&nbsp;<span class="italic">country1:"United States"</span>&nbsp;(if Lucene's data type handling is enabled), or&nbsp;<span class="italic">country:"1United States"</span> (if Lucene's data type handling is disabled).
                        </p><pre class="oac_no_warn" dir="ltr">// Wildcard searching is supported using true parameter.
Iterator&lt;Edge&gt; edges = index.get("country", "United States", true, String.class).iterator();

System.out.println("----- Edges with query: " + queryExpr + " -----");
long countE = 0;
while (edges.hasNext()) {
  System.out.println(edges.next());
  countE++;
}
System.out.println("Edges found: "+ countE);
</pre><p>When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. Oracle Spatial and Graph provides a set of utilities to help users write their own Lucene text search queries using the query syntax and data type identifiers required by the automatic and manual text indexes. </p>
                        <p>The method <code class="codeph">buildSearchTerm(key, value, dtClass)</code>&nbsp;in&nbsp;<code class="codeph">LuceneIndex</code>&nbsp;creates a query expression of the form&nbsp;<span class="italic">field:query_expr</span>&nbsp;by adding the data type identifier to the key (or value) and transforming the value into the required string representation based on the given data type and Apache Lucene's data type handling configuration. 
                        </p>
                        <p>The following code fragment uses the&nbsp;<code class="codeph">buildSearchTerm</code>&nbsp;method to produce a query expression&nbsp;<span class="italic">country1:United*</span>&nbsp;(if Lucene's data type handling is enabled), or&nbsp;<span class="italic">country:1United*</span>&nbsp;(if Lucene's data type handling is disabled) used in the previous examples:
                        </p><pre class="oac_no_warn" dir="ltr">String szQueryStrCountry = index.buildSearchTerm("country", 
                                  "United*", String.class);
</pre><p>To deal with the key and values as individual objects to construct a different Lucene Query like a <code class="codeph">WildcardQuery</code> using the required syntax, the methods&nbsp;<code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code>&nbsp;and&nbsp;<code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code>&nbsp;in <code class="codeph">LuceneIndex</code> will append the appropriate data type identifiers and transform the value into the required Lucene string representation based on the given data type.
                        </p>
                        <p>The following code fragment uses the <code class="codeph">appendDatatypesSuffixToKey</code> method to generate the field name required in a Lucene text query. If Lucene’s data type handling is enabled, the string returned will append the String data type identifier as a suffix of the key (<code class="codeph">country1</code>). In any other case, the retrieved string will be the original key (<code class="codeph">country</code>).
                        </p><pre class="oac_no_warn" dir="ltr">String key = index.appendDatatypesSuffixToKey("country", String.class);</pre><p>The next code fragment uses the&nbsp;<code class="codeph">appendDatatypesSuffixToValue</code>&nbsp;method to generate the query body expression required in a Lucene text query. If Lucene’s data type handling is disabled, the string returned will append the String data type identifier as a prefix of the key (<code class="codeph">1United*</code>). In all other cases, the string returned will be the string representation of the value (<code class="codeph">United*</code>).
                        </p><pre class="oac_no_warn" dir="ltr">String value = index.appendDatatypesSuffixToValue("United*", String.class);</pre><p><code class="codeph">LuceneIndex</code> also supports generating a Term object using the method <code class="codeph">buildSearchTermObject(key, value, dtClass)</code>. Term objects are commonly used among different type of Lucene Query objects to constrain the fields and values of the documents to be retrieved. The following code fragment shows how to create a Wildcard Query object using the <code class="codeph">buildSearchTermObject</code> method.
                        </p><pre class="oac_no_warn" dir="ltr">Term term = index.buildSearchTermObject("country", "United*", String.class);  
Query query = new WildcardQuery(term);
</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-F175FF6A-5E87-4499-8086-95069168C88B__EXECUTINGSEARCHQUERIESOVERATEXTINDE-4E792731">
                        <p class="subhead3">Executing Search Queries Over a Text Index Using SolrCloud</p>
                        <p>The following code fragment creates an automatic index using SolrCloud, and executes a query over the text index by specifying a particular key/value pair.</p><pre class="oac_no_warn" dir="ltr">// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
// number of connections to database, batch size, commit size, 
// write timeout (in secs)
String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr"
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                     "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class); 

// Create manual indexing on above properties for all vertices
OracleIndex&lt;Vertex&gt; index = ((OracleIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);
 
Iterator&lt;Vertex&gt; vertices = index.get("country", "United States").iterator();
System.out.println("----- Vertices with query: " + queryExpr + " -----");
countV = 0;
while (vertices.hasNext()) {
  System.out.println(vertices.next());
  countV++;
}
System.out.println("Vertices found: "+ countV);
</pre><p>In this case, the text index will produce a search query out of the value object. If the <code class="codeph">useWildcards</code> flag is not specified or enabled, then results retrieved will include only exact matches.  If the value object is a numeric or date time value, the produced query will be an inclusive range query where the lower and upper limit is defined by the value. Only numeric or date time matches will be retrieved.
                        </p>
                        <p>On the other hand, if the value is a string then all matching key/value pairs will be retrieved no matter their data type. The resulting text query of this type of queries is a Boolean query with a set of optional search terms, one for each supported data type. Further details on data type handling can be found in <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">Handling Data Types</a>.
                        </p>
                        <p>This way, the previous code produces a query expression&nbsp;<span class="italic">country_str:"United States" OR country_ser:"United States" OR … OR country_json:"United States"</span>.
                        </p>
                        <p>Using a String value object with wildcards enabled requires that the value be written using Apache Lucene Syntax. For details on text search syntax using Apache Lucene, see https://lucene.apache.org/core/2_9_4/queryparsersyntax.html<a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</a>.
                        </p>
                        <p>You can filter the date type of the matching key/value pairs by specifying the data type class to execute the query against. The following code fragment executes a query over the text index using a single key/value pair with String data type only. The code produces a query expression&nbsp;<span class="italic">country_str:"United States".</span></p><pre class="oac_no_warn" dir="ltr">// Wildcard searching is supported using true parameter.
Iterator&lt;Edge&gt; edges = index.get("country", "United States", true, String.class).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre><p>When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. Oracle Spatial and Graph provides a set of utilities to help users write their own Lucene text search queries using the query syntax and data type identifiers required by the automatic and manual text indexes. </p>
                        <p>The method <code class="codeph">buildSearchTerm(key, value, dtClass)</code>&nbsp;in&nbsp;<code class="codeph">SolrIndex </code>&nbsp;creates a query expression of the form&nbsp;<span class="italic">field:query_expr</span>&nbsp;by adding the data type identifier to the key (or value) and transforming the value into the required string representation using the data type formats required by the index.
                        </p>
                        <p>The following code fragment uses the&nbsp;<code class="codeph">buildSearchTerm</code>&nbsp;method to produce a query expression&nbsp;<span class="italic">country_str:United*</span>&nbsp;used in the previous example:
                        </p><pre class="oac_no_warn" dir="ltr">String szQueryStrCountry = index.buildSearchTerm("country", 
                                  "United*", String.class);
</pre><p>To deal with the key and values as individual objects to construct a different SolrCloud query like a <code class="codeph">WildcardQuery</code> using the required syntax, the methods&nbsp;<code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code>&nbsp;and&nbsp;<code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code>&nbsp;in <code class="codeph">SolrIndex</code> will append the appropriate data type identifiers and transform the key and value into the required SolrCloud string representation based on the given data type.
                        </p>
                        <p>The following code fragment uses the <code class="codeph">appendDatatypesSuffixToKey</code> method to generate the field name required in a Lucene text query. If Lucene’s data type handling is enabled, the string returned will append the String data type identifier as a suffix of the key (<code class="codeph">country_str</code>).
                        </p><pre class="oac_no_warn" dir="ltr">String key = index.appendDatatypesSuffixToKey("country", String.class);</pre><p>The next code fragment uses the&nbsp;<code class="codeph">appendDatatypesSuffixToValue</code>&nbsp;method to generate the query body expression required in a Lucene text query. If Lucene’s data type handling is disabled, the string returned will append the String data type identifier as a prefix of the key (<code class="codeph">1United*</code>). In all other cases, the string returned will be the string representation of the value (<code class="codeph">United*</code>).
                        </p><pre class="oac_no_warn" dir="ltr">String key = index.appendDatatypesSuffixToKey("country", String.class);</pre><p>The next code fragment uses the&nbsp;<code class="codeph">appendDatatypesSuffixToValue</code>&nbsp;method to generate the query body expression required in a <code class="codeph">SolrCloud</code> text query. The string returned will be the string representation of the value (<code class="codeph">United*</code>).
                        </p><pre class="oac_no_warn" dir="ltr">String value = index.appendDatatypesSuffixToValue("United*", String.class);</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-F175FF6A-5E87-4499-8086-95069168C88B__EXECUTINGSEARCHQUERIESOVERATEXTINDE-4E792280">
                        <p class="subhead3">Executing Search Queries Over a Text Index Using Oracle Text</p>
                        <p>Text search queries on Oracle Text are translated into SELECT SQL queries with a "<span class="italic">contains</span>"clause including a score range and ordering, and score ID. Oracle’s property graph includes an utility called <code class="codeph">OracleTextQueryObject</code>, which lets you execute text search queries over an Oracle Text index.
                        </p>
                        <p>The following code fragment creates an automatic index using Oracle Text, and executes a query over the text index by specifying a particular key/value pair.</p><pre class="oac_no_warn" dir="ltr">String prefOwner = "scott";
String datastore = (String) null;
String filter = (String) null;
String storage = (String) null;
String wordlist = (String) null;
String stoplist = (String) null;
String lexer = "OPG_AUTO_LEXER";
String options = (String) null;

OracleIndexParameters params 
                  = OracleTextIndexParameters.buildOracleText(prefOwner,               
                                                              datastore, 
                                                              filter, 
                                                              storage, 
                                                              wordlist, 
                                                              stoplist, 
                                                              lexer, 
                                                              dop, 
                                                              options);

opg.setDefaultIndexParameters(indexParams);
    

// Create auto indexing on all existing properties, use wildcard for all
opg.createKeyIndex(("*", Vertex.class); 

// Get the auto index object
OracleIndex&lt;Vertex&gt; index = ((OracleIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Create the text query object for Oracle Text
OracleTextQueryObject otqo 
               = OracleTextQueryObject.getInstance("Obama" /* query body */, 
                                                   1 /* score */, 
                                                   ScoreRange.POSITIVE /* Score range */,   
                                                   Direction.ASC /* order by direction*/);
 
Iterator&lt;Vertex&gt; vertices = index.get("name", otqo).iterator();
System.out.println("----- Vertices with query: " + otqo.toString() + " -----");
countV = 0;
while (vertices.hasNext()) {
  System.out.println(vertices.next());
  countV++;
}
System.out.println("Vertices found: "+ countV);
</pre><p>You can filter the date type of the matching key/value pairs by specifying the data type class to execute the query against. The following code fragment executes a query over the text index to retrieve all properties with a String value including the word <span class="italic">Obama</span>.
                        </p><pre class="oac_no_warn" dir="ltr">// Create the text query object for Oracle Text
OracleTextQueryObject otqo 
               = OracleTextQueryObject.getInstance("Obama" /* query body */, 
                                                   1 /* score */, 
                                                   ScoreRange.POSITIVE 
                                                   /* Score range */,   
                                                   Direction.ASC 
                                                   /* order by direction*/,
                                                   "name",
                                                   String.class);
 
Iterator&lt;Vertex&gt; vertices = index.get("name", otqo).iterator();
System.out.println("----- Vertices with query: " + otqo.toString() + " -----");
countV = 0;
while (vertices.hasNext()) {
  System.out.println(vertices.next());
  countV++;
}
System.out.println("Vertices found: "+ countV);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6" name="GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6"></a><h4 id="SPGDG-GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6" class="sect4"><span class="enumeration_section">2.6.5 </span>Handling Data Types
                  </h4>
                  <div>
                     <p>Oracle's property graph support indexes and stores an element's Key/Value pairs based on the value data type. The main purpose of handling data types is to provide extensive query support like numeric and date range queries.</p>
                     <p>By default, searches over a specific key/value pair are matched up to a query expression based on the value's data type. For example, to find vertices with the key/value pair <code class="codeph">age:30</code>, a query is executed over all age fields with a data type integer. If the value is a query expression, you can also specify the data type class of the value to find by calling the API <code class="codeph">get(String key, Object value, Class dtClass, Boolean useWildcards)</code>. If no data type is specified, the query expression will be matched to all possible data types.
                     </p>
                     <p> When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. The following topics describe how to append this prefix/suffix for Apache Lucene and SolrCloud.</p>
                  </div>
                  <div>
                     <p><strong>Topics:</strong></p>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD">Appending Data Type Identifiers on Apache Lucene</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-996CAF8D-F77E-4624-8684-695434B555A3">Appending Data Type Identifiers on SolrCloud</a><br></li>
                        <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B">Handling Data Types on Oracle Text</a><br></li>
                     </ul>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD" name="GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD"></a><h5 id="SPGDG-GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD" class="sect5"><span class="enumeration_section">2.6.5.1 </span>Appending Data Type Identifiers on Apache Lucene
                     </h5>
                     <div>
                        <p>When Lucene's data types handling is enabled, you must append the proper data type identifier as a suffix to the key in the query expression. This can be done by executing a <code class="codeph">String.concat()</code> operation to the key. If Lucene's data types handling is disabled, you must insert the data type identifier as a prefix in the value String. The following table shows the data type identifiers available for text indexing using Apache Lucene (see also the Javadoc for <code class="codeph">LuceneIndex</code>).
                        </p>
                        <div class="tblformal" id="GUID-3B1143F6-AEE0-46A9-8BE4-FA7860A844CD__APACHELUCENEDATATYPEIDENTIFIERS-11261E8F">
                           <p class="titleintable">Table 2-1 Apache Lucene Data Type Identifiers</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Apache Lucene Data Type Identifiers" summary="Apache Lucene Data Type Identifiers. Column 1 is Lucene Data Type Identifier, and column 2 is Description." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="51%" id="d2789e4612">Lucene Data Type Identifier</th>
                                    <th align="left" valign="bottom" width="49%" id="d2789e4615">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4620" headers="d2789e4612 ">
                                       <p>TYPE_DT_STRING</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4620 d2789e4615 ">
                                       <p>String</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4627" headers="d2789e4612 ">
                                       <p>TYPE_DT_BOOL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4627 d2789e4615 ">
                                       <p>Boolean</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4634" headers="d2789e4612 ">
                                       <p>TYPE_DT_DATE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4634 d2789e4615 ">
                                       <p>Date</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4641" headers="d2789e4612 ">
                                       <p>TYPE_DT_FLOAT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4641 d2789e4615 ">
                                       <p>Float</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4648" headers="d2789e4612 ">
                                       <p>TYPE_DT_DOUBLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4648 d2789e4615 ">
                                       <p>Double</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4655" headers="d2789e4612 ">
                                       <p>TYPE_DT_LONG</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4655 d2789e4615 ">
                                       <p>Long</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4662" headers="d2789e4612 ">
                                       <p>TYPE_DT_CHAR</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4662 d2789e4615 ">
                                       <p>Character</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4669" headers="d2789e4612 ">
                                       <p>TYPE_DT_SHORT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4669 d2789e4615 ">
                                       <p>Short</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4676" headers="d2789e4612 ">
                                       <p>TYPE_DT_BYTE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4676 d2789e4615 ">
                                       <p>Byte</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4683" headers="d2789e4612 ">
                                       <p>TYPE_DT_SPATIAL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4683 d2789e4615 ">
                                       <p>Spatial</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4690" headers="d2789e4612 ">
                                       <p>TYPE_DT_INTEGER</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4690 d2789e4615 ">
                                       <p>Integer</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4698" headers="d2789e4612 ">
                                       <p>TYPE_DT_SERIALIZABLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4698 d2789e4615 ">
                                       <p>Serializable</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The following code fragment creates a manual index on edges using Lucene's data type handling, adds data, and later executes a query over the manual index to get all edges with the key/value pair <code class="codeph">collaboratesWith:Beyonce AND country1:United*</code> using wildcards.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(…);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, "PDML=T,PDDL=T,NO_DUP=T,"); 
    
// Specify Index Directory parameters (number of directories, 
   // number of connections to database, batch size, commit size, 
         // enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(4, 4, 10000, 50000, true, 
            "/home/data/text-index ");
opg.setDefaultIndexParameters(indexParams);
// Create manual indexing on above properties for all edges
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
             index.put("country", vIn.getProperty("country"), edge);
          }
 
// Wildcard searching is supported using true parameter.
    String key = "country";
    key = key.concat(String.valueOf(oracle.pg.text.lucene.LuceneIndex.TYPE_DT_STRING));
   
    String queryExpr = "Beyonce AND " + key + ":United*";
    edges = index.get("collaboratesWith", queryExpr, true /*UseWildcard*/).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre><p>The preceding code example might produce output like the following:</p><pre class="oac_no_warn" dir="ltr">----- Edges with name Beyonce AND country1:United* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre><p>The following code fragment creates an automatic index on vertices, disables Lucene's data type handling, adds data, and later executes a query over the manual index from a previous example to get all vertices with the key/value pair <code class="codeph">country:United* AND role:1*political*</code> using wildcards.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(…);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, "PDML=T,PDDL=T,NO_DUP=T,"); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
   // number of connections to database, batch size, commit size, 
         // enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(4, 4, 10000, 50000, false, "/ home/data/text-index ");
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class);
 
// Wildcard searching is supported using true parameter.
    String value = "*political*";
    value = String.valueOf(LuceneIndex.TYPE_DT_STRING) + value;
String queryExpr = "United* AND role:" + value;
    
 
vertices = opg.getVertices("country", queryExpr,  true /*useWildcard*/).iterator();
    System.out.println("----- Vertices with query: " + queryExpr + " -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
</pre><p>The preceding code example might produce output like the following:</p><pre class="oac_no_warn" dir="ltr">----- Vertices with query: United* and role:1*political* -----
Vertex ID 30 {name:str:Jerry Brown, role:str:political authority, occupation:str:34th and 39th governor of California, country:str:United States, political party:str:Democratic, religion:str:roman catholicism}
Vertex ID 24 {name:str:Edward Snowden, role:str:political authority, occupation:str:system administrator, country:str:United States, religion:str:buddhism}
Vertex ID 22 {name:str:John Kerry, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:68th United States Secretary of State, religion:str:Catholicism}
Vertex ID 21 {name:str:Hillary Clinton, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:67th United States Secretary of State, religion:str:Methodism}
Vertex ID 19 {name:str:Kirsten Gillibrand, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:junior United States Senator from New York, religion:str:Methodism}
Vertex ID 13 {name:str:Ertharin Cousin, role:str:political authority, country:str:United States, political party:str:Democratic}
Vertex ID 11 {name:str:Eric Holder, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:United States Deputy Attorney General}
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 8</pre></div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-996CAF8D-F77E-4624-8684-695434B555A3" name="GUID-996CAF8D-F77E-4624-8684-695434B555A3"></a><h5 id="SPGDG-GUID-996CAF8D-F77E-4624-8684-695434B555A3" class="sect5"><span class="enumeration_section">2.6.5.2 </span>Appending Data Type Identifiers on SolrCloud
                     </h5>
                     <div>
                        <p>For Boolean operations on SolrCloud text indexes, you must append the proper data type identifier as suffix to the key in the query expression. This can be done by executing a <code class="codeph">String.concat()</code> operation to the key. The following trable shows the data type identifiers available for text indexing using SolrCloud (see the Javadoc for <code class="codeph">SolrIndex</code>).
                        </p>
                        <div class="tblformal" id="GUID-996CAF8D-F77E-4624-8684-695434B555A3__SOLRCLOUDDATATYPEIDENTIFIERS-11263D32">
                           <p class="titleintable">Table 2-2 SolrCloud Data Type Identifiers</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="SolrCloud Data Type Identifiers" summary="SolrCloud Data Type Identifiers. Column 1 is SolrCloud Data Type IDentifier, and column 2 is Description." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="51%" id="d2789e4789">Solr Data Type Identifier</th>
                                    <th align="left" valign="bottom" width="49%" id="d2789e4792">Description</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4797" headers="d2789e4789 ">
                                       <p>TYPE_DT_STRING</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4797 d2789e4792 ">
                                       <p>String</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4804" headers="d2789e4789 ">
                                       <p>TYPE_DT_BOOL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4804 d2789e4792 ">
                                       <p>Boolean</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4811" headers="d2789e4789 ">
                                       <p>TYPE_DT_DATE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4811 d2789e4792 ">
                                       <p>Date</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4818" headers="d2789e4789 ">
                                       <p>TYPE_DT_FLOAT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4818 d2789e4792 ">
                                       <p>Float</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4825" headers="d2789e4789 ">
                                       <p>TYPE_DT_DOUBLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4825 d2789e4792 ">
                                       <p>Double</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4832" headers="d2789e4789 ">
                                       <p>TYPE_DT_INTEGER</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4832 d2789e4792 ">
                                       <p>Integer</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4839" headers="d2789e4789 ">
                                       <p>TYPE_DT_LONG</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4839 d2789e4792 ">
                                       <p>Long</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4846" headers="d2789e4789 ">
                                       <p>TYPE_DT_CHAR</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4846 d2789e4792 ">
                                       <p>Character</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4853" headers="d2789e4789 ">
                                       <p>TYPE_DT_SHORT</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4853 d2789e4792 ">
                                       <p>Short</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4860" headers="d2789e4789 ">
                                       <p>TYPE_DT_BYTE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4860 d2789e4792 ">
                                       <p>Byte</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4867" headers="d2789e4789 ">
                                       <p>TYPE_DT_SPATIAL</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4867 d2789e4792 ">
                                       <p>Spatial</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="51%" id="d2789e4875" headers="d2789e4789 ">
                                       <p>TYPE_DT_SERIALIZABLE</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d2789e4875 d2789e4792 ">
                                       <p>Serializable</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The following code fragment creates a manual index on edges using SolrCloud, adds data, and later executes a query over the manual index to get all edges with the key/value pair <code class="codeph">collaboratesWith:Beyonce AND country1:United*</code> using wildcards.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,       
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, 2 /* dop */, 1000, true, "PDML=T,PDDL=T,NO_DUP=T,"); 
    
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
   // number of connections to database, batch size, commit size, 
         // write timeout (in secs)
             String configName = "opgconfig";
             String solrServerUrl = "nodea:2181/solr"
             String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                                  "nodec:8983_solr,noded:8983_solr";
 
         int zkTimeout = 15;
         int numShards = 4;
         int replicationFactor = 1;
         int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
             index.put("country", vIn.getProperty("country"), edge);
          }
 
// Wildcard searching is supported using true parameter.
    String key = "country";
    key = key.concat(oracle.pg.text.solr.SolrIndex.TYPE_DT_STRING);
   
    String queryExpr = "Beyonce AND " + key + ":United*";
    edges = index.get("collaboratesWith", queryExpr, true /** UseWildcard*/).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre><p>The preceding code example might produce output like the following:</p><pre class="oac_no_warn" dir="ltr">----- Edges with name Beyonce AND country_str:United* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1</pre></div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B" name="GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B"></a><h5 id="SPGDG-GUID-BC847F16-AA8A-4CD0-BEF3-F50344F5EA9B" class="sect5"><span class="enumeration_section">2.6.5.3 </span>Handling Data Types on Oracle Text
                     </h5>
                     <div>
                        <p>Text indexes using Oracle Text are created over the K and V text columns of the property graph tables. In order to provide text indexing capabilities on all available data types, Oracle populates the V column with a string representation of numeric, spatial, and date time key/value pairs.</p>
                        <p>To specify the date time and numeric formats used when populating the V column, you can use the methods <code class="codeph">setNumberToCharSqlFormatString</code> and <code class="codeph">setTimeToCharSqlFormatString</code>. The following code snippet shows how to set the date time and numeric formats in a property graph instance.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,       
                                                          szGraphName);
opg.setNumberToCharSqlFormatString("TM9");
opg.setTimeToCharSqlFormatString("SYYYY-MM-DD\"T\"HH24:MI:SS.FF9TZH:TZM");
</pre><p>When executing a text search query over a numeric or date time value, you should use a text expression using the format associated to the property graph. <code class="codeph">OraclePropertyGraph</code> includes a utility API <code class="codeph">opg.parseValueToCharSQLFormatString</code> that lets you parse a numeric or date time object into format used in the V column storage. The following code snippet calls this function with a date value and creates a text query object out of the retrieved text.
                        </p><pre class="oac_no_warn" dir="ltr">Date d = new java.util.Date(100l);
String szDate = opg.parseValueToCharSQLFormatString(d);

// Create the text query object for Oracle Text
OracleTextQueryObject otqo 
               = OracleTextQueryObject.getInstance(szDate /* query body */, 
                                                   1 /* score */, 
                                                   ScoreRange.POSITIVE /* Score range */,   
                                                   Direction.ASC /* order by direction);
</pre></div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3" name="GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3"></a><h4 id="SPGDG-GUID-A5797EAF-4165-4ACE-B1BD-0284DA391DB3" class="sect4"><span class="enumeration_section">2.6.6 </span>Uploading a Collection's SolrCloud Configuration to Zookeeper
                  </h4>
                  <div>
                     <p>Before using SolrCloud text indexes on Oracle Spatial and Graph property graphs, you must upload a collection's configuration to Zookeeper. This can be done using the ZkCli tool from one of the SolrCloud cluster nodes.</p>
                     <p>A predefined collection configuration directory can be found in <code class="codeph">dal/opg-solr-config</code> under the installation home. The following shows an example of how to upload the <code class="codeph">PropertyGraph</code> configuration directory.
                     </p>
                     <ol>
                        <li>
                           <p>Copy <code class="codeph">$ORACLE_HOME/md/property_graph/dal/opg-solr-config.zip</code> into the <code class="codeph">/tmp</code> directory on one of the Solr cluster nodes. For example:
                           </p><pre class="oac_no_warn" dir="ltr">scp &#x2013;r $ORACLE_HOME/md/property_graph/dal/opg-solr-config.zip user@solr-node:/tmp
</pre></li>
                        <li>
                           <p>Execute following commands such as the following, using the ZkCli tool on the same node:</p><pre class="oac_no_warn" dir="ltr">cd /tmp
unzip opg-solr-config.zip
$SOLR_HOME/bin/zkcli.sh -zkhost 127.0.0.1:2181/solr -cmd upconfig &#x2013;confname opgconfig -confdir /tmp/opg-solr-config
</pre></li>
                     </ol>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E" name="GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E"></a><h4 id="SPGDG-GUID-F198F6FA-875D-42E4-A43C-7A9B01FFEA1E" class="sect4"><span class="enumeration_section">2.6.7 </span>Updating Configuration Settings on Text Indexes for Property Graph Data
                  </h4>
                  <div>
                     <p>Oracle's property graph support manages manual and automatic text indexes through integration with Apache Lucene, SolrCloud, and Oracle Text. At creation time, you must create an <code class="codeph">OracleIndexParameters</code> object specifying the search engine and other configuration settings to be used by the text index. After a text index for property graph is created, these configuration settings cannot be changed. For automatic indexes, all vertex index keys are managed by a single text index, and all edge index keys are managed by a different text index using the configuration specified when the first vertex or edge key is indexed.
                     </p>
                     <p>If you need to change the configuration settings, you must first disable the current index and create it again using a new <code class="codeph">OracleIndexParameters</code> object. The following code fragment creates two automatic Apache Lucene-based indexes (on vertices and edges) over an existing property graph, disables them, and re-creates them to use SolrCloud.
                     </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
      …);
 
// Create an automatic index using Apache Lucene.
// Specify Index Directory parameters (number of directories,
// number of connections to database, batch size, commit size,
// enable datatypes, location)
OracleIndexParameters luceneIndexParams =
     OracleIndexParameters.buildFS(4, 4, 10000, 50000, true,
             "/home/oracle/text-index ");
 
// Specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class, luceneIndexParams.getParameters());
 
// Create auto indexing on weight for all edges
opg.createKeyIndex("weight", Edge.class, luceneIndexParams.getParameters());
 
// Disable auto indexes to change parameters
opg.getOracleIndexManager().disableVertexAutoIndexer();
opg.getOracleIndexManager().disableEdgeAutoIndexer();
 
 
// Recreate text indexes using SolrCloud
// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set,
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,
// number of connections to database, batch size, commit size,
// write timeout (in secs)
String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr";
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +
   "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters solrIndexParams =
OracleIndexParameters.buildSolr(configName,
                                solrServerUrl,
                                solrNodeSet,
                                zkTimeout,
                                numShards,
                                replicationFactor,
                                maxShardsPerNode,
                                4,
                                10000,
                                500000,
                                15);
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class, solrIndexParams.getParameters());
 
// Create auto indexing on weight for all edges
opg.createKeyIndex("weight", Edge.class, solrIndexParams.getParameters());
</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52" name="GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52"></a><h4 id="SPGDG-GUID-7C5C1BDB-13EA-4504-9B4F-B8F7D788AE52" class="sect4"><span class="enumeration_section">2.6.8 </span>Using Parallel Query on Text Indexes for Property Graph Data
                  </h4>
                  <div>
                     <p>Text indexes in Oracle Spatial and Graph allow executing text queries over millions of vertices and edges by a particular key/value or key/text pair using parallel query execution.</p>
                     <p>Parallel text querying is an optimized solution taking advantage of the distribution of the data in the index among shards in SolrCloud (or subdirectories in Apache Lucene), so each one is queried using separate index connection. This involves multiple threads and connections to SolrCloud (or Apache Lucene) search engines to increase performance on read operations and retrieve multiple elements from the index. Note that this approach will not rank the matching results based on their score.</p>
                     <p>Parallel text query will produce an array where each element holds all the vertices (or edges) with an attribute matching the given K/V pair from a shard. The subset of shards queried will be delimited by the given start sub-directory ID and the size of the connections array provided. This way, the subset will consider shards in the range of [start, start - 1 + size of connections array]. Note that an integer ID (in the range of [0, N - 1]) is assigned to all the shards in index with N shards.</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Parallel Text Query Using Apache Lucene</p>
                        </li>
                        <li>
                           <p>Parallel Text Search Using SoltCloud</p>
                        </li>
                        <li>
                           <p>Parallel Text Search Using Oracle Text</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3"><span class="bold">Parallel Text Query Using Apache Lucene</span></p>
                        <p>You can use parallel text query using Apache Lucene by calling the method <code class="codeph">getPartitioned</code> in <code class="codeph">LuceneIndex</code>, specifying an array of connections to set of subdirectories (<code class="codeph">SearcherManager</code> objects), the key/value pair to search, and the starting subdirectory ID. Each connection needs to be linked to the appropriate subdirectory, as each subdirectory is independent of the rest of the subdirectories in the index.
                        </p>
                        <p>The following code fragment generates an automatic text index using the Apache Lucene Search engine, and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">LuceneIndex</code> class is controlled by the total number of subdirectories and the number of connections used.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 …);

// Create an automatic index
OracleIndexParameters indexParams 
= OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name for vertices");
opg.createKeyIndex("name", Vertex.class);

// Get the LuceneIndex object 
SearcherManager[] conns = new SearcherManager[dop];
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets a connection object from subdirectory split to 
//(split + conns.length)
for (int idx = 0; idx &lt; conns.length; idx++) { 
<span class="bold">conns[idx] = index.getOracleSearcherManager(idx + split);</span> 
}

// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr 
= <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 "*" /* value */, 
 true /* wildcards */, 
 split /* start split ID */);
</span>
lCount = countFromIterables(iterAr); /* Consume iterables in parallel */

// Do not close the connections to the subdirectories after completion,
// because those connections are used by the LuceneIndex object itself.
}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3">Parallel Text Search Using SolrCloud</p>
                        <p>You can use parallel text query using SolrCloud by calling the method <code class="codeph">getPartitioned</code> in <code class="codeph">SolrIndex</code>, specifying an array of connections to SolrCloud (<code class="codeph">CloudSolrServer</code> objects), the key/value pair to search, and the starting shard ID. 
                        </p>
                        <p>The following code fragment generates an automatic text index using the SolrCloud Search engine and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">SolrIndex</code> class is controlled by the total number of shards in the index and the number of connections used.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(…);

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout /* zookeeper timeout in seconds */,
 numShards /* total number of shards */,
 replicationFactor /* Replication factor */,
 maxShardsPerNode /* maximum number of shardsper node*/,
 4 /* dop used for scan */,
 10000 /* batch size before commit*/,
 500000 /* commit size before SolrCloud commit*/,
 15 /* write timeout in seconds */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name for vertices");
opg.createKeyIndex("name", Vertex.class);

// Get the SolrIndex object 
SearcherManager[] conns = new SearcherManager[dop];
<span class="bold">SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);</span>

// Open an array of connections to handle connections to SolrCloud needed for parallel text search
CloudSolrServer[] conns = new CloudSolrServer[dop];

<span class="bold">for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = index.getCloudSolrServer(15 /* write timeout in 
secs*/);
}
</span>
// Iterate to cover all the shards in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 "*" /* value */, 
 true /* wildcards */, 
 split /* start split ID */);
</span>
lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Close the connections to the sub-directories after completed
for (int idx = 0; idx &lt; conns.length; idx++) { 
conns[idx].shutdown();
} 

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3">Parallel Text Search Using Oracle Text</p>
                        <p>You can use parallel text query using Oracle Text by calling the method&nbsp;<code class="codeph">getPartitioned</code>&nbsp;in&nbsp;<code class="codeph">OracleTextAutoIndex</code>, specifying an array of connections to Oracle Text (Connection&nbsp;objects), the key/value pair to search, and the starting partition ID.
                        </p>
                        <p>The following code fragment generates an automatic text index using Oracle Text and executes a parallel text query. The number of calls to the&nbsp;<code class="codeph">getPartitioned</code>&nbsp;method in the&nbsp;<code class="codeph">OracleTextAutoIndex</code>&nbsp;class is controlled by the total number of partitions in the VT$ (or GE$ tables) and the number of connections used.
                        </p><pre class="oac_no_warn" dir="ltr">OraclePropertyGraph opg = OraclePropertyGraph.getInstance(…);
String prefOwner = "scott";
String datastore = (String) null;
String filter = (String) null;
String storage = (String) null;
String wordlist = (String) null;
String stoplist = (String) null;
String lexer = "OPG_AUTO_LEXER";
String options = (String) null;

OracleIndexParameters params 
                  = OracleTextIndexParameters.buildOracleText(prefOwner,               
                                                              datastore, 
                                                              filter, 
                                                              storage, 
                                                              wordlist, 
                                                              stoplist, 
                                                              lexer, 
                                                              dop, 
                                                              options);

opg.setDefaultIndexParameters(indexParams);
    

// Create auto indexing on all existing properties, use wildcard for all
opg.createKeyIndex(("*", Vertex.class); 


// Create the text query object for Oracle Text
OracleTextQueryObject otqo 
               = OracleTextQueryObject.getInstance("Obama" /* query body */, 
                                                   1 /* score */, 
                                                   ScoreRange.POSITIVE /* Score range */,   
                                                   Direction.ASC /* order by direction*/);

// Get the Connection object 
<span class="bold">Connection[] conns = new Connection[dop];
for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = opg.getOracle().clone().getConnection();</span>
}

// Get the auto index object
OracleIndex&lt;Vertex&gt; index = ((OracleIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Iterate to cover all the partitions in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
  // Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 otqo, 
 true /* wildcards */, 
 split /* start split ID */);</span>

lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Close the connections
<span class="bold">for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx].dispose();
</span>}

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26" name="GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26"></a><h4 id="SPGDG-GUID-C957BD65-7FA5-4EC2-8485-4BB0D297AE26" class="sect4"><span class="enumeration_section">2.6.9 </span>Using Native Query Objects on Text Indexes for Property Graph Data
                  </h4>
                  <div>
                     <p>Using Query objects directly is for advanced users, enabling them to take full advantage of the underlying query capabilities of the text search engine (Apache Lucene or SolrCloud). For example, you can add constraints to text searches, such as adding a boost to the matching scores and adding sorting clauses. </p>
                     <p>Using text searches with Query objects will produce an Iterable object holding all the vertices (or edges) with an attribute (or set of attributes) matching the text  query while satisfying  the constraints. This approach will automatically rank the results based on their matching score.</p>
                     <p>To build the clauses in the query body, you may need to consider the data type used by the key/value pair to be matched, as well as the configuration of the search engine used. For more information about building a search term, see <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">Handling Data Types</a>.
                     </p>
                     <div class="section">
                        <p class="subhead3"><span class="bold">Using Native Query Objects with Apache Lucene</span></p>
                        <p>You can use native query objects using Apache Lucene by calling the method <code class="codeph">get(Query)</code> in <code class="codeph">LuceneIndex</code>. You can also use parallel text query with native query objects by calling the method <code class="codeph">getPartitioned(SearcherManager[], Query, int)</code> in <code class="codeph">LuceneIndex</code> specifying an array of connections to a set of subdirectories (<code class="codeph">SearcherManager</code> objects), the Lucene query object, and the starting subdirectory ID. Each connection must be linked to the appropriate subdirectory, because each subdirectory is independent of the rest of the subdirectories in the index.
                        </p>
                        <p>The following code fragment generates an automatic text index using Apache Lucene Search engine, creates a Lucene Query, and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">LuceneIndex</code> class is controlled by the total number of subdirectories and the number of connections used.
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.lucene.LuceneIndex;
import org.apache.lucene.search.*;
import org.apache.lucene.index.*;

...

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 …);

// Create an automatic index
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name and country properties for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the LuceneIndex object 
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
Term term = index.buildSearchTermObject("name", "Beyo*", String.class);
Query queryBey = new WildcardQuery(term);

// Add another condition to query all the vertices whose country is 
//"United States"
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

Query queryCountry = new PhraseQuery();
StringTokenizer st = new StringTokenizer(value);
while (st.hasMoreTokens()) {
  queryCountry.add(new Term(key, st.nextToken()));
};

//Concatenate queries
BooleanQuery bQuery = new BooleanQuery();
bQuery.add(queryBey, BooleanClause.Occur.MUST);
bQuery.add(queryCountry, BooleanClause.Occur.MUST);

long lCount = 0;
SearcherManager[] conns = new SearcherManager[dop];
for (int split = 0; split &lt; index.getTotalShards(); split += conns.length) {
  // Gets a connection object from subdirectory split to 
  //(split + conns.length). Skip the cache so we clone the connection and
  // avoid using the connection used by the index.
  for (int idx = 0; idx &lt; conns.length; idx++) { 
    conns[idx] = index.getOracleSearcherManager(idx + split, 
                                      true /* skip looking in the cache*/                 
); 
  }

  // Gets elements from split to split + conns.length
  Iterable&lt;Vertex&gt;[] iterAr = index.getPartitioned(conns /* connections */, 
                                                   bQuery,  
                                                   split /* start split ID */);

  lCount = countFromIterables(iterAr); /* Consume iterables in parallel */

  // Do not close the connections to the sub-directories after completed,
  // as those connections are used by the index itself

}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3">Using Native Query Objects withSolrCloud</p>
                        <p>You can directly use native query objects against SolrCloud by calling the method <code class="codeph">get(SolrQuery)</code> in <code class="codeph">SolrIndex</code>. You can also use parallel text query with native query objects by calling the method <code class="codeph">getPartitioned(CloudSolrServer[],SolrQuery,int)</code> in <code class="codeph">SolrIndex</code> specifying an array of connections to SolrCloud (<code class="codeph">CloudSolrServer</code> objects), the <code class="codeph">SolrQuery</code> object, and the starting shard ID.
                        </p>
                        <p>The following code fragment generates an automatic text index using the Apache SolrCloud Search engine, creates a <code class="codeph">SolrQuery</code> object, and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">SolrIndex</code> class is controlled by the total number of subdirectories and the number of connections used.
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.solr.*;
import org.apache.solr.client.solrj.*;

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 …);

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout          /* zookeeper timeout in seconds */,
 numShards          /* total number of shards */,
 replicationFactor  /* Replication factor */,
 maxShardsPerNode   /* maximum number of shardsper node*/,
 4                  /* dop used for scan */,
 10000              /* batch size before commit*/,
 500000             /* commit size before SolrCloud commit*/,
 15                 /* write timeout in seconds */
);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the SolrIndex object 
SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
String szQueryStrBey = index.buildSearchTerm("name", "Beyo*", String.class);
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

String szQueryStrCountry = key + ":" + value;
Solrquery query = new SolrQuery(szQueryStrBey + " AND " + szQueryStrCountry);

//Query using get operation
index.get(query);

// Open an array of connections to handle connections to SolrCloud needed 
// for parallel text search
CloudSolrServer[] conns = new CloudSolrServer[dop];

for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = index.getCloudSolrServer(15 /* write timeout in 
secs*/);
}

// Iterate to cover all the shards in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = index.getPartitioned(conns /* connections */, 
 query, 
 split /* start split ID */);

lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Close the connections to SolCloud after completion
for (int idx = 0; idx &lt; conns.length; idx++) { 
  conns[idx].shutdown();
}

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-F0D99092-49A0-434E-9827-C672CC18F64C" name="GUID-F0D99092-49A0-434E-9827-C672CC18F64C"></a><h4 id="SPGDG-GUID-F0D99092-49A0-434E-9827-C672CC18F64C" class="sect4"><span class="enumeration_section">2.6.10 </span>Using Native Query Results on Text Indexes for Property Graph Data
                  </h4>
                  <div>
                     <p>Applying native query results directly into property graph data enables users to take full advantage of the querying capabilities of the text search engine (Apache Lucene or SolrCloud). This way, users can execute different type of queries (like Faceted queries) on the text engine and parse the retrieved results into vertices (or edges) objects.</p>
                     <p>Using text searches with Query results will produce an <code class="codeph">Iterable</code> object holding all the vertices (or edges) from the given result object. This approach will automatically rank the results based on their result set order.
                     </p>
                     <p>To execute the search queries directly into Apache Lucene or SolrCloud index, you may need to consider the data type used by the key/value pair to be matched, as well as the configuration of the search engine used. For more information about building a search term, see <a href="using-property-graphs-oracle-database.html#GUID-26C80DDB-DA5A-48B6-B729-9BE34DECCBB6">Handling Data Types</a>.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Using Native Query Results with Apache Lucene</p>
                        </li>
                        <li>
                           <p>Using Native Query Results with SolrCloud</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3">Using  Native Query Results with Apache Lucene</p>
                        <p>You can use native query results using Apache Lucene by calling the method&nbsp;<code class="codeph">get(TopDocs)&nbsp;in&nbsp;LuceneIndex</code>. A <code class="codeph">TopDocs</code> object provides a set of Documents matching a text search query over a specific Apache Lucene directory. <code class="codeph">LuceneIndex</code> will produce an <code class="codeph">Iterable</code> object holding all the vertices (or edges) from the documents found in the <code class="codeph">TopDocs</code> object.
                        </p>
                        <p>Oracle property graph text indexes that use Apache Lucene are created using multiple Apache Lucene directories. Indexed vertices and edges are spread among the directories to enhance storage scalability and query performance. If you need to execute a query against all the data in the property graph’s text index, you must execute the query against each Apache Lucene directory. You can easily get the <code class="codeph">IndexSearcher</code> object associated to a directory by using the API <code class="codeph">getOracleSearcher in LuceneIndex</code>.
                        </p>
                        <p>The following code fragment generates an automatic text index using Apache Lucene Search engine, creates a Lucene Query and executes it against an <code class="codeph">IndexSearcher</code> object to get a <code class="codeph">TopDocs</code> object. Later, an <code class="codeph">Iterable</code> of vertices is created from the result object.
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.lucene.LuceneIndex;
import org.apache.lucene.search.*;
import org.apache.lucene.index.*;

...

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 …);

// Create an automatic index
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name and country properties for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the LuceneIndex object 
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
Term term = index.buildSearchTermObject("name", "Beyo*", String.class);
Query queryBey = new WildcardQuery(term);

// Add another condition to query all the vertices whose country is 
//"United States"
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

Query queryCountry = new PhraseQuery();
StringTokenizer st = new StringTokenizer(value);
while (st.hasMoreTokens()) {
  queryCountry.add(new Term(key, st.nextToken()));
};

//Concatenate queries
BooleanQuery bQuery = new BooleanQuery();
bQuery.add(queryBey, BooleanClause.Occur.MUST);
bQuery.add(queryCountry, BooleanClause.Occur.MUST);

// Get the IndexSearcher object needed to execute the query. 
// The index searcher object is mapped to a single Apache Lucene directory
<span class="bold">SearcherManager searcherMgr = 
         index.getOracleSearcherManager(0, true /* skip looking in the cache*/); 
IndexSearcher indexSearcher = searcherMgr.acquire();
// search for the first 1000 results in the current index directory 0
TopDocs docs = index.search(bQuery, 1000); 

long lCount = 0;
Iterable&lt;Vertex&gt; it = index.get(docs);
</span>
while (it.hasNext()) {
  System.out.println(it.next());
  lCount++;
}
System.out.println("Vertices found: "+ lCount);
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3">Using Native Query Results with SolrCloud</p>
                        <p>You can use native query results using SolrCloud by calling the method&nbsp;<code class="codeph">get(QueryResponse)</code>&nbsp;in&nbsp;<code class="codeph">SolrIndex</code>. A <code class="codeph">QueryResponse</code> object provides a set of Documents matching a text search query over a specific SolrCloud collection. <code class="codeph">SolrIndex</code> will produce an <code class="codeph">Iterable</code> object holding all the vertices (or edges) from the documents found in the <code class="codeph">QueryResponse</code> object.
                        </p>
                        <p>The following code fragment generates an automatic text index using the Apache SolrCloud Search engine, creates a&nbsp;<code class="codeph">SolrQuery</code>&nbsp;object, and executes it against a <code class="codeph">CloudSolrServer</code> object to get a <code class="codeph">QueryResponse</code> object. Later, an <code class="codeph">Iterable</code> of vertices is created from the result object.
                        </p><pre class="oac_no_warn" dir="ltr">import oracle.pg.text.solr.*;
import org.apache.solr.client.solrj.*;

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 …);

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout          /* zookeeper timeout in seconds */,
 numShards          /* total number of shards */,
 replicationFactor  /* Replication factor */,
 maxShardsPerNode   /* maximum number of shardsper node*/,
 4                  /* dop used for scan */,
 10000              /* batch size before commit*/,
 500000             /* commit size before SolrCloud commit*/,
 15                 /* write timeout in seconds */
);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the SolrIndex object 
SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
String szQueryStrBey = index.buildSearchTerm("name", "Beyo*", String.class);
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

String szQueryStrCountry = key + ":" + value;
Solrquery query = new SolrQuery(szQueryStrBey + " AND " + szQueryStrCountry);

<span class="bold">CloudSolrServer conn = index.getCloudSolrServer(15 /* write timeout in 
secs*/);

//Query using get operation
QueryResponse qr = conn.query(query, SolrRequest.METHOD.POST);
Iterable&lt;Vertex&gt; it = index.get(qr);
</span>
long lCount = 0;

while (it.hasNext()) {
  System.out.println(it.next());
  lCount++;
}

System.out.println("Vertices found: "+ lCount);
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7" name="GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7"></a><h3 id="SPGDG-GUID-5E5587AB-52F0-4C69-9C4B-6EC667620BB7" class="sect3"><span class="enumeration_section">2.7 </span>Access Control for Property Graph Data (Graph-Level and OLS)
               </h3>
               <div>
                  <p>The property graph feature in Oracle Spatial and Graph supports two access control and security models: graph level access control, and fine-grained security through integration with Oracle Label Security (OLS).</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Graph-level access control relies on grant/revoke to allow/disallow users other than the owner to access a property graph.</p>
                     </li>
                     <li>
                        <p>OLS for property graph data allows sensitivity labels to be associated with individual vertex or edge stored in a property graph.</p>
                     </li>
                  </ul>
                  <p>The default control of access to property graph data stored in an Oracle Database is at the graph level: the owner of a graph can grant read, insert, delete, update and select privileges on the graph to other users.</p>
                  <p> However, for applications with stringent security requirements, you can enforce a fine-grained access control mechanism by using the Oracle Label Security option of Oracle Database. With OLS, for each query, access to specific elements (vertices or edges) is granted by comparing their labels with the user's labels. (For information about using OLS, see <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/12.2/spgdg&amp;id=OLSAG001"><span><cite>Oracle Label Security Administrator’s Guide</cite></span></a>.)
                  </p>
                  <p>With Oracle Label Security enabled, elements (vertices or edges) may not be inserted in the graph if the same elements exist in the database with a stronger sensitivity label. For example, assume that you have a vertex with a very sensitive label, such as: <code class="codeph">( Vertex ID 1 {name:str:v1} "SENSITIVE" )</code>. This actually prevents a low-privileged (PUBLIC) user from updating the vertex:<code class="codeph"> ( Vertex ID 1 {name:str:v1} "PUBLIC" )</code>. On the other hand, if a high-privileged user overwrites a vertex or an edge that had been created with a low-level security label, the newer label with higher security will be assigned to the vertex or edge, and the low-privileged user will not be able to see it anymore.
                  </p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A">Applying Oracle Label Security (OLS) on Property Graph Data</a><br>This topic presents an example illustrating how to apply OLS to property graph data.
                     </li>
                  </ul>
               </div>
               
               <div class="sect3"><a id="GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A" name="GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A"></a><h4 id="SPGDG-GUID-3A4E6B7D-5803-4379-912E-9BCCFA08308A" class="sect4"><span class="enumeration_section">2.7.1 </span>Applying Oracle Label Security (OLS) on Property Graph Data
                  </h4>
                  <div>
                     <p>This topic presents an example illustrating how to apply OLS to property graph data.</p>
                     <p>Because the property graph is stored in regular relational tables, this example is no different from applying OLS on a regular relational table. The following shows how to configure and enable OLS, create a security policy with security labels, and apply it to a property graph. The code examples are very simplified, and do not necessarily reflect recommended practices regarding user names and passwords.</p>
                     <ol>
                        <li>
                           <p>As SYSDBA, create database users named userP, userP2, userS, userTS, userTS2 and pgAdmin.</p><pre class="pre codeblock"><code>CONNECT / as sysdba;

CREATE USER userP IDENTIFIED BY userPpass;
GRANT connect, resource, create table, create view, create any index TO userP;
GRANT unlimited TABLESPACE to userP;

CREATE USER userP2 IDENTIFIED BY userP2pass;
GRANT connect, resource, create table, create view, create any index TO userP2;
GRANT unlimited TABLESPACE to userP2;

CREATE USER userS IDENTIFIED BY userSpass;
GRANT connect, resource, create table, create view, create any index TO userS;
GRANT unlimited TABLESPACE to userS;

CREATE USER userTS IDENTIFIED BY userTSpass;
GRANT connect, resource, create table, create view, create any index TO userTS;
GRANT unlimited TABLESPACE to userTS;

CREATE USER userTS2 IDENTIFIED BY userTS2pass;
GRANT connect, resource, create table, create view, create any index TO userTS2;
GRANT unlimited TABLESPACE to userTS2;

CREATE USER pgAdmin IDENTIFIED BY pgAdminpass;
GRANT connect, resource, create table, create view, create any index TO pgAdmin;
GRANT unlimited TABLESPACE to pgAdmin;
</code></pre></li>
                        <li>
                           <p>As SYSDBA, configure and enable Oracle Label Security.</p><pre class="pre codeblock"><code>ALTER USER lbacsys IDENTIFIED BY lbacsys ACCOUNT UNLOCK;
EXEC LBACSYS.CONFIGURE_OLS;
EXEC LBACSYS.OLS_ENFORCEMENT.ENABLE_OLS;
</code></pre></li>
                        <li>
                           <p>As SYSTEM, grant privileges to sec_admin and hr_sec.</p><pre class="pre codeblock"><code>CONNECT system/&lt;system-password&gt;
GRANT connect, create any index to sec_admin IDENTIFIED BY password;
GRANT connect, create user, drop user, create role, drop any role TO hr_sec IDENTIFIED BY password;
</code></pre></li>
                        <li>
                           <p>As LBACSYS, create the security policy.</p><pre class="pre codeblock"><code>CONNECT lbacsys/&lt;lbacsys-password&gt;

BEGIN
SA_SYSDBA.CREATE_POLICY (
  policy_name =&gt; 'DEFENSE',
  column_name =&gt; 'SL',
  default_options =&gt; 'READ_CONTROL,LABEL_DEFAULT,HIDE');
END;
/
</code></pre></li>
                        <li>
                           <p>As LBACSYS , grant DEFENSE_DBA and execute to sec_admin and hr_sec users.</p><pre class="pre codeblock"><code>GRANT DEFENSE_DBA to sec_admin;
GRANT DEFENSE_DBA to hr_sec;

GRANT execute on SA_COMPONENTS to sec_admin;
GRANT execute on SA_USER_ADMIN to hr_sec;
</code></pre></li>
                        <li>
                           <p>As SEC_ADMIN, create three security levels (For simplicity, compartments and groups are omitted here.)</p><pre class="pre codeblock"><code>CONNECT sec_admin/&lt;sec_admin-password&gt;;

BEGIN
SA_COMPONENTS.CREATE_LEVEL ( 
  policy_name =&gt; 'DEFENSE', 
  level_num =&gt; 1000,
  short_name =&gt; 'PUB',
  long_name =&gt; 'PUBLIC'); 
END;
/
EXECUTE SA_COMPONENTS.CREATE_LEVEL('DEFENSE',2000,'CONF','CONFIDENTIAL');
EXECUTE SA_COMPONENTS.CREATE_LEVEL('DEFENSE',3000,'SENS','SENSITIVE');
</code></pre></li>
                        <li>
                           <p>Create three labels.</p><pre class="pre codeblock"><code>EXECUTE SA_LABEL_ADMIN.CREATE_LABEL('DEFENSE',1000,'PUB');
EXECUTE SA_LABEL_ADMIN.CREATE_LABEL('DEFENSE',2000,'CONF');
EXECUTE SA_LABEL_ADMIN.CREATE_LABEL('DEFENSE',3000,'SENS');
</code></pre></li>
                        <li>
                           <p>As HR_SEC, assign labels and privileges.</p><pre class="pre codeblock"><code>CONNECT hr_sec/&lt;hr_sec-password&gt;;

BEGIN
SA_USER_ADMIN.SET_USER_LABELS (
  policy_name =&gt; 'DEFENSE',
  user_name =&gt; 'UT',
  max_read_label =&gt; 'SENS',
  max_write_label =&gt; 'SENS',
  min_write_label =&gt; 'CONF',
  def_label =&gt; 'SENS',
  row_label =&gt; 'SENS');
END;
/

EXECUTE SA_USER_ADMIN.SET_USER_LABELS('DEFENSE', 'userTS', 'SENS');
EXECUTE SA_USER_ADMIN.SET_USER_LABELS('DEFENSE','userTS2','SENS');
EXECUTE SA_USER_ADMIN.SET_USER_LABELS('DEFENSE', 'userS', 'CONF');
EXECUTE SA_USER_ADMIN.SET_USER_LABELS ('DEFENSE', userP', 'PUB', 'PUB', 'PUB', 'PUB', 'PUB');
EXECUTE SA_USER_ADMIN.SET_USER_LABELS ('DEFENSE', 'userP2', 'PUB', 'PUB', 'PUB', 'PUB', 'PUB');
EXECUTE SA_USER_ADMIN.SET_USER_PRIVS ('DEFENSE', 'pgAdmin', 'FULL');
</code></pre></li>
                        <li>
                           <p>As SEC_ADMIN, apply the security policies to the desired property graph. Assume a property graph with the name OLSEXAMPLE with userP as the graph owner. To apply OLS security, execute the following statements.</p><pre class="pre codeblock"><code>CONNECT sec_admin/welcome1;

EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY ('DEFENSE', 'userP', 'OLSEXAMPLEVT$');
EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY ('DEFENSE', 'userP', 'OLSEXAMPLEGE$');
EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY ('DEFENSE', 'userP', 'OLSEXAMPLEGT$');
EXECUTE SA_POLICY_ADMIN.APPLY_TABLE_POLICY ('DEFENSE', 'userP', 'OLSEXAMPLESS$');
</code></pre></li>
                     </ol>
                     <p>Now Oracle Label Security has sensitivity labels to be associated with individual vertices or edges stored in the property graph. </p>
                     <p>The following example shows how to create a property graph with name OLSEXAMPLE, and an example flow to demonstrate the behavior when different users with different security labels create, read, and write graph elements.</p><pre class="pre codeblock"><code>// Create Oracle Property Graph
String graphName = "OLSEXAMPLE";
Oracle connPub = new Oracle("jdbc:oracle:thin:@host:port:SID",  "userP", "userPpass");
OraclePropertyGraph graphPub = OraclePropertyGraph.getInstance(connPub, graphName, 48);

// Grant access to other users
graphPub.grantAccess("userP2",  "RSIUD"); // Read, Select, Insert, Update, Delete (RSIUD)
graphPub.grantAccess("userS",   "RSIUD");
graphPub.grantAccess("userTS",  "RSIUD");
graphPub.grantAccess("userTS2", "RSIUD");
 
// Load data
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
String vfile = "../../data/connections.opv";
String efile = "../../data/connections.ope";
graphPub.clearRepository();
opgdl.loadData(graphPub, vfile, efile, 48, 1000, true, null);
System.out.println("Vertices with user userP and PUBLIC LABEL: " + graphPub.countVertices()); // 78
System.out.println("Vertices with user userP and PUBLIC LABEL: " + graphPub.countEdges());  // 164

// Second user with a higher level 
Oracle connTS = new Oracle("jdbc:oracle:thin:@host:port:SID", "userTS", "userTpassS");
OraclePropertyGraph graphTS = OraclePropertyGraph.getInstance(connTS, "USERP", graphName, 8, 48, null, null);
System.out.println("Vertices with user userTS and SENSITIVE LABEL: " + graphTS.countVertices()); // 78
System.out.println("Vertices with user userTS and SENSITIVE LABEL: " + graphTS.countEdges());  // 164

// Add vertices and edges with the second user
long lMaxVertexID = graphTS.getMaxVertexID();
long lMaxEdgeID = graphTS.getMaxEdgeID();
long size = 10;
System.out.println("\nAdd " + size + " vertices and edges with user userTS and SENSITIVE LABEL\n");
for (long idx = 1; idx &lt;= size; idx++) {
  Vertex v = graphTS.addVertex(idx + lMaxVertexID);
  v.setProperty("name", "v_" + (idx + lMaxVertexID));
  Edge e = graphTS.addEdge(idx + lMaxEdgeID, v, graphTS.getVertex(idx), "edge_" + (idx + lMaxEdgeID));
}
graphTS.commit();

// User userP with a lower level only sees the original vertices and edges, user userTS can see more
System.out.println("Vertices with user userP and PUBLIC LABEL: " + graphPub.countVertices()); // 78
System.out.println("Vertices with user userP and PUBLIC LABEL: " + graphPub.countEdges());  // 164
System.out.println("Vertices with user userTS and SENSITIVE LABEL: " + graphTS.countVertices()); // 88
System.out.println("Vertices with user userTS and SENSITIVE LABEL: " + graphTS.countEdges());  // 174

// Third user with a higher level 
Oracle connTS2 = new Oracle("jdbc:oracle:thin:@host:port:SID", "userTS2", "userTS2pass");
OraclePropertyGraph graphTS2 = OraclePropertyGraph.getInstance(connTS2, "USERP", graphName, 8, 48, null, null);
System.out.println("Vertices with user userTS2 and SENSITIVE LABEL: " + graphTS2.countVertices()); // 88
System.out.println("Vertices with user userTS2 and SENSITIVE LABEL: " + graphTS2.countEdges());  // 174

// Fourth user with a intermediate level 
Oracle connS = new Oracle("jdbc:oracle:thin:@host:port:SID", "userS", "userSpass");
OraclePropertyGraph graphS = OraclePropertyGraph.getInstance(connS, "USERP", graphName, 8, 48, null, null);
System.out.println("Vertices with user userS and CONFIDENTIAL LABEL: " + graphS.countVertices()); // 78
System.out.println("Vertices with user userS and CONFIDENTIAL LABEL: " + graphS.countEdges());  // 164
   
// Modify vertices with the fourth user
System.out.println("\nModify " + size + " vertices with user userS and CONFIDENTIAL LABEL\n");
for (long idx = 1; idx &lt;= size; idx++) {
  Vertex v = graphS.getVertex(idx);
  v.setProperty("security_label", "CONFIDENTIAL");
}
graphS.commit();

// User userP with a lower level that userS cannot see the new vertices
// Users userS and userTS can see them
System.out.println("Vertices with user userP with property security_label: " + OraclePropertyGraphUtils.size(graphPub.getVertices("security_label", "CONFIDENTIAL"))); // 0
System.out.println("Vertices with user userS with property security_label: " + OraclePropertyGraphUtils.size(graphS.getVertices("security_label", "CONFIDENTIAL"))); // 10
System.out.println("Vertices with user userTS with property security_label: " + OraclePropertyGraphUtils.size(graphTS.getVertices("security_label", "CONFIDENTIAL"))); // 10
System.out.println("Vertices with user userP and PUBLIC LABEL: " + graphPub.countVertices()); // 68
System.out.println("Vertices with user userTS and SENSITIVE LABEL: " + graphTS.countVertices()); // 88
</code></pre><p>The preceding example should produce the following output.</p><pre class="oac_no_warn" dir="ltr">Vertices with user userP and PUBLIC LABEL: 78
Vertices with user userP and PUBLIC LABEL: 164
Vertices with user userTS and SENSITIVE LABEL: 78
Vertices with user userTS and SENSITIVE LABEL: 164

Add 10 vertices and edges with user userTS and SENSITIVE LABEL

Vertices with user userP and PUBLIC LABEL: 78
Vertices with user userP and PUBLIC LABEL: 164
Vertices with user userTS and SENSITIVE LABEL: 88
Vertices with user userTS and SENSITIVE LABEL: 174
Vertices with user userTS2 and SENSITIVE LABEL: 88
Vertices with user userTS2 and SENSITIVE LABEL: 174
Vertices with user userS and CONFIDENTIAL LABEL: 78
Vertices with user userS and CONFIDENTIAL LABEL: 164

Modify 10 vertices with user userS and CONFIDENTIAL LABEL

Vertices with user userP with property security_label: 0
Vertices with user userS with property security_label: 10
Vertices with user userTS with property security_label: 10
Vertices with user userP and PUBLIC LABEL: 68
Vertices with user userTS and SENSITIVE LABEL: 88
</pre></div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7" name="GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7"></a><h3 id="SPGDG-GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7" class="sect3"><span class="enumeration_section">2.8 </span>Using the Groovy Shell with Property Graph Data
               </h3>
               <div>
                  <p>The Oracle Spatial and Graph property graph support includes a built-in Groovy shell (based on the original Gremlin Groovy shell script). With this command-line shell interface, you can explore the Java APIs.</p>
                  <p>To start the Groovy shell, go to the <code class="codeph">dal/groovy</code> directory under the installation home (<code class="codeph">$ORACLE_HOME/md/property_graph by default</code> by default). For example:
                  </p><pre class="oac_no_warn" dir="ltr">cd $ORACLE_HOME/md/property_graph/dal/groovy/</pre><p>Included is the script&nbsp;<code class="codeph">gremlin-opg-rdbms.sh</code>&nbsp;for connecting to an Oracle database.
                  </p>
                  <div class="infoboxnote" id="GUID-DFCC2E13-5548-4DAC-B0DE-E4CEF13E97C7__GUID-08B8E3DA-9227-4BF6-ABD3-7C3ABCC2CA38">
                     <p class="notep1">Note:</p>To run some gremlin traversal examples, you must first do the following import operation:<pre class="pre codeblock"><code>import com.tinkerpop.pipes.util.structures.*;
</code></pre></div>
                  <p>The following example connects to an Oracle database, gets an instance of <code class="codeph">OraclePropertyGraph</code> with graph name <code class="codeph">myGraph</code>, loads some example graph data, and gets the list of vertices and edges. 
                  </p><pre class="oac_no_warn" dir="ltr"><span class="bold">$ sh ./gremlin-rdbms.sh</span>
 
opg-rdbms&gt; cfg = 
cfg = GraphConfigBuilder.forPropertyGraphRdbms() \
.setJdbcUrl("jdbc:oracle:thin:@127.0.0.1:1521:orcl")\
.setUsername("scott").setPassword("tiger") \
.setName("connections") .setMaxNumConnections(2)\
.setLoadEdgeLabel(false) \
.addEdgeProperty("weight", PropertyType.DOUBLE, "1000000") \
.build();

opg-rdbms&gt; opg = OraclePropertyGraph.getInstance(cfg);
==&gt;oraclepropertygraph with name myGraph
 
opg-rdbms&gt; opgdl = OraclePropertyGraphDataLoader.getInstance();
==&gt;oracle.pg.nosql.OraclePropertyGraphDataLoader@576f1cad
 
opg-rdbms&gt; opgdl.loadData(opg, new FileInputStream("../../data/connections.opv"), new FileInputStream("../../data/connections.ope"), 4/*dop*/, 1000/*iBatchSize*/, true /*rebuildIndex*/, null /*szOptions*/); ==&gt;null
 
opg-rdbms&gt; opg.getVertices();
==&gt;Vertex ID 5 {country:str:Italy, name:str:Pope Francis, occupation:str:pope, religion:str:Catholicism, role:str:Catholic religion authority}
[... other output lines omitted for brevity ...]
 
opg-rdbms&gt;  opg.getEdges();
==&gt;Edge ID 1139 from Vertex ID 64 {country:str:United States, name:str:Jeff Bezos, occupation:str:business man} =[leads]=&gt; Vertex ID 37 {country:str:United States, name:str:Amazon, type:str:online retailing} edgeKV[{weight:flo:1.0}]
[... other output lines omitted for brevity ...]
</pre><p>The following example customizes several configuration parameters for in-memory analytics. It connects to an Oracle database, gets an instance of <code class="codeph">OraclePropertyGraph</code> with graph name <code class="codeph">myGraph</code>, loads some example graph data, gets the list of vertices and edges, gets an in-memory analyst, and executes one of the built-in analytics, triangle counting.
                  </p><pre class="oac_no_warn" dir="ltr"><span class="bold">$ sh ./gremlin-opg-rdbms.sh</span>
opg-rdbms&gt;
opg-rdbms&gt; dop=2;   // degree of parallelism
==&gt;2
opg-rdbms&gt; confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;();
opg-rdbms&gt; confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false);
==&gt;null
opg-rdbms&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop);
==&gt;null
opg-rdbms&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, 3);
==&gt;null
opg-rdbms&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2);
==&gt;null
opg-rdbms&gt; confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);
==&gt;null
opg-rdbms&gt; confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);
==&gt;null
opg-rdbms&gt; instance = Pgx.getInstance()
==&gt;null
opg-rdbms&gt; instance.startEngine(confPgx) 
==&gt;null

opg-rdbms&gt; 
cfg = GraphConfigBuilder.forPropertyGraphRdbms() \
.setJdbcUrl("jdbc:oracle:thin:@127.0.0.1:1521:orcl")\
.setUsername("scott").setPassword("tiger") \
.setName("connections") .setMaxNumConnections(2)\
.setLoadEdgeLabel(false) \
.addEdgeProperty("weight", PropertyType.DOUBLE, "1000000") \
.build(); 
opg-rdbms&gt; opg = OraclePropertyGraph.getInstance(cfg);  
==&gt;oraclepropertygraph with name myGraph
 
opg-rdbms&gt; opgdl = OraclePropertyGraphDataLoader.getInstance();
==&gt;oracle.pg.hbase.OraclePropertyGraphDataLoader@3451289b
 
opg-rdbms&gt; opgdl.loadData(opg, "../../data/connections.opv", "../../data/connections.ope", 4/*dop*/, 1000/*iBatchSize*/, true /*rebuildIndex*/, null /*szOptions*/);
==&gt;null
 
opg-rdbms&gt; opg.getVertices();
==&gt;Vertex ID 78 {country:str:United States, name:str:Hosain Rahman, occupation:str:CEO of Jawbone}
...
 
opg-rdbms&gt; opg.getEdges();
==&gt;Edge ID 1139 from Vertex ID 64 {country:str:United States, name:str:Jeff Bezos, occupation:str:business man} =[leads]=&gt; Vertex ID 37 {country:str:United States, name:str:Amazon, type:str:online retailing} edgeKV[{weight:flo:1.0}]
[... other output lines omitted for brevity ...]
 
opg-rdbms&gt; session = Pgx.createSession("session-id-1");
opg-rdbms&gt; g = session.readGraphWithProperties(cfg);
opg-rdbms&gt; analyst = session.createAnalyst();
 
opg-rdbms&gt;  triangles = analyst.countTriangles(false).get();
==&gt;22
</pre><p>For detailed information about the Java APIs, see the Javadoc reference information.</p>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE" name="GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE"></a><h3 id="SPGDG-GUID-24C684A5-8A18-45F3-9F0D-A8F7CCF964BE" class="sect3"><span class="enumeration_section">2.9 </span>Creating Property Graph Views on an RDF Graph
               </h3>
               <div>
                  <p>With Oracle Spatial and Graph, you can view RDF data as a property graph to execute graph analytics operations by creating property graph views over an RDF graph stored in Oracle Database.</p>
                  <p>Given an RDF model (or a virtual model), the property graph feature creates two views, a &lt;graph_name&gt;VT$ view for vertices and a &lt;graph_name&gt;GE$ view for edges.</p>
                  <p>The <code class="codeph">PGUtils.createPropertyGraphViewOnRDF</code> method lets you customize a property graph view over RDF data:
                  </p><pre class="oac_no_warn" dir="ltr">public static void createPropertyGraphViewOnRDF( Connection conn /* a Connection instance to Oracle database */,
      String pgGraphName /* the name of the property graph to be created */,
      String rdfModelName /* the name of the RDF model */,
      boolean virtualModel /* a flag represents if the RDF model
                              is virtual model or not; 
                              true &#x2013; virtual mode, false &#x2013; normal model*/,
      RDFPredicate[] predListForVertexAttrs /* an array of RDFPredicate objects specifying how to create vertex view using these predicates; each RDFPredicate includes two fields: an URL of the RDF predicate, the corresponding name of vertex key in the Property Graph. The mapping from RDF predicates to vertex keys will be created based on this parameter.  */,
      RDFPredicate[] predListForEdges /* an array of RDFPredicate specifying how to create edge view using these predicates; each RDFPredicate includes two (or three) fields: an URL of the RDF predicate, the edge label in the Property Graph, the weight of the edge (optional). The mapping from RDF predicates to edges will be created based on this parameter. */)
</pre><p>This operation requires the name of the property graph, the name of the RDF Model used to generate the Property Graph view, and a set of mappings determining how triples will be parsed into vertices or edges. The <code class="codeph">createPropertyGraphViewOnRDF</code> method requires a <span class="italic">key/value mapping</span> array specifying how RDF predicates are mapped to Key/Value properties for vertices, and an <span class="italic">edge mapping</span> array specifying how RDF predicates are mapped to edges. The <code class="codeph">PGUtils.RDFPredicate</code> API lets you create a map from RDF assertions to vertices/edges.
                  </p>
                  <p>Vertices are created based on the triples matching at least one of the RDF predicates in the key/value mappings. Each triple satisfying one of the RDF predicates defined in the mapping array is parsed into a vertex with ID based on the internal RDF resource ID of the subject of the triple, and a key/value pair whose key is defined by the mapping itself and whose value is obtained from the object of the triple.</p>
                  <p>The following example defines a key/value mapping of the RDF predicate URI <code class="codeph">http://purl.org/dc/elements/1.1/title</code> to the key/value property with property name <code class="codeph">title</code>.
                  </p><pre class="oac_no_warn" dir="ltr">String titleURL = "http://purl.org/dc/elements/1.1/title";
// create an RDFPredicate to specify how to map the RDF predicate to vertex keys
RDFPredicate titleRDFPredicate 
              = RDFPredicate.getInstance(titleURL /* RDF Predicate URI */ , 
                                         "title" /* property name */);
</pre><p>Edges are created based on the triples matching at least one of the RDF predicates in the edge mapping array.  Each triple satisfying the RDF predicate defined in the mapping array is parsed into an edge with ID based on the row number, an edge label defined by the mapping itself, a source vertex obtained from the RDF Resource ID of the subject of the triple, and a destination vertex obtained from the RDF Resource ID of the object of the triple. For each triple parsed here, two vertices will be created if they were not generated from the key/value mapping.</p>
                  <p>The following example defines an edge mapping of the RDF predicate URI <code class="codeph">http://purl.org/dc/elements/1.1/reference</code> to an edge with a label <span class="italic">references</span> and a weight of 0.5d.
                  </p><pre class="oac_no_warn" dir="ltr">String referencesURL = "http://purl.org/dc/terms/references";
// create an RDFPredicate to specify how to map the RDF predicate to edges
RDFPredicate referencesRDFPredicate    
                      = RDFPredicate.getInstance(referencesURL, "references", 0.5d);
</pre><p>The following example creates a property graph view over the RDF model <code class="codeph">articles</code> describing different publications, their authors, and references. The generated property graph will include vertices with some key/value properties that may include <code class="codeph">title</code> and <code class="codeph">creator</code>. The edges in the property graph will be determined by the references among publications.
                  </p><pre class="oac_no_warn" dir="ltr">Oracle oracle = null;
Connection conn = null;
OraclePropertyGraph pggraph = null;
try {
  // create the connection instance to Oracle database
  OracleDataSource ds = new oracle.jdbc.pool.OracleDataSource();
  ds.setURL(jdbcUrl);
  conn = (OracleConnection) ds.getConnection(user, password);
 	
  // define some string variables for RDF predicates
  String titleURL = "http://purl.org/dc/elements/1.1/title";
  String creatorURL = "http://purl.org/dc/elements/1.1/creator";
  String serialnumberURL = "http://purl.org/dc/elements/1.1/serialnumber";
  String widthURL = "http://purl.org/dc/elements/1.1/width";
  String weightURL = "http://purl.org/dc/elements/1.1/weight";
  String onsaleURL = "http://purl.org/dc/elements/1.1/onsale";
  String publicationDateURL = "http://purl.org/dc/elements/1.1/publicationDate";
  String publicationTimeURL = "http://purl.org/dc/elements/1.1/publicationTime";
  String referencesURL = "http://purl.org/dc/terms/references";
     
  // create RDFPredicate[] predsForVertexAttrs to specify how to map 
  // RDF predicate to vertex keys
  RDFPredicate[] predsForVertexAttrs = new RDFPredicate[8];
  predsForVertexAttrs[0] = RDFPredicate.getInstance(titleURL, "title");
  predsForVertexAttrs[1] = RDFPredicate.getInstance(creatorURL, "creator");
  predsForVertexAttrs[2] = RDFPredicate.getInstance(serialnumberURL, 
                                                    "serialnumber");
  predsForVertexAttrs[3] = RDFPredicate.getInstance(widthURL, "width");
  predsForVertexAttrs[4] = RDFPredicate.getInstance(weightURL, "weight");
  predsForVertexAttrs[5] = RDFPredicate.getInstance(onsaleURL, "onsale");
  predsForVertexAttrs[6] = RDFPredicate.getInstance(publicationDateURL, 
                                                    "publicationDate");
  predsForVertexAttrs[7] = RDFPredicate.getInstance(publicationTimeURL, 
                                                    "publicationTime");

  // create RDFPredicate[] predsForEdges to specify how to map RDF predicates to 
  // edges
  RDFPredicate[] predsForEdges = new RDFPredicate[1];
  predsForEdges[0] = RDFPredicate.getInstance(referencesURL, "references", 0.5d);
      
  // create PG view on RDF model
 <span class="bold"> PGUtils.createPropertyGraphViewOnRDF(conn, "articles", "articles", false, 
                                       predsForVertexAttrs, predsForEdges);
</span>
  // get the Property Graph instance
  oracle = new Oracle(jdbcUrl, user, password);
  pggraph = OraclePropertyGraph.getInstance(oracle, "articles", 24);

  System.err.println("------ Vertices from property graph view ------");
  pggraph.getVertices();
  System.err.println("------ Edges from property graph view ------");
  pggraph.getEdges();
}
finally {
  pggraph.shutdown();
  oracle.dispose();
  conn.close();
}
</pre><p>Given the following triples in the <code class="codeph">articles</code> RDF model (11 triples), the output property graph will include two vertices, one for <code class="codeph">&lt;http://nature.example.com/Article1&gt;</code> (v1) and another one for <code class="codeph">&lt;http://nature.example.com/Article2&gt;</code> (v2). For vertex v1, it has eight properties, whose values are the same as their RDF predicates. For example, v1’s title is <span class="italic">“All about XYZ”.</span> Similarly for vertex v2, it has two properties: <code class="codeph">title</code> and <code class="codeph">creator</code>. The output property graph will include a single edge (eid:1) from vertex v1 to vertex v2 with an edge label <span class="italic">“references”</span> and a weight of 0.5d.
                  </p><pre class="oac_no_warn" dir="ltr">&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; “All about XYZ”^^xsd:string.
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/creator&gt; “Jane Smith”^^xsd:string. 
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/serialnumber&gt; “123456”^^xsd:integer.
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/width&gt; “10.5”^^xsd:float.
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/weight&gt; “1.08”^^xsd:double. 
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/onsale&gt; “false”^^xsd:boolean. 
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/publicationDate&gt; “2016-03-08”^^xsd:date) 
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/elements/1.1/publicationTime&gt; “2016-03-08T10:10:10”^^xsd:dateTime) 
&lt;http://nature.example.com/Article2&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; “A review of ABC”^^xsd:string.
&lt;http://nature.example.com/Article2&gt; &lt;http://purl.org/dc/elements/1.1/creator&gt; “Joe Bloggs”^^xsd:string.
&lt;http://nature.example.com/Article1&gt; &lt;http://purl.org/dc/terms/references&gt; &lt;http://nature.example.com/Article2&gt;.
</pre><p>The preceding code will produce an output similar as the following. Note that the internal RDF resource ID values may vary across different Oracle databases.</p><pre class="oac_no_warn" dir="ltr">------ Vertices from property graph view ------
Vertex ID 7299961478807817799 {creator:str:Jane Smith, onsale:bol:false, publicationDate:dat:Mon Mar 07 16:00:00 PST 2016, publicationTime:dat:Tue Mar 08 02:10:10 PST 2016, serialnumber:dbl:123456.0, title:str:All about XYZ, weight:dbl:1.08, width:flo:10.5}
Vertex ID 7074365724528867041 {creator:str:Joe Bloggs, title:str:A review of ABC}
------ Edges from property graph view ------
Edge ID 1 from Vertex ID 7299961478807817799 {creator:str:Jane Smith, onsale:bol:false, publicationDate:dat:Mon Mar 07 16:00:00 PST 2016, publicationTime:dat:Tue Mar 08 02:10:10 PST 2016, serialnumber:dbl:123456.0, title:str:All about XYZ, weight:dbl:1.08, width:flo:10.5} =[references]=&gt; Vertex ID 7074365724528867041 {creator:str:Joe Bloggs, title:str:A review of ABC} edgeKV[{weight:dbl:0.5}]
</pre></div>
            </div>
            <div class="props_rev_3"><a id="GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" name="GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00"></a><h3 id="SPGDG-GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00" class="sect3"><span class="enumeration_section">2.10 </span>Handling Property Graphs Using a Two-Tables Schema
               </h3>
               <div>
                  <p>For property graphs with relatively fixed, simple data structures, where you do not need the flexibility of <code class="codeph">&lt;graph_name&gt;VT$</code> and <code class="codeph">&lt;graph_name&gt;GE$</code>  key/value data tables for vertices and edges, you can use a two-tables schema to achieve better run-time performance. 
                  </p>
                  <p>The two-tables schema approach is an alternative to using the property graph schema (described in Property Graph Schema Objects for Oracle Database). </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The property graph schema approach is designed mainly for heterogeneous and/or large graphs.When a graph model is used to present a dynamic application domain in which new relationships and possibly new data types for the same property name(s) are introduced and added to the graph model on the fly, using the property graph schema is recommended.</p>
                        <p>When a graph model is used to present a dynamic application domain in which new relationships and possibly new data types for the same property name(s) are introduced and added to the graph model on the fly, using the property graph schema is recommended.</p>
                     </li>
                     <li>
                        <p>The two-tables schema approach is designed for homogenous graphs.</p>
                        <p>If a graph model represents an application domain where the set of relationships is already known and the total number of distinct relationships is relatively small (less than 1000), then the two-tables approach is recommended. This situation usually happens when the original data source is from one or a set of existing relational tables or views.</p>
                     </li>
                  </ul>
                  <p>An example of where the two-tables approach might be useful is if all nodes are employees of a specific organization, and each employee has a limited and fixed set of attributes and potential relationships. An example of where the two-tables approach would not be useful is if the nodes can be any individuals who can have different attributes and relationships, and where attributes and relationships can be dynamically added and altered.</p>
                  <p>In the flexible key/value approach (<span class="italic">not</span> two-tables), Oracle Spatial and Graph stores property graph data with a flexible schema:  <code class="codeph">&lt;graph_name&gt;VT$</code> for vertices and <code class="codeph">&lt;graph_name&gt;GE$</code> for edges. In this schema, vertices and edges are stored using multiple rows where each row represents a key/value property associated with the vertex (or the edge) with a flexible data type, determined by the attribute <code class="codeph">T</code> (type). This schema design can easily accommodate a heterogeneous graph where vertices (edges) have different set of properties or data types of property values.
                  </p>
                  <p>On the other hand, for a property graph with a homogeneous structure, you can store graph data using a two-tables schema. With this approach, each vertex is stored as a single row in a named vertex table, and each edge as a single row in a named edge table. This way, each column in the row corresponds to a property with a fixed data type. The in-memory analyst can then use this approach to construct and manage the in-memory graphs.</p>
                  <div class="infoboxnote" id="GUID-7A2037E1-2DB7-40A2-AA37-0A91D0E34D00__GUID-4C489E91-0C00-47B4-BCA6-59493964217B">
                     <p class="notep1">Note:</p>
                     <p>The two-tables approach is mainly for providing graph data for the in-memory analyst to existing Blueprints-based Java APIs, and text indexing does <span class="bold">not</span> work with the two-tables approach.
                     </p>
                     <p>Graph data change tracking is only available when the property graph schema approach is used.</p>
                  </div>
                  <p>The following topics focus on how to create a property graph using a two-tables schema, as well as how to execute read and write operations over this data.</p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD">Preparing the Two-Tables Schema</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65">Storing Data in a Property Graph Using a Two-Tables Schema</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE">Reading Data from a Property Graph Using a Two-Tables Schema</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD" name="GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD"></a><h4 id="SPGDG-GUID-AE6022AC-2B38-46AA-83E7-3A94DD2648CD" class="sect4"><span class="enumeration_section">2.10.1 </span>Preparing the Two-Tables Schema
                  </h4>
                  <div>
                     <p><code class="codeph">OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab</code> lets you customize the schema of a vertex table using a two-tables schema to store all the vertices in a graph. This operation requires a connection to an Oracle database, the table owner, the table name, and two arrays specifying the property names and their data types.  By default, the table schema of the generated table includes the attribute <code class="codeph">VID</code>, which represents the primary key of the table and is mapped to the vertex ID.
                     </p>
                     <p>The following code snippet creates a vertex table using a two-tables schema. In this case, the generated table <code class="codeph">employeesNodes</code> will include four attributes: <code class="codeph">name</code>, <code class="codeph">age</code>, <code class="codeph">address</code>, and <code class="codeph">SSN</code> (Social Security Number). The primary key of the vertex table is the generated attribute <code class="codeph">VID</code>.
                     </p><pre class="pre codeblock"><code>import oracle.pgx.common.types.PropertyType;
List&lt;String&gt; propertyNames = new ArrayList&lt;String&gt;();
propertyNames.addAll(new String[4]{ "name", "age", "address", "SSN" });

List&lt;PropertyType&gt; = new ArrayList&lt;PropertyType&gt;();
propertyType.add(PropertyType.STRING);
propertyType.add(PropertyType.INTEGER);
propertyType.add(PropertyType.STRING);
propertyType.add(PropertyType.STRING);

<span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab(conn /* Connection object */,
                                            pg /* table owner */, 
                                            "employeesNodes" /* vertex table name */, 
                                            propertyNames /* property names */, 
                                            propertyTypes /* property data types */,
                                            "pgts" /* table space */, 
                                            null /* storage options */, 
                                            true /* no logging */);</span>
</code></pre><p>The preceding code produces a table schema as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE employeenodes
( VID number not null,
  NAME nvarchar2(15000),
  AGE integer,
  ADDRESS nvarchar2(15000),
  SSN nvarchar2(15000),  
  CONSTRAINT employenodes_pk PRIMARY KEY (VID)
);
</pre><p>Similarly, <code class="codeph">OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab</code> lets you customize the schema of an edge table using a two-tables schema to store all the edges in a graph. This operation requires a connection to an Oracle database, the table owner, the table name, a two arrays specifying the property names and their data types. By default, the table schema of the generated table includes the following attributes: <code class="codeph">EID</code>, which represents the primary key of the table and is mapped to the edge ID; <code class="codeph">EL</code>, which is mapped to the edge label; and <code class="codeph">SVID</code> and <code class="codeph">DVID</code> for the source and destination vertex IDs, respectively.
                     </p>
                     <p>The following code snippet creates an edge table using a two-tables schema. In this case, the generated table <code class="codeph">organizationEdges</code> will include the attribute named <code class="codeph">weight</code>. The primary key of the vertex table is the generated attribute <code class="codeph">EID</code>, which is the default attribute of the table schema, mapped to the vertices' ID (long value) values.
                     </p><pre class="pre codeblock"><code>import oracle.pgx.common.types.PropertyType;
List&lt;String&gt; propertyNames = new ArrayList&lt;String&gt;();
propertyNames.addAll(new String[1]{ "weight" });

List&lt;PropertyType&gt; = new ArrayList&lt;PropertyType&gt;();
propertyType.add(PropertyType.DOUBLE);
<span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab(conn /* Connection object */,
                                            pg /* table owner */, 
                                            organizationEdges" /* edge table name */, 
                                            propertyNames /* property names */, 
                                            propertyTypes /* property data types */,
                                            "pgts" /* table space */, 
                                            null /* storage options */, 
                                            true /* no logging */);</span>
</code></pre><p>The preceding code produces a table structure as follows:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE organizationedges
( EID number not null,
  SVID number not null,
  DVID number not null,
  EL nvarchar2(3100),
  WEIGHT number,
  CONSTRAINT organizationedges_pk PRIMARY KEY (EID)
);
</pre><p>Note that if the table already exists, both <code class="codeph">prepareTwoTablesGraphEdgeTab</code> and <code class="codeph">prepareTwoTablesGraphEdgeTab</code> will truncate the table contents.
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65" name="GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65"></a><h4 id="SPGDG-GUID-D494CD8D-80D7-45B0-A6FF-E35988AE5A65" class="sect4"><span class="enumeration_section">2.10.2 </span>Storing Data in a Property Graph Using a Two-Tables Schema
                  </h4>
                  <div>
                     <p>To load a set of vertices into a vertex table using a two-tables schema, you can use the API <code class="codeph">OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties</code>. This operation takes an array of  Iterable (or Iterator) of TinkerPop Blueprints Vertex objects, and reads out the ID and the values for the properties defined in the vertex table schema. Based on this information, the vertex is later inserted as a new row in the vertex table. Note that if a vertex does not include a property defined in the schema, the value for that associated column is set to NULL. 
                     </p>
                     <p>The following code snippet creates a property graph <code class="codeph">employeesGraphDAL</code> using the <code class="codeph">OraclePropertyGraph</code> API, and loads two vertices and an edge. Then, it creates a vertex table <code class="codeph">employeesNodes</code> using a two-tables schema and populates it with the data from the vertices in <code class="codeph">employeesGraphDAL</code>. Note that the property <code class="codeph">email</code> in the vertex <code class="codeph">v1</code> is not loaded into the <code class="codeph">employeesNode</code> table because it is not defined in the schema. Also, the property <code class="codeph">SSN</code> for vertex <code class="codeph">v2</code> is set NULL because it is not defined in the vertex.
                     </p><pre class="pre codeblock"><code>// Create employeesGraphDAL
import oracle.pg.rdbms.*;
Oracle oracle = new Oracle(jdbcURL, username, password);
OraclePropertyGraph opgEmployees
                  = OraclePropertyGraph.getInstance(oracle, "employeesGraphDAL");

// Create vertex v1 and assign it properties as key-value pairs
Vertex v1 = opgEmployees.addVertex(1l);
v1.setProperty("age",  Integer.valueOf(31));
v1.setProperty("name", "Alice");
v1.setProperty("address", "Main Street 12");
v1.setProperty("email", "alice@mymail.com");
v1.setProperty("SSN", "123456789");

Vertex v2 = opgEmployees.addVertex(2l);
v2.setProperty("age",  Integer.valueOf(27));
v2.setProperty("name", "Bob");
v2.setProperty("adress", "Sesame Street 334"); 
       
// Add edge e1
Edge e1 = opgEmployees.addEdge(1l, v1, v2, "managerOf");
e1.setProperty("weight", 0.5d);

opgEmployees.commit();

// Prepare the vertex table using a Two Tables schema
import oracle.pgx.common.types.PropertyType;
List&lt;String&gt; propertyNames = new ArrayList&lt;String&gt;();
propertyNames.addAll(new String[4]{ "name", "age", "address", "SSN" });

List&lt;PropertyType&gt; = new ArrayList&lt;PropertyType&gt;();
propertyType.add(PropertyType.STRING);
propertyType.add(PropertyType.INTEGER);
propertyType.add(PropertyType.STRING);
propertyType.add(PropertyType.STRING);

Connection conn 
     = opgEmployees.getOracle().clone().getConnection(); /* Clone the connection
                                                            from the property graph 
                                                            instance */    
<span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab(conn /* Connection object */,
                                            pg /* table owner */, 
                                            "employeesNodes" /* vertex table name */, 
                                            propertyNames /* property names */, 
                                            propertyTypes /* property data types */,
                                            "pgts" /* table space */, 
                                            null /* storage options */, 
                                            true /* no logging */);
</span>
// Get the vertices from the employeesDAL graph
Iterable&lt;Vertex&gt; vertices = opgEmployees.getVertices();

<span class="bold">// Load the vertices into the vertex table using a Two-Tables schema</span>
Connection[] conns = new Connection[1]; /* the connection array size defines the
                                           Degree of parallelism (multithreading)
                                        */
conns[1] = conn;
<span class="bold">OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties(
                                           conn /* Connectionobject */,
                                            pg /* table owner */, 
                                            "employeesNodes" /* vertex table name */,  
                                            1000 /* batch size*/, 
                                            new Iterable[] {vertices} /* array of 
                                                                vertex iterables */);</span> 
</code></pre><p>To load a set of edges into an edge table using a two-tables schema, you can use the API <code class="codeph">OraclePropertyGraphUtils.writeTwoTablesGraphEdgesAndProperties</code>. This operation takes an array of Iterable (or Iterator) of Blueprints Edge objects, and  reads out the ID, EL, SVID, DVID, and the values for the properties defined in the edge table schema. Based on this information, the edge is later inserted as a new row in the edge table. Note that if an edge does not include a property defined in the schema, the value for that given column is set to NULL. 
                     </p>
                     <p>The following code snippet creates a property graph <code class="codeph">employeesGraphDAL</code> using the <code class="codeph">OraclePropertyGraph</code> API, and loads two vertices and an edge. Then, it creates a vertex table <code class="codeph">organizationEdges</code> using a two-tables schema, and populates it with the data from the edges in <code class="codeph">employeesGraphDAL</code>.
                     </p><pre class="pre codeblock"><code>// Create employeesGraphDAL
import oracle.pg.rdbms.*;
Oracle oracle = new Oracle(jdbcURL, username, password);
OraclePropertyGraph opgEmployees
                  = OraclePropertyGraph.getInstance(oracle, "employeesGraphDAL");

// Create vertex v1 and assign it properties as key-value pairs
Vertex v1 = opgEmployees.addVertex(1l);
v1.setProperty("age",  Integer.valueOf(31));
v1.setProperty("name", "Alice");
v1.setProperty("address", "Main Street 12");
v1.setProperty("email", "alice@mymail.com");
v1.setProperty("SSN", "123456789");

Vertex v2 = opgEmployees.addVertex(2l);
v2.setProperty("age",  Integer.valueOf(27));
v2.setProperty("name", "Bob");
v2.setProperty("adress", "Sesame Street 334"); 
       
// Add edge e1
Edge e1 = opgEmployees.addEdge(1l, v1, v2, "managerOf");
e1.setProperty("weight", 0.5d);

opgEmployees.commit();

// Prepare the edge table using a Two Tables schema
import oracle.pgx.common.types.PropertyType;
       Connection conn 
            = opgEmployees.getOracle().clone().getConnection(); /* Clone the connection
                                                                   from the property graph 
                                                                   instance */    
List&lt;String&gt; propertyNames = new ArrayList&lt;String&gt;();
propertyNames.addAll(new String[1]{ "weight" });

List&lt;PropertyType&gt; = new ArrayList&lt;PropertyType&gt;();
propertyType.add(PropertyType.DOUBLE);
<span class="bold">OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab(conn /* Connection object */,
                                            pg /* table owner */, 
                                            organizationEdges" /* edge table name */, 
                                            propertyNames /* property names */, 
                                            propertyTypes /* property data types */,
                                            "pgts" /* table space */, 
                                            null /* storage options */, 
                                            true /* no logging */);
</span>
// Get the edges from the employeesDAL graph
Iterator&lt;Edge&gt; edges = opgEmployees.getEdges().iterator();

<span class="bold">// Load the edges into the edges table using a Two-Tables schema
</span>Connection[] conns = new Connection[1]; /* the connection array size defines the
                                           Degree of parallelism (multithreading)
                                        */
conns[1] = conn;
<span class="bold">OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties(conn /* Connection 
                                                                        object */,
                                            pg /* table owner */, 
                                            "organizationEdges" /* edge table 
                                                                   name */,  
                                            1000 /* batch size*/, 
                                            new Iterator[] {edges} /* array of 
                                                           iterator of edges */);</span> 
</code></pre><p>To optimize the performance of the storing operations, you can specify a set of flags and hints when calling the <code class="codeph">writeTwoTablesGraph</code> APIs. These hints include:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">DOP</span>:  Degree of parallelism. The size of the connection array defines the degree of parallelism to use when loading the data. This determines the number of chunks to generate when reading the Iterables as well as the number of loader threads to use when loading the data into the table.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Batch Size</span>: An integer specifying the batch size to use for Oracle update statements in batching mode. A recommended batch size is 1000.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE" name="GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE"></a><h4 id="SPGDG-GUID-977CBAFC-9B5B-4C48-BF65-626E410A85FE" class="sect4"><span class="enumeration_section">2.10.3 </span>Reading Data from a Property Graph Using a Two-Tables Schema
                  </h4>
                  <div>
                     <p>To read a subset of vertices from a vertex table using a two-tables schema, you can use the API <code class="codeph">OraclePropertyGraphUtils.readTwoTablesGraphVertexAndProperties</code>. This operation returns an array of <code class="codeph">ResultSet</code> objects with all the rows found in the corresponding splits of the vertex table. Each <code class="codeph">ResultSet</code> object in the array uses one of the connections provided to fetch the vertex rows from the corresponding split. The splits are determined by the specified number of total splits.
                     </p>
                     <p>An integer ID (in the range of [0, N - 1]) is assigned to the splits in the vertex table with N splits. This way, the subset of splits queried will consist of those splits with ID value in the range between the start split ID and the start split ID plus the size of the connection array. If the sum is greater than the total number of splits, then the subset of splits queried will consist of those splits with ID in the range of [start split ID, N - 1].</p>
                     <p>The following code reads all vertices from a vertex table using a two-tables schema using a total of 1 split. Note that you can easily create an array of Blueprints Vertex Iterables by executing the API on <code class="codeph">OraclePropertyGraph</code>. The vertices retrieved will include all the properties defined in the vertex table schema.
                     </p><pre class="pre codeblock"><code>ResultSet[] rsAr = readTwoTablesGraphVertexAndProperties(conns, 
                                                 "pg" /* table owner */,
                                                 "employeeNodes /* vertex table 
                                                                   name */,                                                                                              
                                                 1 /* Total Splits*/, 
                                                 0 /* Start Split);

Iterable&lt;Vertex&gt;[] vertices = getVerticesPartitioned(rsAr /* ResultSet array */,
                                                     true /* skip store to cache */,
                                                     null /* vertex filter 
                                                              callback */,
                                                     null /* optimization flag */);
</code></pre><p>To optimize reading performance, you can specify the list of property names to retrieve for each vertex read from the table.</p>
                     <p>The following code creates a property graph <code class="codeph">employeesGraphDAL</code> using the <code class="codeph">OraclePropertyGraph</code> API, and loads two vertices and an edge. Then, it creates a vertex table <code class="codeph">employeNodes</code> using a two-tables schema, and populates it with the data from the vertices in <code class="codeph">employeesGraphDAL</code>. Finally, it reads the vertices out of the vertex table using only the name property.
                     </p><pre class="pre codeblock"><code>// Create employeesGraphDAL
import oracle.pg.rdbms.*;
Oracle oracle = new Oracle(jdbcURL, username, password);
OraclePropertyGraph opgEmployees
                  = OraclePropertyGraph.getInstance(oracle, "employeesGraphDAL");

// Create vertex v1 and assign it properties as key-value pairs
Vertex v1 = opgEmployees.addVertex(1l);
v1.setProperty("age",  Integer.valueOf(31));
v1.setProperty("name", "Alice");
v1.setProperty("address", "Main Street 12");
v1.setProperty("email", "alice@mymail.com");
v1.setProperty("SSN", "123456789");
  
Vertex v2 = opgEmployees.addVertex(2l);
v2.setProperty("age",  Integer.valueOf(27));
v2.setProperty("name", "Bob");
v2.setProperty("adress", "Sesame Street 334"); 
      
// Add edge e1
Edge e1 = opgEmployees.addEdge(1l, v1, v2, "managerOf");
e1.setProperty("weight", 0.5d);

opgEmployees.commit();

// Prepare the vertex table using a Two Tables schema
import oracle.pgx.common.types.PropertyType;
List&lt;String&gt; propertyNames = new ArrayList&lt;String&gt;();
propertyNames.addAll(new String[4]{ "name", "age", "address", "SSN" });

List&lt;PropertyType&gt; = new ArrayList&lt;PropertyType&gt;();
propertyType.add(PropertyType.STRING);
propertyType.add(PropertyType.INTEGER);
propertyType.add(PropertyType.STRING);
propertyType.add(PropertyType.STRING);

Connection conn 
     = opgEmployees.getOracle().clone().getConnection(); /* Clone the connection
                                                            from the property graph 
                                                            instance */    
OraclePropertyGraphUtils.prepareTwoTablesGraphVertexTab(conn /* Connection object */,
                                            pg /* table owner */, 
                                            "employeesNodes" /* vertex table name */, 
                                            propertyNames /* property names */, 
                                            propertyTypes /* property data types */,
                                            "pgts" /* table space */, 
                                            null /* storage options */, 
                                            true /* no logging */);

// Get the vertices from the employeesDAL graph
Iterable&lt;Vertex&gt; vertices = opgEmployees.getVertices();

// Load the vertices into the vertex table using a Two Tables schema
Connection[] conns = new Connection[1]; /* the connection array size defines the
                                           Degree of parallelism (multithreading)
                                        */
conns[1] = conn;
OraclePropertyGraphUtils.writeTwoTablesGraphVertexAndProperties(conn /* Connection 
                                                                        object */,
                                            pg /* table owner */, 
                                            "employeesNodes" /* vertex table name */,  
                                            1000 /* batch size*/, 
                                            new Iterable[] {vertices} /* array of 
                                                                vertex iterables */); 

// Read the vertices (using only name property)
List&lt;String&gt; vPropertyNames = new ArrayList&lt;String&gt;();
vPropertyNames.add("name");
<span class="bold">ResultSet[] rsAr = readTwoTablesGraphVertexAndProperties(conns, 
                                                 "pg" /* table owner */,
                                                 "employeeNodes /* vertex table 
                                                                   name */,  
                                                 vPropertyNames /* list of property 
                                                                   names */,
                                                 1 /* Total Splits*/, 
                                                 0 /* Start Split);

Iterable&lt;Vertex&gt;[] vertices = getVerticesPartitioned(rsAr /* ResultSet array */,
                                                     true /* skip store to cache */,
                                                     null /* vertex filter 
                                                              callback */,
                                                     null /* optimization flag */);
</span>
for (int idx = 0; vertices.length; idx++) {
  Iterator&lt;Vertex&gt; it = vertices[idx].iterator();
  while (it.hasNext()) {
    System.out.println(it.next());
  }
}
</code></pre><p>The preceding code produces output similar to the following:</p><pre class="oac_no_warn" dir="ltr">Vertex ID 1 {name:str:Alice}
Vertex ID 2 {name:str:Bob}
</pre><p>To read a subset of edges from an edge table using a two-tables schema, you can use the API <code class="codeph">OraclePropertyGraphUtils.readTwoTablesGraphEdgeAndProperties</code>. This operation returns an array of <code class="codeph">ResultSet</code> objects with all the rows found in the corresponding splits of the vertex table. Each <code class="codeph">ResultSet</code> object in the array uses one of the connections provided to fetch the vertex rows from the corresponding split. The splits are determined by the specified number of total splits.
                     </p>
                     <p>Similar to what is done for reading vertices, an integer ID (in the range of [0, N - 1]) is assigned to the splits in the vertex table with N splits. The subset of splits queried will consist of those splits with ID value in the range between the start split ID and the start split ID plus the size of the connection array.</p>
                     <p>The following code creates a property graph <code class="codeph">employeesGraphDAL</code> using the <code class="codeph">OraclePropertyGraph</code> API, and loads two vertices and an edge. Then, it creates an edge table <code class="codeph">organizationEdges</code> using a two-tables schema, and populates it with the data from the edges in <code class="codeph">employeesGraphDAL</code>. Finally, it reads the edges out of table using only the name weight.
                     </p><pre class="pre codeblock"><code>       // Create employeesGraphDAL
       import oracle.pg.rdbms.*;
       Oracle oracle = new Oracle(jdbcURL, username, password);
       OraclePropertyGraph opgEmployees
                         = OraclePropertyGraph.getInstance(oracle, "employeesGraphDAL");

       // Create vertex v1 and assign it properties as key-value pairs
       Vertex v1 = opgEmployees.addVertex(1l);
       v1.setProperty("age",  Integer.valueOf(31));
       v1.setProperty("name", "Alice");
       v1.setProperty("address", "Main Street 12");
       v1.setProperty("email", "alice@mymail.com");
       v1.setProperty("SSN", "123456789");
  
       Vertex v2 = opgEmployees.addVertex(2l);
       v2.setProperty("age",  Integer.valueOf(27));
       v2.setProperty("name", "Bob");
       v2.setProperty("adress", "Sesame Street 334"); 

       
       // Add edge e1
       Edge e1 = opgEmployees.addEdge(1l, v1, v2, "managerOf");
       e1.setProperty("weight", 0.5d);

       opgEmployees.commit();

// Prepare the edge table using a Two Tables schema
import oracle.pgx.common.types.PropertyType;
List&lt;String&gt; propertyNames = new ArrayList&lt;String&gt;();
propertyNames.addAll(new String[4]{ "weight" });

List&lt;PropertyType&gt; = new ArrayList&lt;PropertyType&gt;();
propertyType.add(PropertyType.DOUBLE);

       Connection conn 
            = opgEmployees.getOracle().clone().getConnection(); /* Clone the connection
                                                                   from the property graph 
                                                                   instance */    
OraclePropertyGraphUtils.prepareTwoTablesGraphEdgeTab(conn /* Connection object */,
                                            pg /* table owner */, 
                                            "organizationEdges" /* edge table 
                                                                   name */, 
                                            propertyNames /* property names */, 
                                            propertyTypes /* property data types */,
                                            "pgts" /* table space */, 
                                            null /* storage options */, 
                                            true /* no logging */);

// Get the edges from the employeesDAL graph
Iterable&lt;Edge&gt; edges = opgEmployees.getVertices();

// Load the vertices into the vertex table using a Two Tables schema
Connection[] conns = new Connection[1]; /* the connection array size defines the
                                           Degree of parallelism (multithreading)
                                        */
conns[1] = conn;
OraclePropertyGraphUtils.writeTwoTablesGraphEdgeAndProperties(conn /* Connection 
                                                                        object */,
                                            pg /* table owner */, 
                                            organizationEdges" /* edge table name */,  
                                            1000 /* batch size*/, 
                                            new Iterable[] {edges} /* array of 
                                                                edge iterables */); 

// Read the edges (using only weight property)
List&lt;String&gt; ePropertyNames = new ArrayList&lt;String&gt;();
ePropertyNames.add("weight");
<span class="bold">ResultSet[] rsAr = readTwoTablesGraphVertexAndProperties(conns, 
                                                 "pg" /* table owner */,
                                                 "organizationEdges /* edge table 
                                                                   name */,  
                                                 ePropertyNames /* list of property 
                                                                   names */,                                                                                            
                                                 1 /* Total Splits*/, 
                                                 0 /* Start Split);

Iterable&lt;Edge&gt;[] edges = getEdgesPartitioned(rsAr /* ResultSet array */,
                                                     true /* skip store to cache */,
                                                     null /* edge filter 
                                                              callback */,
                                                     null /* optimization flag */);
</span>
for (int idx = 0; edges.length; idx++) {
  Iterator&lt;Edge&gt; it = edges[idx].iterator();
  while (it.hasNext()) {
    System.out.println(it.next());
  }
}
</code></pre><p>The preceding code produces output similar to the following:</p><pre class="oac_no_warn" dir="ltr">Edge ID 1 from Vertex ID 1 {} =[references]=&gt; Vertex ID 2 {} edgeKV[{weight:dbl:0.5}]</pre></div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" name="GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB"></a><h3 id="SPGDG-GUID-7FC09376-F237-41E8-B0FE-9D1044A59FBB" class="sect3"><span class="enumeration_section">2.11 </span>Oracle Flat File Format Definition
               </h3>
               <div>
                  <p>A property graph can be defined in two flat files, specifically description files for the vertices and edges.</p>
                  <p>A property graph can be defined in two flat files, specifically description files for the vertices and edges.</p>
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4">About the Property Graph Description Files</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3">Edge File</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF">Vertex File</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-7323744B-BD8D-4179-91D3-93C92461D92B">Encoding Special Characters</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE">Example Property Graph in Oracle Flat File Format</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B">Converting an Oracle Database Table to an Oracle-Defined Property Graph Flat File</a><br></li>
                     <li class="ulchildlink"><a href="using-property-graphs-oracle-database.html#GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5">Converting CSV Files for Vertices and Edges to Oracle-Defined Property Graph Flat Files</a><br></li>
                  </ul>
               </div>
               
               <div class="props_rev_3"><a id="GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4" name="GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4"></a><h4 id="SPGDG-GUID-2716F004-2C67-489A-87E2-957C5AEAA7D4" class="sect4"><span class="enumeration_section">2.11.1 </span>About the Property Graph Description Files
                  </h4>
                  <div>
                     <p>A pair of files describe a property graph:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">Vertex file</span>: Describes the vertices of the property graph. This file has an <code class="codeph">.opv</code> file name extension.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Edge file</span>: Describes the edges of the property graph. This file has an <code class="codeph">.ope</code> file name extension.
                           </p>
                        </li>
                     </ul>
                     <p>It is recommended that these two files share the same base name. For example, <code class="codeph">simple.opv</code> and <code class="codeph">simple.ope</code> define a property graph. 
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3" name="GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3"></a><h4 id="SPGDG-GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3" class="sect4"><span class="enumeration_section">2.11.2 </span>Edge File
                  </h4>
                  <div>
                     <p>Each line in an edge file is a record that describes an edge of the property graph. A record can describe one key-value property of an edge, thus multiple records are used to describe an edge with multiple properties.</p>
                     <p>A record contains nine fields separated by commas. Each record must contain eight commas to delimit all fields, whether or not they have values:</p>
                     <p><span class="italic">edge_ID, source_vertex_ID, destination_vertex_ID, edge_label, key_name, value_type, value, value, value</span></p>
                     <p>The following table describes the fields composing an edge file record.</p>
                     <div class="tblformal" id="GUID-20FD630A-CE49-44F5-A117-EE1BA5CC5DB3__EDGEFILERECORDFORMAT-112820D6">
                        <p class="titleintable">Table 2-3 Edge File Record Format</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Edge File Record Format" summary="Edge file field descriptions. Columns are Field Number, Name, and Description." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="12%" id="d2789e6669">Field Number</th>
                                 <th align="left" valign="bottom" width="32%" id="d2789e6672">Name</th>
                                 <th align="left" valign="bottom" width="56%" id="d2789e6675">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6680" headers="d2789e6669 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6680 d2789e6672 ">
                                    <p><span class="italic">edge_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6680 d2789e6675 ">
                                    <p>An integer that uniquely identifies the edge</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6691" headers="d2789e6669 ">
                                    <p>2</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6691 d2789e6672 ">
                                    <p><span class="italic">source_vertex_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6691 d2789e6675 ">
                                    <p>The <span class="italic">vertex_ID</span> of the outgoing tail of the edge.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6705" headers="d2789e6669 ">
                                    <p>3</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6705 d2789e6672 ">
                                    <p><span class="italic">destination_vertex_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6705 d2789e6675 ">
                                    <p>The <span class="italic">vertex_ID</span> of the incoming head of the edge.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6719" headers="d2789e6669 ">
                                    <p>4</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6719 d2789e6672 ">
                                    <p><span class="italic">edge_label</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6719 d2789e6675 ">
                                    <p>The encoded label of the edge, which describes the relationship between the two vertices</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6730" headers="d2789e6669 ">
                                    <p>5</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6730 d2789e6672 ">
                                    <p><span class="italic">key_name</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6730 d2789e6675 ">
                                    <p>The encoded name of the key in a key-value pair</p>
                                    <p>If the edge has no properties, then enter a space (<code class="codeph">%20</code>). This example describes edge 100 with no properties:
                                    </p><pre class="oac_no_warn" dir="ltr">100,1,2,likes,%20,,,,</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6748" headers="d2789e6669 ">
                                    <p>6</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6748 d2789e6672 ">
                                    <p><span class="italic">value_type</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6748 d2789e6675 ">
                                    <p>An integer that represents the data type of the value in the key-value pair:</p>
                                    <ul class="simple" style="list-style-type: none;padding-left:0;">
                                       <li><code class="codeph">1</code> String
                                       </li>
                                       <li><code class="codeph">2</code> Integer
                                       </li>
                                       <li><code class="codeph">3</code> Float
                                       </li>
                                       <li><code class="codeph">4</code> Double
                                       </li>
                                       <li><code class="codeph">5</code> Timestamp (date)
                                       </li>
                                       <li><code class="codeph">6</code> Boolean
                                       </li>
                                       <li><code class="codeph">7</code> Long integer
                                       </li>
                                       <li><code class="codeph">8</code> Short integer
                                       </li>
                                       <li><code class="codeph">9</code> Byte
                                       </li>
                                       <li><code class="codeph">10</code> Char
                                       </li>
                                       <li><code class="codeph">20</code> Spatial
                                       </li>
                                       <li><code class="codeph">101</code> Serializable Java object
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6809" headers="d2789e6669 ">
                                    <p>7</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6809 d2789e6672 ">
                                    <p><span class="italic">value</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6809 d2789e6675 ">
                                    <p>The encoded, nonnull value of <span class="italic">key_name</span> when it is neither numeric nor timestamp (date)
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6823" headers="d2789e6669 ">
                                    <p>8</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6823 d2789e6672 ">
                                    <p><span class="italic">value</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6823 d2789e6675 ">
                                    <p>The encoded, nonnull value of <span class="italic">key_name</span> when it is numeric
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d2789e6837" headers="d2789e6669 ">
                                    <p>9</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d2789e6837 d2789e6672 ">
                                    <p><span class="italic">value</span></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d2789e6837 d2789e6675 ">
                                    <p>The encoded, nonnull value of <span class="italic">key_name</span> when it is a timestamp (date)
                                    </p>
                                    <p>Use the Java <code class="codeph">SimpleDateFormat</code> class to identify the format of the date. This example describes the date format of <code class="codeph">2015-03-26Th00:00:00.000-05:00</code>:
                                    </p><pre class="oac_no_warn" dir="ltr">SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX"); encode(sdf.format((java.util.Date) value));</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><span class="bold">Required Grouping of Edges</span>: An edge can have multiple properties, and the edge file includes a record (represented by a single line of text in the flat file) for each combination of an edge ID and a property for that edge. In the edge file, all records for each edge must be grouped together (that is, not have any intervening records for other edges. You can accomplish this any way you want, but a convenient way is to sort the edge file records in ascending (or descending) order by edge ID. (Note, however, an edge file is not required to have all records sorted by edge ID; this is merely one way to achieve the grouping requirement.)
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF" name="GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF"></a><h4 id="SPGDG-GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF" class="sect4"><span class="enumeration_section">2.11.3 </span>Vertex File
                  </h4>
                  <div>
                     <p>Each line in a vertex file is a record that describes a vertex of the property graph. A record can describe one key-value property of a vertex, thus multiple records/lines are used to describe a vertex with multiple properties.</p>
                     <p>A record contains six fields separated by commas. Each record must contain five commas to delimit all fields, whether or not they have values:</p>
                     <p><span class="italic">vertex_ID, key_name, value_type, value, value, value</span></p>
                     <p>The following table describes the fields composing a vertex file record.</p>
                     <div class="tblformal" id="GUID-18026FD1-4EF5-4CE8-A6A2-73A31FE44AFF__VERTEXFILERECORDFORMAT-1127FAA7">
                        <p class="titleintable">Table 2-4 Vertex File Record Format</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Vertex File Record Format" summary="Vertex file field descriptions. Columns are Field Number, Name, and Description." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="13%" id="d2789e6928">Field Number</th>
                                 <th align="left" valign="bottom" width="28%" id="d2789e6931">Name</th>
                                 <th align="left" valign="bottom" width="59%" id="d2789e6934">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d2789e6939" headers="d2789e6928 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d2789e6939 d2789e6931 ">
                                    <p><span class="italic">vertex_ID</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d2789e6939 d2789e6934 ">
                                    <p>An integer that uniquely identifies the vertex</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d2789e6950" headers="d2789e6928 ">
                                    <p>2</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d2789e6950 d2789e6931 ">
                                    <p><span class="italic">key_name</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d2789e6950 d2789e6934 ">
                                    <p>The name of the key in the key-value pair</p>
                                    <p>If the vertex has no properties, then enter a space (<code class="codeph">%20</code>). This example describes vertex 1 with no properties:
                                    </p><pre class="oac_no_warn" dir="ltr">1,%20,,,,</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d2789e6968" headers="d2789e6928 ">
                                    <p>3</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d2789e6968 d2789e6931 ">
                                    <p><span class="italic">value_type</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d2789e6968 d2789e6934 ">
                                    <p>An integer that represents the data type of the value in the key-value pair:</p>
                                    <ul class="simple" style="list-style-type: none;padding-left:0;">
                                       <li><code class="codeph">1</code> String
                                       </li>
                                       <li><code class="codeph">2</code> Integer
                                       </li>
                                       <li><code class="codeph">3</code> Float
                                       </li>
                                       <li><code class="codeph">4</code> Double
                                       </li>
                                       <li><code class="codeph">5</code> Timestamp (date)
                                       </li>
                                       <li><code class="codeph">6</code> Boolean
                                       </li>
                                       <li><code class="codeph">7</code> Long integer
                                       </li>
                                       <li><code class="codeph">8</code> Short integer
                                       </li>
                                       <li><code class="codeph">9</code> Byte
                                       </li>
                                       <li><code class="codeph">10</code> Char
                                       </li>
                                       <li><code class="codeph">20</code> Spatial data, which can be geospatial coordinates, lines, polygons, or Well-Known Text (WKT) literals
                                       </li>
                                       <li><code class="codeph">101</code> Serializable Java object
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d2789e7029" headers="d2789e6928 ">
                                    <p>4</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d2789e7029 d2789e6931 ">
                                    <p><span class="italic">value</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d2789e7029 d2789e6934 ">
                                    <p>The encoded, nonnull value of <span class="italic">key_name</span> when it is neither numeric nor date
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d2789e7043" headers="d2789e6928 ">
                                    <p>5</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d2789e7043 d2789e6931 ">
                                    <p><span class="italic">value</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d2789e7043 d2789e6934 ">
                                    <p>The encoded, nonnull value of <span class="italic">key_name</span> when it is numeric
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d2789e7057" headers="d2789e6928 ">
                                    <p>6</p>
                                 </td>
                                 <td align="left" valign="top" width="28%" headers="d2789e7057 d2789e6931 ">
                                    <p><span class="italic">value</span></p>
                                 </td>
                                 <td align="left" valign="top" width="59%" headers="d2789e7057 d2789e6934 ">
                                    <p>The encoded, nonnull value of <span class="italic">key_name</span> when it is a timestamp (date)
                                    </p>
                                    <p>Use the Java <code class="codeph">SimpleDateFormat</code> class to identify the format of the date. This example describes the date format of <code class="codeph">2015-03-26T00:00:00.000-05:00</code>:
                                    </p><pre class="oac_no_warn" dir="ltr">SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX"); encode(sdf.format((java.util.Date) value));</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><span class="bold">Required Grouping of Vertices</span>: A vertex can have multiple properties, and the vertex file includes a record (represented by a single line of text in the flat file) for each combination of a vertex ID and a property for that vertex. In the vertex file, all records for each vertex must be grouped together (that is, not have any intervening records for other vertices. You can accomplish this any way you want, but a convenient way is to sort the vertex file records in ascending (or descending) order by vertex ID. (Note, however, a vertex file is not required to have all records sorted by vertex ID; this is merely one way to achieve the grouping requirement.)
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-7323744B-BD8D-4179-91D3-93C92461D92B" name="GUID-7323744B-BD8D-4179-91D3-93C92461D92B"></a><h4 id="SPGDG-GUID-7323744B-BD8D-4179-91D3-93C92461D92B" class="sect4"><span class="enumeration_section">2.11.4 </span>Encoding Special Characters
                  </h4>
                  <div>
                     <p>The encoding is UTF-8 for the vertex and edge files. The following table lists the special characters that must be encoded as strings when they appear in a vertex or edge property (key-value pair) or an edge label. No other characters require encoding.</p>
                     <div class="tblformal" id="GUID-7323744B-BD8D-4179-91D3-93C92461D92B__SPECIALCHARACTERCODESINTHEORACLEFLA-11283C25">
                        <p class="titleintable">Table 2-5 Special Character Codes in the Oracle Flat File Format</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Special Character Codes in the Oracle Flat File Format" summary="Special character encoding. Column names are Spacial Character, String Encoding, and Description." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="35%" id="d2789e7141">Special Character</th>
                                 <th align="left" valign="bottom" width="33%" id="d2789e7144">String Encoding</th>
                                 <th align="left" valign="bottom" width="33%" id="d2789e7147">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d2789e7152" headers="d2789e7141 ">
                                    <p><code class="codeph">%</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7152 d2789e7144 ">
                                    <p><code class="codeph">%25</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7152 d2789e7147 ">
                                    <p>Percent</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d2789e7164" headers="d2789e7141 ">
                                    <p><code class="codeph">\t</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7164 d2789e7144 ">
                                    <p><code class="codeph">%09</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7164 d2789e7147 ">
                                    <p>Tab</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d2789e7176" headers="d2789e7141 ">
                                    <p><code class="codeph"> </code> (space)
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7176 d2789e7144 ">
                                    <p><code class="codeph">%20</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7176 d2789e7147 ">
                                    <p>Space</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d2789e7189" headers="d2789e7141 ">
                                    <p><code class="codeph">\n</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7189 d2789e7144 ">
                                    <p><code class="codeph">%0A</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7189 d2789e7147 ">
                                    <p>New line</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d2789e7201" headers="d2789e7141 ">
                                    <p><code class="codeph">\r</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7201 d2789e7144 ">
                                    <p><code class="codeph">%0D</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7201 d2789e7147 ">
                                    <p>Return</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d2789e7213" headers="d2789e7141 ">
                                    <p><code class="codeph">,</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7213 d2789e7144 ">
                                    <p><code class="codeph">%2C</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d2789e7213 d2789e7147 ">
                                    <p>Comma</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE" name="GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE"></a><h4 id="SPGDG-GUID-14C10BAB-3CE4-4D5E-BA09-7C6697F226FE" class="sect4"><span class="enumeration_section">2.11.5 </span>Example Property Graph in Oracle Flat File Format
                  </h4>
                  <div>
                     <p>An example property graph in Oracle flat file format is as follows. In this example, there are two vertices (John and Mary), and a single edge denoting that John is a friend of Mary.</p><pre class="oac_no_warn" dir="ltr">%cat simple.opv
1,age,2,,10,
1,name,1,John,,
2,name,1,Mary,,
2,hobby,1,soccer,,
 
%cat simple.ope
100,1,2,friendOf,%20,,,,</pre></div>
               </div>
               <div class="props_rev_3"><a id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B" name="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B"></a><h4 id="SPGDG-GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B" class="sect4"><span class="enumeration_section">2.11.6 </span>Converting an Oracle Database Table to an Oracle-Defined Property Graph Flat File
                  </h4>
                  <div>
                     <p>You can convert Oracle Database tables that represent the vertices and edges of a graph into an Oracle-defined flat file format (<code class="codeph">.opv</code> and <code class="codeph">.ope</code> file extensions). 
                     </p>
                     <p>If you have graph data stored in Oracle Database tables, you can use Java API methods to convert that data into flat files, and later load the tables into Oracle Database as a property graph. This eliminates the need to take some other manual approach to generating the flat files from existing Oracle Database tables.</p>
                     <div class="section">
                        <p class="subhead3"><span class="bold">Converting a Table Storing Graph Vertices to an .opv File</span></p>
                        <p>You can convert an Oracle Database table that contains entities (that can be represented as vertices of a graph) to a property graph flat file in <code class="codeph">.opv</code> format.
                        </p>
                        <p>For example, assume the following relational table: <code class="codeph">EmployeeTab (empID integer not null, hasName varchar(255), hasAge integer, hasSalary number)</code></p>
                        <p>Assume that this table has the following data:</p><pre class="oac_no_warn" dir="ltr">101, Jean, 20, 120.0
102, Mary, 21, 50.0
103, Jack, 22, 110.0
……
</pre><p>Each employee can be viewed as a vertex in the graph. The vertex ID could be the value of employeeID or an ID generated using some heuristics like hashing. The columns hasName, hasAge, and hasSalary can be viewed as attributes.</p>
                        <p>The Java method <code class="codeph">OraclePropertyGraphUtils.convertRDBMSTable2OP<span class="bold">V</span></code> and its Javadoc information are as follows:
                        </p><pre class="oac_no_warn" dir="ltr">/**
* conn: is an connect instance to the Oracle relational database
* rdbmsTableName: name of the RDBMS table to be converted
* vidColName is the name of an column in RDBMS table to be treated as vertex ID
* lVIDOffset is the offset will be applied to the vertex ID
* ctams defines how to map columns in the RDBMS table to the attributes
* dop degree of parallelism
* dcl an instance of DataConverterListener to report the progress and control the behavior when errors happen 
*/
OraclePropertyGraphUtils.convertRDBMSTable2OPV(
       Connection conn, 
       String rdbmsTableName, 
       String vidColName, 
       long lVIDOffset, 
       ColumnToAttrMapping[] ctams, 
       int dop, 
       OutputStream opvOS, 
       DataConverterListener dcl);
</pre><p>The following code snippet converts this table into an Oracle-defined vertex file (<code class="codeph">.opv</code>):
                        </p><pre class="pre codeblock"><code>// location of the output file
String opv = "./EmployeeTab.opv"; 
OutputStream opvOS = new FileOutputStream(opv);
// an array of ColumnToAttrMapping objects; each object defines how to map a column in the RDBMS table to an attribute of the vertex in an Oracle Property Graph.
ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[3];
// map column "hasName" to attribute "name" of type String
ctams[0] = ColumnToAttrMapping.getInstance("hasName", "name", String.class);
// map column "hasAge" to attribute "age" of type Integer
ctams[1] = ColumnToAttrMapping.getInstance("hasAge", "age", Integer.class);
// map column "hasSalary" to attribute "salary" of type Double
ctams[2] = ColumnToAttrMapping.getInstance("hasSalary", "salary",Double.class);
// convert RDBMS table "EmployeeTab" into opv file "./EmployeeTab.opv", column "empID" is the vertex ID column, offset 1000l will be applied to vertex ID, use ctams to map RDBMS columns to attributes, set DOP to 8
OraclePropertyGraphUtils.convertRDBMSTable2OPV(conn, "EmployeeTab", "empID", 1000l, ctams, 8, opvOS, (DataConverterListener) null);
</code></pre><div class="infoboxnote" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-EFB41B19-4333-4E77-85C4-7C7737E9CD66">
                           <p class="notep1">Note:</p>
                           <p>The lowercase letter "l" as the last character in the offset value <code class="codeph">1000l</code> denotes that the value before it is a long integer.
                           </p>
                        </div>
                        <p>The conversion result is as follows:</p><pre class="oac_no_warn" dir="ltr">1101,name,1,Jean,,
1101,age,2,,20,
1101,salary,4,,120.0,
1102,name,1,Mary,,
1102,age,2,,21,
1102,salary,4,,50.0,
1103,name,1,Jack,,
1103,age,2,,22,
1103,salary,4,,110.0,
</pre><p>In this case, each row in table EmployeeTab is converted to one vertex with three attributes. For example, the row with data "101, Jean, 20, 120.0" is converted to a vertex with ID 1101 with attributes name/"Jean", age/20, salary/120.0. There is an offset between original empID 101 and vertex ID 1101 because an offset 1000l is applied. An offset is useful to avoid collision in ID values of graph elements.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3"><span class="bold">Converting a Table Storing Graph Edges to an .ope File</span></p>
                        <p>You can convert an Oracle Database table that contains entity relationships (that can be represented as edges of a graph) to a property graph flat filein <code class="codeph">.ope</code> format.
                        </p>
                        <p>For example, assume the following relational table: <code class="codeph">EmpRelationTab (relationID integer not null, source integer not null, destination integer not null, relationType varchar(255), startDate date)</code></p>
                        <p>Assume that this table has the following data:</p><pre class="oac_no_warn" dir="ltr">90001, 101, 102, manage, 10-May-2015
90002, 101, 103, manage, 11-Jan-2015
90003, 102, 103, colleague, 11-Jan-2015
……
</pre><p>Each relation (row) can be viewed as an edge in a graph. Specifically, edge ID could be the same as relationID or an ID generated using some heuristics like hashing. The column relationType can be used to define edge labels, and the column startDate can be treated as an edge attribute.</p>
                        <p>The Java method <code class="codeph">OraclePropertyGraphUtils.convertRDBMSTable2OP<span class="bold">E</span></code> and its Javadoc information are as follows:
                        </p><pre class="oac_no_warn" dir="ltr">/**
* conn: is an connect instance to the Oracle relational database
* rdbmsTableName: name of the RDBMS table to be converted
* eidColName is the name of an column in RDBMS table to be treated as edge ID
* lEIDOffset is the offset will be applied to the edge ID
* svidColName is the name of an column in RDBMS table to be treated as source vertex ID of the edge
* dvidColName is the name of an column in RDBMS table to be treated as destination vertex ID of the edge
* lVIDOffset is the offset will be applied to the vertex ID
* bHasEdgeLabelCol a Boolean flag represents if the given RDBMS table has a column for edge labels; if true, use value of column elColName as the edge label; otherwise, use the constant string elColName as the edge label
* elColName is the name of an column in RDBMS table to be treated as edge labels
* ctams defines how to map columns in the RDBMS table to the attributes
* dop degree of parallelism
* dcl an instance of DataConverterListener to report the progress and control the behavior when errors happen 
*/
OraclePropertyGraphUtils.convertRDBMSTable2OPE(
        Connection conn, 
        String rdbmsTableName, 
        String eidColName, 
        long lEIDOffset, 
        String svidColName, 
        String dvidColName, 
        long lVIDOffset, 
        boolean bHasEdgeLabelCol, 
        String elColName, 
        ColumnToAttrMapping[] ctams, 
        int dop, 
        OutputStream opeOS, 
        DataConverterListener dcl);
</pre><p>The following code snippet converts this table into an Oracle-defined edge file (<code class="codeph">.ope</code>):
                        </p><pre class="pre codeblock"><code>// location of the output file
String ope = "./EmpRelationTab.ope"; 
OutputStream opeOS = new FileOutputStream(ope);
// an array of ColumnToAttrMapping objects; each object defines how to map a column in the RDBMS table to an attribute of the edge in an Oracle Property Graph.
ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[1];
// map column "startDate" to attribute "since" of type Date
ctams[0] = ColumnToAttrMapping.getInstance(“startDate", “since",Date.class);
// convert RDBMS table “EmpRelationTab" into ope file “./EmpRelationTab.opv", column “relationID" is the edge ID column, offset 10000l will be applied to edge ID, the source and destination vertices of the edge are defined by columns “source" and “destination", offset 1000l will be applied to vertex ID, the RDBMS table has an column “relationType" to be treated as edge labels, use ctams to map RDBMS columns to edge attributes, set DOP to 8
OraclePropertyGraphUtils.convertRDBMSTable2OPE(conn, “EmpRelationTab", “relationID", 10000l, “source", “destination", 1000l, true, “relationType", ctams, 8, opeOS, (DataConverterListener) null);
</code></pre><div class="infoboxnote" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-29C25198-B41F-4595-9EBB-0045D2DBA5BC">
                           <p class="notep1">Note:</p>
                           <p>The lowercase letter “l" as the last character in the offset value <code class="codeph">10000l</code> denotes that the value before it is a long integer.
                           </p>
                        </div>
                        <p>The conversion result is as follows:</p><pre class="oac_no_warn" dir="ltr">100001,1101,1102,manage,since,5,,,2015-05-10T00:00:00.000-07:00
100002,1101,1103,manage,since,5,,,2015-01-11T00:00:00.000-07:00
100003,1102,1103,colleague,since,5,,,2015-01-11T00:00:00.000-07:00
</pre><p>In this case, each row in table EmpRelationTab is converted to a distinct edge with the attribute <code class="codeph">since</code>. For example, the row with data  “90001, 101, 102, manage, 10-May-2015" is converted to an  edge with ID 100001 linking vertex 1101 to vertex 1102. This edge has attribute since/“2015-05-10T00:00:00.000-07:00". There is an offset between original relationID “90001" and edge ID “100001" because an  offset 10000l is applied. Similarly, an offset 1000l is applied to the source and destination vertex IDs.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5" name="GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5"></a><h4 id="SPGDG-GUID-269EA431-B8C2-45F5-9338-482D4D4E34F5" class="sect4"><span class="enumeration_section">2.11.7 </span>Converting CSV Files for Vertices and Edges to Oracle-Defined Property Graph Flat Files
                  </h4>
                  <div>
                     <p>Some applications use CSV (comma-separated value) format to encode vertices and edges of a graph. In this format, each record of the CSV file represents a single vertex or edge, with all its properties. You can convert a CSV file representing the vertices of a graph to Oracle-defined flat file format definition (<code class="codeph">.opv</code> for vertices, <code class="codeph">.ope</code> for edges). 
                     </p>
                     <p>The CSV file to be converted may include a header line specifying the column name and the type of the attribute that the column represents. If the header includes only the attribute names, then the converter will assume that the data type of the values will be String.</p>
                     <p>The Java APIs to convert CSV to OPV or OPE receive an <code class="codeph">InputStream</code> from which they read the vertices or edges (from CSV), and write them in the <code class="codeph">.opv</code> or <code class="codeph">.ope</code> format to an <code class="codeph">OutputStream</code>. The converter APIs also allow customization of the conversion process.
                     </p>
                     <p>The following subtopics provide instructions for converting vertices and edges:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Vertices: Converting a CSV File to Oracle-Defined Flat File Format (<code class="codeph">.opv</code>)
                           </p>
                        </li>
                        <li>
                           <p>Edges: Converting a CSV File to Oracle-Defined Flat File Format (<code class="codeph">.ope</code>)
                           </p>
                        </li>
                     </ul>
                     <p>The instructions for both are very similar, but with differences specific to vertices and edges.</p>
                     <div class="section">
                        <p class="subhead3"><span class="bold">Vertices: Converting a CSV File to Oracle-Defined Flat File Format (.opv)</span></p>
                        <p>If the CSV file does not include a header, you must specify a ColumnToAttrMapping array describing all the attribute names (mapped to its values data types) in the same order in which they appear in the CSV file. Additionally, the entire columns from the CSV file must be described in the array, including special columns such as the ID for the vertices. If you want to specify the headers for the column in the first line of the same CSV file, then this parameter must be set to null.</p>
                        <p>To convert a CSV file representing vertices, you can use one of the convertCSV2OPV APIs. The simplest of these APIs requires:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>An <code class="codeph">InputStream</code> to read vertices from a CSV file
                              </p>
                           </li>
                           <li>
                              <p>The name of the column that is representing the vertex ID (this column must appear in the CSV file)</p>
                           </li>
                           <li>
                              <p>An integer offset to add to the VID (an offset is useful to avoid collision in ID values of graph elements)</p>
                           </li>
                           <li>
                              <p>A <code class="codeph">ColumnToAttrMapping</code> array (which must be null if the headers are specified in the file)
                              </p>
                           </li>
                           <li>
                              <p>Degree of parallelism (DOP)</p>
                           </li>
                           <li>
                              <p>An integer denoting offset (number of vertex records to skip) before converting </p>
                           </li>
                           <li>
                              <p>An <code class="codeph">OutputStream</code> in which the vertex flat file (.opv) will be written
                              </p>
                           </li>
                           <li>
                              <p>An optional <code class="codeph">DataConverterListener</code> that can be used to keep track of the conversion progress and decide what to do if an error occurs
                              </p>
                           </li>
                        </ul>
                        <p>Additional parameters can be used to specify a different format of the CSV file:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The delimiter character, which is used to separate tokens in a record. The default is the comma character ',’.</p>
                           </li>
                           <li>
                              <p>The quotation character, which is used to quote String values so they can contain special characters, for example, commas. If a quotation character appears in the value of the String itself, it must be escaped either by duplication or by placing a backslash character '\' before it. Some examples are:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>"""Hello, world"", the screen showed…"</p>
                                 </li>
                                 <li>
                                    <p>"But Vader replied: \"No, I am your father.\""</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>The Date format, which will be used to parse the date values. For the CSV conversion, this parameter can be null, but it is recommended to be specified if the CSV has a specific date format. Providing a specific date format helps performance, because that format will be used as the first option when trying to parse date values. Some example date formats are:  </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</p>
                                 </li>
                                 <li>
                                    <p>"MM/dd/yyyy HH:mm:ss"</p>
                                 </li>
                                 <li>
                                    <p>"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"</p>
                                 </li>
                                 <li>
                                    <p>"dddd, dd MMMM yyyy hh:mm:ss"</p>
                                 </li>
                                 <li>
                                    <p>"yyyy-MM-dd"</p>
                                 </li>
                                 <li>
                                    <p>"MM/dd/yyyy"</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>A flag indicating if the CSV file contains String values with new line characters. If this parameter is set to true, all the Strings in the file that contain new lines or quotation characters as values must be quoted.</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>"The first lines of Don Quixote are:""In a village of La Mancha, the name of which I have no desire to call to mind""."</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>The following code fragment shows how to create a&nbsp;<code class="codeph">ColumnToAttrMapping</code> array and use the API to convert a CSV file into an <code class="codeph">.opv</code> file.
                        </p><pre class="pre codeblock"><code>    String inputCSV             = "/path/mygraph-vertices.csv";
    String outputOPV            = "/path/mygraph.opv"; 
    ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[4];
    ctams[0]                    = ColumnToAttrMapping.getInstance("VID",   Long.class);
    ctams[1]                    = ColumnToAttrMapping.getInstance("name",  String.class);
    ctams[2]                    = ColumnToAttrMapping.getInstance("score", Double.class);
    ctams[3]                    = ColumnToAttrMapping.getInstance("age",   Integer.class);
    String vidColumn            = "VID";

    isCSV = new FileInputStream(inputCSV);
    osOPV = new FileOutputStream(new File(outputOPV));
      
    // Convert Vertices
    OraclePropertyGraphUtilsBase.convertCSV2OPV(isCSV, vidColumn, 0, ctams, 1, 0, osOPV, null);
    isOPV.close();
    osOPV.close();
</code></pre><p>In this example, the CSV file to be converted must not include the header and contain four columns (the vertex ID, name, score, and age). An example CVS is as follows:</p><pre class="oac_no_warn" dir="ltr">1,John,4.2,30
2,Mary,4.3,32
3,"Skywalker, Anakin",5.0,46
4,"Darth Vader",5.0,46
5,"Skywalker, Luke",5.0,53
</pre><p>The resulting <code class="codeph">.opv</code> file is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">1,name,1,John,,
1,score,4,,4.2,
1,age,2,,30,
2,name,1,Mary,,
2,score,4,,4.3,
2,age,2,,32,
3,name,1,Skywalker%2C%20Anakin,,
3,score,4,,5.0,
3,age,2,,46,
4,name,1,Darth%20Vader,,
4,score,4,,5.0,
4,age,2,,46,
5,name,1,Skywalker%2C%20Luke,,
5,score,4,,5.0,
5,age,2,,53,
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3"><span class="bold">Edges: Converting a CSV File to Oracle-Defined Flat File Format (.ope)</span></p>
                        <p>If the CSV file does not include a header, you must specify a <code class="codeph">ColumnToAttrMapping</code> array describing all the attribute names (mapped to its values data types) in the same order in which they appear in the CSV file. Additionally, the entire columns from the CSV file must be described in the array, including special columns such as the ID for the edges if it applies, and the START_ID, END_ID, and TYPE, which are required. If you want to specify the headers for the column in the first line of the same CSV file, then this parameter must be set to null.
                        </p>
                        <p>To convert a CSV file representing vertices, you can use one of the <code class="codeph">convertCSV2OPE</code> APIs. The simplest of these APIs requires:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>An <code class="codeph">InputStream</code> to read vertices from a CSV file
                              </p>
                           </li>
                           <li>
                              <p>The name of the column that is representing the edge ID (this is optional in the CSV file; if it is not present, the line number will be used as the ID)</p>
                           </li>
                           <li>
                              <p>An integer offset to add to the EID (an offset is useful to avoid collision in ID values of graph elements)</p>
                           </li>
                           <li>
                              <p>Name of the column that is representing the source vertex ID (this column must appear in the CSV file)</p>
                           </li>
                           <li>
                              <p>Name of the column that is representing the destination vertex ID (this column must appear in the CSV file)</p>
                           </li>
                           <li>
                              <p>Offset to the VID (<code class="codeph">lOffsetVID</code>). This offset will be added on top of the original SVID and DVID values. (A variation of this API takes in two arguments (<code class="codeph">lOffsetSVID</code> and <code class="codeph">lOffsetDVID</code>): one offset for SVID, the other offset for DVID.)
                              </p>
                           </li>
                           <li>
                              <p>A boolean flag indicating if the edge label column is present in the CSV file.</p>
                           </li>
                           <li>
                              <p>Name of the column that is representing the edge label (if this column is not present in the CSV file, then this parameter will be used as a constant for all edge labels) </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">ColumnToAttrMapping</code> array (which must be null if the headers are specified in the file)
                              </p>
                           </li>
                           <li>
                              <p>Degree of parallelism (DOP)</p>
                           </li>
                           <li>
                              <p>An integer denoting offset (number of edge records to skip) before converting </p>
                           </li>
                           <li>
                              <p>An <code class="codeph">OutputStream</code> in which the edge flat file (.ope) will be written
                              </p>
                           </li>
                           <li>
                              <p>An optional <code class="codeph">DataConverterListener</code> that can be used to keep track of the conversion progress and decide what to do if an error occurs.
                              </p>
                           </li>
                        </ul>
                        <p>Additional parameters can be used to specify a different format of the CSV file:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The delimiter character, which is used to separate tokens in a record. The default is the comma character ',’.</p>
                           </li>
                           <li>
                              <p>The quotation character, which is used to quote String values so they can contain special characters, for example, commas. If a quotation character appears in the value of the String itself, it must be escaped either by duplication or by placing a backslash character '\' before it. Some examples are:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>"""Hello, world"", the screen showed…"</p>
                                 </li>
                                 <li>
                                    <p>"But Vader replied: \"No, I am your father.\""</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>The Date format, which will be used to parse the date values. For the CSV conversion, this parameter can be null, but it is recommended to be specified if the CSV has a specific date format. Providing a specific date format helps performance, because that format will be used as the first option when trying to parse date values. Some example date formats are:  </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</p>
                                 </li>
                                 <li>
                                    <p>"MM/dd/yyyy HH:mm:ss"</p>
                                 </li>
                                 <li>
                                    <p>"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"</p>
                                 </li>
                                 <li>
                                    <p>"dddd, dd MMMM yyyy hh:mm:ss"</p>
                                 </li>
                                 <li>
                                    <p>"yyyy-MM-dd"</p>
                                 </li>
                                 <li>
                                    <p>"MM/dd/yyyy"</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>A flag indicating if the CSV file contains String values with new line characters. If this parameter is set to true, all the Strings in the file that contain new lines or quotation characters as values must be quoted.</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>"The first lines of Don Quixote are:""In a village of La Mancha, the name of which I have no desire to call to mind""."</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>The following code fragment shows how to use the API to convert a CSV file into an <code class="codeph">.ope</code> file with a null&nbsp;<code class="codeph">ColumnToAttrMapping</code> array.
                        </p><pre class="pre codeblock"><code>    String inputOPE    = "/path/mygraph-edges.csv";
    String outputOPE   = "/path/mygraph.ope"; 
    String eidColumn   = null;             // null implies that an integer sequence will be used
    String svidColumn  = "START_ID";
    String dvidColumn  = "END_ID";
    boolean hasLabel   = true;
    String labelColumn = "TYPE";

    isOPE = new FileInputStream(inputOPE);
    osOPE = new FileOutputStream(new File(outputOPE));
      
    // Convert Edges
    OraclePropertyGraphUtilsBase.convertCSV2OPE(isOPE, eidColumn, 0, svidColumn, dvidColumn, hasLabel, labelColumn, null, 1, 0, osOPE, null);
</code></pre><p>An input CSV that uses the former example to be converted should include the header specifying the columns name and their type. An example CSV file is as follows.</p><pre class="oac_no_warn" dir="ltr">START_ID:long,weight:float,END_ID:long,:TYPE
1,1.0,2,loves
1,1.0,5,admires
2,0.9,1,loves
1,0.5,3,likes
2,0.0,4,likes
4,1.0,5,is the dad of
3,1.0,4,turns to
5,1.0,3,saves from the dark side
</pre><p>The resulting .ope file is as follows.</p><pre class="oac_no_warn" dir="ltr">1,1,2,loves,weight,3,,1.0,
2,1,5,admires,weight,3,,1.0,
3,2,1,loves,weight,3,,0.9,
4,1,3,likes,weight,3,,0.5,
5,2,4,likes,weight,3,,0.0,
6,4,5,is%20the%20dad%20of,weight,3,,1.0,
7,3,4,turns%20to,weight,3,,1.0,
8,5,3,saves%20from%20the%20dark%20side,weight,3,,1.0,
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD" name="GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD"></a><h3 id="SPGDG-GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD" class="sect3"><span class="enumeration_section">2.12 </span>Example Python User Interface
               </h3>
               <div>
                  <p>The example Python scripts in <code class="codeph">$ORACLE_HOME/md/property_graph/pyopg/</code> can used with Oracle Spatial and Graph Property Graph, and you may want to change and enhance them (or copies of them) to suit your needs.
                  </p>
                  <div class="infoboxnote" id="GUID-1946BFA3-8995-4EE5-8E39-FE1C58391EAD__GUID-88F50BD3-C9B6-4F8C-B646-0A2CAB6365B2">
                     <p class="notep1">Note:</p>
                     <p>Names do not appear in the vertex or edge files, but are provided here to simplify field references.</p>
                  </div>
                  <p>To invoke the user interface to run the examples, use the script <code class="codeph">pyopg.sh</code>.
                  </p>
                  <p>The examples include the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Example 1: Connect to an Oracle database and perform a simple check of the number of vertices and edges. To run it:</p><pre class="oac_no_warn" dir="ltr">sh ./pyopg.sh
 
connectRDBMS("connections", "jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger");print "vertices", countV()
print "edges", countE()
</pre><p>In the preceding example, <code class="codeph">mygraph</code> is the name of the graph stored in the Oracle database, and the remaining arguments are the connection information to access the Oracle database. They must be customized for your environment.
                        </p>
                     </li>
                     <li>
                        <p>Example 2: Connect to an Oracle database and run a few analytical functions. To run it:</p><pre class="oac_no_warn" dir="ltr">connectRDBMS("connections", "jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger");
print "vertices", countV()
print "edges", countE()

import pprint

analyzer = analyst()
print "# triangles in the graph", analyzer.countTriangles()

graph_communities = [{"commid":i.getName(),"size":i.size()} for i in analyzer.communities().iterator()]

import pandas as pd
import numpy as np

community_frame = pd.DataFrame(graph_communities)
community_frame[:5]

import matplotlib as mpl
import matplotlib.pyplot as plt

fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(16,12));
community_frame["size"].plot(kind="bar", title="Communities and Sizes")
ax.set_xticklabels(community_frame.index);
plt.show()
</pre><p>The preceding example connects to an Oracle database, prints basic information about the vertices and edges, get an in memory analyst, computes the number of triangles, performs community detection, and finally plots out in a bar chart communities and their sizes.</p>
                     </li>
                  </ul>
                  <p>For detailed information about this example Python interface, see the following directory under the installation home:</p><pre class="oac_no_warn" dir="ltr">$ORACLE_HOME/md/property_graph/pyopg/doc/</pre></div>
            </div>
         </div>
      </article>
   </body>
</html>