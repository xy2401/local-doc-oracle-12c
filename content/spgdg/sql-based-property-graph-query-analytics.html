<!DOCTYPE html
  SYSTEM "about:legacy-compat">

<!-- saved from url=(0023)https://docs.oracle.com -->

<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can use SQL to query property graph data in Oracle Spatial and Graph.">
      <meta name="description" content="You can use SQL to query property graph data in Oracle Spatial and Graph.">
      <title>SQL-Based Property Graph Query and Analytics</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Property Graph Developer’s Guide">
      <meta property="og:description" content="You can use SQL to query property graph data in Oracle Spatial and Graph.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Property Graph Developer’s Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 17.8.1">
      <link rel="alternate" href="spatial-and-graph-property-graph-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2017-10-11T16:07:51-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2017">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E85870-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/12.2">
      <meta name="dcterms.release" content="Release 12.2">
      <link rel="prev" href="using-inmemory-analyst-oracle-database.html" title="Previous" type="text/html">
      <link rel="next" href="OPG_APIS-reference.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">
            {
                "primary":
                {
                    "category":{
                      "short_name":"database",
                      "element_name":"Database",
                      "display_in_url":true
                    },
                    "suite":{
                      "short_name":"oracle",
                      "element_name":"Oracle",
                      "display_in_url":true
                    },
                    "product_group":{
                      "short_name":"not-applicable",
                      "element_name":"Not applicable",
                      "display_in_url":false
                    },
                    "product":{
                      "short_name":"oracle-database",
                      "element_name":"Oracle Database",
                      "display_in_url":true
                    },
                    "release":{
                      "short_name":"12.2",
                      "element_name":"Release 12.2",
                      "display_in_url":true
                    },
                    "platform":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    },
                    "component":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    }
                }
            }
            </script>
      
    <meta name="dcterms.title" content="Spatial and Graph Property Graph Developer's Guide">
    <meta name="dcterms.isVersionOf" content="SPGDG">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-inmemory-analyst-oracle-database.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="OPG_APIS-reference.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Property Graph Developer’s Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL-Based Property Graph Query and Analytics</li>
            </ol>
            <a id="GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" name="GUID-C5CC6650-0375-4F32-8317-BAF859C1909C"></a>
            
            <h2 id="SPGDG-GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" class="sect2"><span class="enumeration_chapter">4 </span>SQL-Based Property Graph Query and Analytics
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>You can use SQL to query property graph data in Oracle Spatial and Graph.</p>
               <p>For the property graph support in Oracle Spatial and Graph, all the vertices and edges data are persisted in relational form in Oracle Database. For detailed information about the Oracle Spatial and Graph property graph schema objects, see <a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" title="The property graph PL/SQL and Java APIs use special Oracle Database schema objects.">Property Graph Schema Objects for Oracle Database</a>.
               </p>
               <p>This chapter provides examples of typical graph queries implemented using SQL. The audience includes DBAs as well as application developers who understand SQL syntax and property graph schema objects.</p>
               <p>The benefits of querying directly property graph using SQL include:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>There is no need to bring data outside Oracle Database.</p>
                  </li>
               </ul>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>You can leverage the industry-proven SQL engine provided by Oracle Database.</p>
                  </li>
               </ul>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>You can easily join or integrate property graph data with other data types (relational, JSON, XML, and so on).</p>
                  </li>
               </ul>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>You can take advantage of existing Oracle SQL tuning and database management tools and user interface.</p>
                  </li>
               </ul>
               <p>The examples assume that there is a property graph named <code class="codeph"><span class="bold">connections</span></code> in the current schema. The SQL queries and example output are for illustration purpose only, and your output may be different depending on the data in your <code class="codeph">connections</code> graph. In some examples, the output is reformatted for readability.
               </p>
            </div>
            <div>
               <p><strong>Topics:</strong></p>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-DA3E5ADB-5851-4686-8418-EFF473794846">Simple Property Graph Queries</a><br>The examples in this topic query vertices, edges, and properties of the graph.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734">Text Queries on Property Graphs</a><br>If values of a property (vertex property or edge property) contain free text, then it might help performance to create an Oracle Text index on the V column.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA">Navigation and Graph Pattern Matching</a><br>A key benefit of using a graph data model is that you can easily navigate across entities (people, movies, products, services, events, and so on) that are modeled as vertices, following links and relationships modeled as edges. In addition, graph matching templates can be defined to do such things as detect patterns, aggregate individuals, and analyze trends.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09">Navigation Options: CONNECT BY and Parallel Recursion</a><br>The CONNECT BY clause and parallel recursion provide options for advanced navigation and querying.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734">Pivot</a><br>The PIVOT clause lets you dynamically add columns to a table to create a new table.
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6">SQL-Based Property Graph Analytics</a><br>In addition to the analytical functions offered by the in-memory analyst, the property graph feature in Oracle Spatial and Graph supports several native, SQL-based property graph analytics.
                  </li>
               </ul>
            </div>
            
            <div class="props_rev_3"><a id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846" name="GUID-DA3E5ADB-5851-4686-8418-EFF473794846"></a><h3 id="SPGDG-GUID-DA3E5ADB-5851-4686-8418-EFF473794846" class="sect3"><span class="enumeration_section">4.1 </span>Simple Property Graph Queries
               </h3>
               <div>
                  <p>The examples in this topic query vertices, edges, and properties of the graph.</p>
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDAVERTEXWITHASPECIFIEDVERTEXID-0857F724">
                     <p class="titleinexample">Example 4-1 Find a Vertex with a Specified Vertex ID</p>
                     <p>This example find the vertex with vertex ID 1 in the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select vid, k, v, vn, vt 
      from connectionsVT$ 
      where vid=1;
</code></pre><p>The output might be as follows:</p><pre class="oac_no_warn" dir="ltr">     1 country     United States
     1 name        Barack Obama
     1 occupation  44th president of United States of America
     ...
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDANEDGEWITHASPECIFIEDEDGEID-0857FB2C">
                     <p class="titleinexample">Example 4-2 Find an Edge with a Specified Edge ID</p>
                     <p>This example find the edge with edge ID 100 in the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select eid,svid,dvid,k,t,v,vn,vt 
      from connectionsGE$ 
      where eid=1000;
</code></pre><p>The output might be as follows:</p><pre class="oac_no_warn" dir="ltr">    1000  1 2 weight  3  1  1 </pre><p>In the preceding output, the K of the edge property is "weight" and the type ID of the value is 3, indicating a float value.</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__PERFORMSIMPLECOUNTING-085800A7">
                     <p class="titleinexample">Example 4-3 Perform Simple Counting</p>
                     <p>This example performs simple counting in the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; -- Get the total number of K/V pairs of all the vertices
SQL&gt; select /*+ parallel */ count(1) 
       from connectionsVT$;

    299

SQL&gt; -- Get the total number of K/V pairs of all the edges
SQL&gt; select /*+ parallel(8) */ count(1) 
       from connectionsGE$;
    164

SQL&gt; -- Get the total number of vertices
SQL&gt; select /*+ parallel */ count(distinct vid) 
       from connectionsVT$;

    78

SQL&gt; -- Get the total number of edges
SQL&gt; select /*+ parallel */ count(distinct eid) 
       from connectionsGE$;

    164
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__GETTHESETOFPROPERTYKEYSUSED-0858058D">
                     <p class="titleinexample">Example 4-4 Get the Set of Property Keys Used</p>
                     <p>This example gets the set of property keys used for the vertices n the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select /*+ parallel */ distinct k 
      from connectionsVT$;

company
show
occupation
type
team
religion
criminal charge
music genre
genre
name
role
political party
country

13 rows selected.

SQL&gt; -- get the set of property keys used for edges
SQL&gt; select /*+ parallel */ distinct k 
       from connectionsGE$;

weight
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDVERTICESWITHAVALUE-085809A2">
                     <p class="titleinexample">Example 4-5 Find Vertices with a Value</p>
                     <p>This example finds vertices with a value (of any property) that is of String type, and where and the value contains two adjacent occurrences of a, e, i, o, or u, regardless of case.n the <code class="codeph">connections</code> graph.
                     </p><pre class="pre codeblock"><code>SQL&gt; select vid, t, k, v 
       from connectionsVT$ 
      where t=1 
        and regexp_like(v, '([aeiou])\1', 'i');

     6        1  name  Jordan Peele 
     6        1  show  Key and Peele
    54        1  name  John Green
        ...
</code></pre><p>It is usually hard to leverage a B-Tree index for the preceding kind of query because it is difficult to know beforehand what kind of regular expression is going to be used. For the above query, you might get the following execution plan. Note that full table scan is chosen by the optimizer.</p><pre class="oac_no_warn" dir="ltr">------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation            | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |                |    15 |   795 |    28    (0)| 00:00:01 |       |       |        |      |           |
|   1 |  PX COORDINATOR      |                |       |       |             |          |       |       |        |      |           |
|   2 |   PX SEND QC (RANDOM)| :TQ10000       |    15 |   795 |    28    (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND) |
|   3 |    PX BLOCK ITERATOR |                |    15 |   795 |    28    (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |           |
|*  4 |     <span class="bold">TABLE ACCESS FULL</span>| CONNECTIONSVT$ |    15 |   795 |    28    (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |           |
------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - filter(INTERNAL_FUNCTION("V") AND  REGEXP_LIKE ("V",U'([aeiou])\005C1','i') AND "T"=1 AND INTERNAL_FUNCTION("K"))
Note
-----
   - Degree of Parallelism is 2 because of table property
</pre><p>If the Oracle Database In-Memory option is available and memory is sufficient, it can help performance to place the table (full table or a set of relevant columns) in memory. One way to achieve that is as follows:</p><pre class="pre codeblock"><code>SQL&gt; alter table connectionsVT$ inmemory;
Table altered.
</code></pre><p>Now, entering the same SQL containing the regular expression shows a plan that performs a "TABLE ACCESS INMEMORY FULL".</p><pre class="oac_no_warn" dir="ltr">--------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                     | Name           | Rows  | Bytes | Cost (%CPU)  | Time     | Pstart| Pstop |    TQ    |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |                |    15 |   795 |    28     (0)| 00:00:01 |       |       |        |      |            |
|   1 |  PX COORDINATOR               |                |       |       |              |          |       |       |        |      |            |
|   2 |   PX SEND QC (RANDOM)         | :TQ10000       |    15 |   795 |    28     (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   3 |    PX BLOCK ITERATOR          |                |    15 |   795 |    28     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |            |
|*  4 |     <span class="bold">TABLE ACCESS INMEMORY FULL</span>| CONNECTIONSVT$ |    15 |   795 |    28     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |            |
---------------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - filter(INTERNAL_FUNCTION("V") AND  REGEXP_LIKE ("V",U'([aeiou])\005C1','i') AND "T"=1 AND INTERNAL_FUNCTION("K"))
Note
-----
   - Degree of Parallelism is 2 because of table property
</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" name="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734"></a><h3 id="SPGDG-GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" class="sect3"><span class="enumeration_section">4.2 </span>Text Queries on Property Graphs
               </h3>
               <div>
                  <p>If values of a property (vertex property or edge property) contain free text, then it might help performance to create an Oracle Text index on the V column.</p>
                  <p>Oracle Text can process text that is directly stored in the database.&nbsp;The text can be short strings (such as names or addresses), or it can be full-length documents.&nbsp;These documents can be in a variety of textual format.</p>
                  <p>The text can also be in many different languages. Oracle Text can handle any space-separated languages (including character sets such as Greek or Cyrillic). In addition, Oracle Text is able to handle the Chinese, Japanese and Korean pictographic languages)</p>
                  <p>Because the property graph feature uses NVARCHAR typed column for better support of Unicode, it is <span class="bold"><span class="italic">highly recommended</span></span> that UTF8 (AL32UTF8) be used as the database character set.
                  </p>
                  <p>To create an Oracle Text index on the vertices table (or edges table),&nbsp;the ALTER SESSION privilege is required. For example:</p><pre class="pre codeblock"><code>SQL&gt; grant alter session to &lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>If customization is required, also grant the EXECUTE privilege on CTX_DDL:</p><pre class="pre codeblock"><code>SQL&gt; grant execute on ctx_ddl to &lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>The following shows some example statements for granting these privileges to SCOTT.</p><pre class="pre codeblock"><code>SQL&gt; conn / as sysdba
Connected.
SQL&gt; -- This is a PDB setup -- 
SQL&gt; alter session set container=orcl;
Session altered.

SQL&gt; grant execute on ctx_ddl to scott;
Grant succeeded.

SQL&gt; grant alter session to scott;
Grant succeeded.
</code></pre><div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-66A640E6-CE39-4297-BED9-0C4D05C028C2">
                     <p class="titleinexample">Example 4-6 <span class="bold">Create a Text Index</span></p>
                     <p>This example creates an Oracle Text index on the vertices table (V column) of the connections graph in the SCOTT schema. Note that unlike the text index capabilities provided by either Apache Lucene or Apache SolrCloud, the Oracle Text index created here is for <span class="bold"><span class="italic">all </span></span> property keys, not just one or a subset of property keys. In addition, if a new property is added to the graph and the property value is of String data type, then it will automatically be included in the same text index.
                     </p>
                     <p>The example uses the OPG_AUTO_LEXER lexer owned by MDSYS.</p><pre class="pre codeblock"><code>SQL&gt; execute opg_apis.create_vertices_text_idx('scott', 'connections', pref_owner=&gt;'MDSYS', lexer=&gt;'OPG_AUTO_LEXER', dop=&gt;2);</code></pre><p>If customization is desired, you can use the ctx_ddl.create_preference API. For example:</p><pre class="pre codeblock"><code>SQL&gt; -- The following requires access privilege to CTX_DDL
SQL&gt; exec ctx_ddl.create_preference('SCOTT.OPG_AUTO_LEXER', 'AUTO_LEXER');

PL/SQL procedure successfully completed.

SQL&gt; execute opg_apis.create_vertices_text_idx('scott', 'connections', pref_owner=&gt;'scott', lexer=&gt;'OPG_AUTO_LEXER', dop=&gt;2);

PL/SQL procedure successfully completed.
</code></pre><p>You can now use a rich set of functions provided  by Oracle Text to perform queries against graph elements.</p>
                     <div class="infoboxnote" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-0E694C49-E268-441E-B753-B5284CD9B1D1">
                        <p class="notep1">Note:</p>
                        <p>If you no longer need an Oracle Text index, you can use the drop_vertices_text_idx or opg_apis.drop_edges_text_idx API to drop it. The following statements drop the text indexes on the vertices and edges of a graph named <code class="codeph">connections</code> owned by SCOTT:
                        </p><pre class="pre codeblock"><code>SQL&gt; exec opg_apis.drop_vertices_text_Idx('scott', 'connections');
SQL&gt; exec opg_apis.drop_edges_text_Idx('scott', 'connections');</code></pre></div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-7359CE86-2325-4159-9CBE-9D0B5B5F2405">
                     <p class="titleinexample">Example 4-7 Find a Vertex that Has a Property Value</p>
                     <p>The following example find a vertex that has a property value (of string type) containing the keyword "Obama".</p><pre class="pre codeblock"><code>SQL&gt; select vid, k, t, v 
       from connectionsVT$ 
      where t=1 
        and contains(v, 'Obama', 1) &gt; 0 
      order by score(1) desc
      ;
</code></pre><p>The output and SQL execution plan from the preceding statement may appear as follows. Note that DOMAIN INDEX appears as an operation in the execution plan.</p><pre class="oac_no_warn" dir="ltr">     1  name    1  Barack Obama

Execution Plan
----------------------------------------------------------
Plan hash value: 1619508090

-----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name            | Rows  | Bytes | Cost (%CPU) | Time     | Pstart| Pstop |
-----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                 |     1 |    56 |     5  (20) | 00:00:01 |       |       |
|   1 |  SORT ORDER BY                      |                 |     1 |    56 |     5  (20) | 00:00:01 |       |       |
|*  2 |   TABLE ACCESS BY GLOBAL INDEX ROWID| CONNECTIONSVT$  |     1 |    56 |     4    (0)| 00:00:01 | ROWID | ROWID |
|*  3 |    <span class="bold">DOMAIN INDEX</span>                     | CONNECTIONSXTV$ |       |       |     4    (0)| 00:00:01 |       |       |
-----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("T"=1 AND INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
   3 - access("CTXSYS"."CONTAINS"("V",'Obama',1)&gt;0)
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-7982C91F-7911-43D3-A2E5-39D5428082D5">
                     <p class="titleinexample">Example 4-8 Fuzzy Match</p>
                     <p>The following example finds a vertex that has a property value (of string type) containing variants of "ameriian" (a deliberate misspelling for this example) Fuzzy match is used.</p><pre class="pre codeblock"><code>SQL&gt; select vid, k, t, v 
       from connectionsVT$ 
      where contains(v, <span class="bold">'fuzzy</span>(ameriian,,,weight)', 1) &gt; 0 
      order by score(1) desc;
</code></pre><p>The output and SQL execution plan from the preceding statement may appear as follows.</p><pre class="oac_no_warn" dir="ltr">     8 role      1  american business man
     9 role      1  american business man
     4 role      1  american economist
     6 role      1  american comedian actor
     7 role      1  american comedian actor
     1 occupation 1 44th president of United States of America

6 rows selected.

Execution Plan
----------------------------------------------------------
Plan hash value: 1619508090

-----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
-----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                 |     1 |    56 |     5  (20)| 00:00:01 |       |       |
|   1 |  SORT ORDER BY                      |                 |     1 |    56 |     5  (20)| 00:00:01 |       |       |
|*  2 |   TABLE ACCESS BY GLOBAL INDEX ROWID| CONNECTIONSVT$  |     1 |    56 |     4   (0)| 00:00:01 | ROWID | ROWID |
|*  3 |    DOMAIN INDEX                     | CONNECTIONSXTV$ |       |       |     4   (0)| 00:00:01 |       |       |
-----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter(INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-80227A76-367F-4735-A49A-94D8C45D704E">
                     <p class="titleinexample">Example 4-9 Query Relaxation</p>
                     <p>The following example is a sophisticated Oracle Text query that implements <span class="bold">query relaxation</span>, which enables you to execute the most restrictive version of a query first, progressively relaxing the query until the required number of matches is obtained. Using query relaxation with queries that contain multiple strings, you can provide guidance for determining the “best” matches, so that these appear earlier in the results than other potential matches.
                     </p>
                     <p>This example searchs for "american actor" with a query relaxation sequence.</p><pre class="pre codeblock"><code>SQL&gt; select vid, k, t, v  
       from connectionsVT$ 
      where <span class="bold">CONTAINS</span> (v,
 '&lt;query&gt;
   &lt;textquery lang="ENGLISH" grammar="CONTEXT"&gt;
<span class="bold">     &lt;progression&gt;
       &lt;seq&gt;{american} {actor}&lt;/seq&gt;
       &lt;seq&gt;{american} NEAR {actor}&lt;/seq&gt;
       &lt;seq&gt;{american} AND {actor}&lt;/seq&gt;
       &lt;seq&gt;{american} ACCUM {actor}&lt;/seq&gt;
     &lt;/progression&gt;
   &lt;/textquery&gt;</span>
   &lt;score datatype="INTEGER" algorithm="COUNT"/&gt;
  &lt;/query&gt;') &gt; 0;
</code></pre><p>The output and SQL execution plan from the preceding statement may appear as follows.</p><pre class="oac_no_warn" dir="ltr">     7 role       1 american comedian actor
     6 role       1 american comedian actor
    44 occupation 1 actor
     8 role       1 american business man
    53 occupation 1 actor film producer
    52 occupation 1 actor
     4 role       1 american economist
    47 occupation 1 actor
     9 role       1 american business man

9 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 2158361449

----------------------------------------------------------------------------------------------------------------------
| Id  | Operation                          | Name         | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
----------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                   |                 |       1 |      56 |       4   (0)| 00:00:01 |         |         |
|*  1 |  TABLE ACCESS BY GLOBAL INDEX ROWID| CONNECTIONSVT$  |       1 |      56 |       4   (0)| 00:00:01 | ROWID | ROWID |
|*  2 |   DOMAIN INDEX                     | CONNECTIONSXTV$ |         |         |       4   (0)| 00:00:01 |         |         |
----------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter(INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
   2 - access("CTXSYS"."CONTAINS"("V",'&lt;query&gt;      &lt;textquery lang="ENGLISH" grammar="CONTEXT"&gt;
          &lt;progression&gt;       &lt;seq&gt;{american} {actor}&lt;/seq&gt;    &lt;seq&gt;{american} NEAR {actor}&lt;/seq&gt;
          &lt;seq&gt;{american} AND {actor}&lt;/seq&gt;        &lt;seq&gt;{american} ACCUM {actor}&lt;/seq&gt;    &lt;/progression&gt;
          &lt;/textquery&gt;    &lt;score datatype="INTEGER" algorithm="COUNT"/&gt; &lt;/query&gt;')&gt;0)
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-901379A5-6980-47A3-B55A-15B29B3E5344">
                     <p class="titleinexample">Example 4-10 Find an Edge</p>
                     <p>Just as with vertices, you can create an Oracle Text index on the V column of the edges table (GE$) of a property graph. The following example uses the OPG_AUTO_LEXER lexer owned by MDSYS.</p><pre class="pre codeblock"><code>SQL&gt; exec opg_apis.create_edges_text_idx('scott', 'connections', pref_owner=&gt;'mdsys', lexer=&gt;'OPG_AUTO_LEXER', dop=&gt;4);</code></pre><p>If customization is required, use the ctx_ddl.create_preference API.</p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA" name="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA"></a><h3 id="SPGDG-GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA" class="sect3"><span class="enumeration_section">4.3 </span>Navigation and Graph Pattern Matching
               </h3>
               <div>
                  <p>A key benefit of using a graph data model is that you can easily navigate across entities (people, movies, products, services, events, and so on) that are modeled as vertices, following links and relationships modeled as edges. In addition, graph matching templates can be defined to do such things as detect patterns, aggregate individuals, and analyze trends.</p>
                  <p>This topic provides graph navigation and pattern matching examples using the example property graph named connections. Most of the SQL statements are relatively simple, but they can be used as building blocks to implement requirements that are more sophisticated. It is generally best to start from something simple, and progressively add complexity.</p>
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__WHOAREAPERSONSCOLLABORATORS-3728428C">
                     <p class="titleinexample">Example 4-11 Who Are a Person's Collaborators?</p>
                     <p>The following SQL ststement finds all entities that a vertex with ID 1 collaborates with. For simplicity, it considers <span class="bold">only </span>outgoing relationships.
                     </p><pre class="pre codeblock"><code>SQL&gt; select dvid, el, k, vn, v 
       from connectionsGE$ 
      where svid=1 
        and el='collaborates';
</code></pre><div class="infoboxnote" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-E9C22EA0-FA62-4D83-9F63-2A5C9565F5B7">
                        <p class="notep1">Note:</p>
                        <p>To find the specific vertex ID of interest, you can perform a text query on the property graph using keywords or fuzzy matching. (For details and examples, see <a href="sql-based-property-graph-query-analytics.html#GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" title="If values of a property (vertex property or edge property) contain free text, then it might help performance to create an Oracle Text index on the V column.">Text Queries on Property Graphs</a>.)
                        </p>
                     </div>
                     <p>The preceding example's output and execution plan may be as follows.</p><pre class="oac_no_warn" dir="ltr">     2 collaborates weight 1 1
    21 collaborates weight 1 1
    22 collaborates weight 1 1
      ....
    26 collaborates weight 1 1


10 rows selected.


-------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                    | Name            | Rows  | Bytes | Cost (%CPU)| Time      | Pstart| Pstop |    TQ    |IN-OUT| PQ Distrib |
-------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                             |                 |    10 |   460 |     2     (0)| 00:00:01 |       |       |        |      |        |
|   1 |  PX COORDINATOR                              |                 |       |       |              |          |       |       |        |      |        |
|   2 |   PX SEND QC (RANDOM)                        | :TQ10000        |    10 |   460 |     2     (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   3 |    PX PARTITION HASH ALL                     |                 |    10 |   460 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |        |
|*  4 |     TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| CONNECTIONSGE$  |    10 |   460 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
|*  5 |      INDEX RANGE SCAN                        | CONNECTIONSXSE$ |    20 |       |     1     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
-------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'collaborates' AND INTERNAL_FUNCTION("K") AND INTERNAL_FUNCTION("V"))
   5 - access("SVID"=1)
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-78270F51-B255-4B34-BEBB-FB231FC2094F">
                     <p class="titleinexample">Example 4-12 Who Are a Person's Collaborators and What are Their Occupations?</p>
                     <p>The following SQL statement finds collaborators of the vertex with ID 1, and the occupation of each collaborator. A join with the vertices table (VT$) is required.</p><pre class="pre codeblock"><code>SQL&gt; select dvid, vertices.v 
       from connectionsGE$, connectionsVT$ vertices 
      where svid=1 
        and el='collaborates' 
        and dvid=vertices.vid 
        and vertices.k='occupation';
</code></pre><p>The preceding example's output and execution plan may be as follows.</p><pre class="oac_no_warn" dir="ltr">    21  67th United States Secretary of State
    22  68th United States Secretary of State
    23  chancellor
    28  7th president of Iran
    19  junior United States Senator from New York
...


--------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                     | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
--------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                              |                 |     7 |   525 |     7   (0)| 00:00:01 |       |       |     |    |         |
|   1 |  PX COORDINATOR                               |                 |       |       |            |          |       |       |     |    |         |
|   2 |   PX SEND QC (RANDOM)                         | :TQ10000        |     7 |   525 |     7   (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   3 |    NESTED LOOPS                               |                 |     7 |   525 |     7   (0)| 00:00:01 |       |       |  Q1,00 | PCWP |         |
|   4 |     PX PARTITION HASH ALL                     |                 |    10 |   250 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |         |
|*  5 |      TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| CONNECTIONSGE$  |    10 |   250 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |         |
|*  6 |       INDEX RANGE SCAN                        | CONNECTIONSXSE$ |    20 |       |     1   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |         |
|   7 |     PARTITION HASH ITERATOR                   |                 |     1 |       |     0   (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |         |
|*  8 |      TABLE ACCESS BY LOCAL INDEX ROWID        | CONNECTIONSVT$  |       |       |            |          |   KEY |   KEY |  Q1,00 | PCWP |         |
|*  9 |       INDEX UNIQUE SCAN                       | CONNECTIONSXQV$ |     1 |       |     0   (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |         |
--------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'collaborates')
   6 - access("SVID"=1)
   8 - filter(INTERNAL_FUNCTION("VERTICES"."V"))
   9 - access("DVID"="VERTICES"."VID" AND "VERTICES"."K"=U'occupation')
       filter(INTERNAL_FUNCTION("VERTICES"."K"))
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-BAEE2D4E-8A3E-44E9-B715-98F3A5C10894">
                     <p class="titleinexample">Example 4-13 Find a Person's Enemies and Aggregate Them by Their Country</p>
                     <p>The following SQL statement finds enemies (that is, those with the <code class="codeph">feuds</code> relationship) of the vertex with ID 1, and aggregates them by their countries. A join with the vertices table (VT$) is required.
                     </p><pre class="pre codeblock"><code>SQL&gt;   select vertices.v, count(1) 
         from connectionsGE$, connectionsVT$ vertices 
        where svid=1 
          and el='feuds'  
          and dvid=vertices.vid 
          and vertices.k='country' 
     group by vertices.v;
</code></pre><p>The example's output and execution plan may be as follows. In this case, the vertex with ID 1 has 3 enemies in the United States and 1 in Russia.</p><pre class="oac_no_warn" dir="ltr">United States      3
Russia             1


------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                     | Name            | Rows   | Bytes  | Cost (%CPU)| Time      | Pstart| Pstop |     TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                              |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |        |      |         |
|   1 |  PX COORDINATOR                               |                 |        |        |             |          |        |        |        |      |         |
|   2 |   PX SEND QC (RANDOM)                         | :TQ10001        |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,01 | P-&gt;S | QC (RAND)  |
|   3 |    HASH GROUP BY                              |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,01 | PCWP |         |
|   4 |     PX RECEIVE                                |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,01 | PCWP |         |
|   5 |      PX SEND HASH                             | :TQ10000        |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,00 | P-&gt;P | HASH     |
|   6 |       HASH GROUP BY                           |                 |      5 |    375 |      5  (20)| 00:00:01 |        |        |  Q1,00 | PCWP |         |
|   7 |        NESTED LOOPS                           |                 |      5 |    375 |      4   (0)| 00:00:01 |        |        |  Q1,00 | PCWP |         |
|   8 |     PX PARTITION HASH ALL                     |                 |      5 |    125 |      2   (0)| 00:00:01 |      1 |      8 |  Q1,00 | PCWC |         |
|*  9 |      TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| CONNECTIONSGE$  |      5 |    125 |      2   (0)| 00:00:01 |      1 |      8 |  Q1,00 | PCWP |         |
|* 10 |       INDEX RANGE SCAN                        | CONNECTIONSXSE$ |     20 |        |      1   (0)| 00:00:01 |      1 |      8 |  Q1,00 | PCWP |         |
|  11 |     PARTITION HASH ITERATOR                   |                 |      1 |        |      0   (0)| 00:00:01 |    KEY |    KEY |  Q1,00 | PCWP |         |
|* 12 |      TABLE ACCESS BY LOCAL INDEX ROWID        | CONNECTIONSVT$  |        |        |             |          |    KEY |    KEY |  Q1,00 | PCWP |         |
|* 13 |       INDEX UNIQUE SCAN                       | CONNECTIONSXQV$ |      1 |        |      0   (0)| 00:00:01 |    KEY |    KEY |  Q1,00 | PCWP |         |
------------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   9 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'feuds')
  10 - access("SVID"=1)
  12 - filter(INTERNAL_FUNCTION("VERTICES"."V"))
  13 - access("DVID"="VERTICES"."VID" AND "VERTICES"."K"=U'country')
       filter(INTERNAL_FUNCTION("VERTICES"."K"))
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-6C71C301-6678-478B-AD45-15CAF8CA2C51">
                     <p class="titleinexample">Example 4-14 Find a Person's Collaborators, and aggregate and sort them</p>
                     <p>The following SQL statement finds the collaborators of the vertex with ID 1, aggregates them by their country, and sorts them in ascending order.</p><pre class="pre codeblock"><code>SQL&gt; select vertices.v, count(1) 
      from connectionsGE$, connectionsVT$ vertices 
     where svid=1 
       and el='collaborates' 
       and dvid=vertices.vid 
       and vertices.k='country' 
  group by vertices.v 
  order by count(1) asc;
</code></pre><p>The example output and execution plan may be as follows. In this case, the vertex with ID 1 has the most collaborators in the United States.</p><pre class="oac_no_warn" dir="ltr">Germany        1
Japan          1
Iran           1
United States  7


---------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                         | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ    |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                                  |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |        |      |        |
|   1 |  PX COORDINATOR                                   |                 |       |       |              |          |       |       |        |      |        |
|   2 |   PX SEND QC (ORDER)                              | :TQ10002        |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,02 | P-&gt;S | QC (ORDER) |
|   3 |    SORT ORDER BY                                  |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,02 | PCWP |        |
|   4 |     PX RECEIVE                                    |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,02 | PCWP |        |
|   5 |      PX SEND RANGE                                | :TQ10001        |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,01 | P-&gt;P | RANGE  |
|   6 |       HASH GROUP BY                               |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,01 | PCWP |        |
|   7 |        PX RECEIVE                                 |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,01 | PCWP |        |
|   8 |     PX SEND HASH                                  | :TQ10000        |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,00 | P-&gt;P | HASH   |
|   9 |      HASH GROUP BY                                |                 |    10 |   750 |     9    (23)| 00:00:01 |       |       |  Q1,00 | PCWP |        |
|  10 |       NESTED LOOPS                                |                 |    10 |   750 |     7     (0)| 00:00:01 |       |       |  Q1,00 | PCWP |        |
|  11 |        PX PARTITION HASH ALL                      |                 |    10 |   250 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |        |
|* 12 |         TABLE ACCESS BY LOCAL INDEX ROWID BATCHED | CONNECTIONSGE$  |    10 |   250 |     2     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
|* 13 |          INDEX RANGE SCAN                         | CONNECTIONSXSE$ |    20 |       |     1     (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |        |
|  14 |        PARTITION HASH ITERATOR                    |                 |     1 |       |     0     (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |        |
|* 15 |         TABLE ACCESS BY LOCAL INDEX ROWID         | CONNECTIONSVT$  |       |       |        |                |   KEY |   KEY |  Q1,00 | PCWP |        |
|* 16 |          INDEX UNIQUE SCAN                        | CONNECTIONSXQV$ |     1 |       |     0     (0)| 00:00:01 |   KEY |   KEY |  Q1,00 | PCWP |        |
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

  12 - filter(INTERNAL_FUNCTION("EL") AND "EL"=U'collaborates')
  13 - access("SVID"=1)
  15 - filter(INTERNAL_FUNCTION("VERTICES"."V"))
  16 - access("DVID"="VERTICES"."VID" AND "VERTICES"."K"=U'country')
       filter(INTERNAL_FUNCTION("VERTICES"."K"))
</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09" name="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09"></a><h3 id="SPGDG-GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09" class="sect3"><span class="enumeration_section">4.4 </span>Navigation Options: CONNECT BY and Parallel Recursion
               </h3>
               <div>
                  <p>The CONNECT BY clause and parallel recursion provide options for advanced navigation and querying.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>CONNECT BY lets you navigate and find matches in a hierarchical order. To follow outgoing edges, you can use prior dvid = svid to guide the navigation.</p>
                     </li>
                     <li>
                        <p>Parallel recursion lets you perform navigation up to a specified number of hops away.</p>
                     </li>
                  </ul>
                  <p>The examples use a property graph named connections.</p>
                  <div class="example" id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09__WHOAREAPERSONSCOLLABORATORS-37415127">
                     <p class="titleinexample">Example 4-15 CONNECT WITH</p>
                     <p>The following SQL statement follows the outgoing edges by 1 hop.</p><pre class="pre codeblock"><code>SQL&gt; select G.dvid
       from connectionsGE$ G
      start with svid = 1
    <span class="bold">connect by</span> nocycle prior dvid = svid and <span class="bold">level &lt;= 1</span>;
</code></pre><p>The preceding example's output and execution plan may be as follows.</p><pre class="oac_no_warn" dir="ltr">         2
         3
         4
         5
         6
         7
         8
         9
        10
        ...
------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                 | Name            | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT          |                 |     7 |   273 |     3  (67)| 00:00:01 |       |       |        |      |            |
|*  1 |  CONNECT BY WITH FILTERING|                 |       |       |            |          |       |       |        |      |            |
|   2 |   PX COORDINATOR          |                 |       |       |            |          |       |       |        |      |            |
|   3 |    PX SEND QC (RANDOM)    | :TQ10000        |     2 |    12 |     0   (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|   4 |     PX PARTITION HASH ALL |                 |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |            |
|*  5 |      INDEX RANGE SCAN     | CONNECTIONSXSE$ |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |            |
|*  6 |   FILTER                  |                 |       |       |            |          |       |       |        |      |            |
|   7 |    NESTED LOOPS           |                 |     5 |    95 |     1   (0)| 00:00:01 |       |       |        |      |            |
|   8 |     CONNECT BY PUMP       |                 |       |       |            |          |       |       |        |      |            |
|   9 |     PARTITION HASH ALL    |                 |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |        |      |            |
|* 10 |      INDEX RANGE SCAN     | CONNECTIONSXSE$ |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |        |      |            |
------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("SVID"=PRIOR "DVID")
       filter(LEVEL&lt;=2)
   5 - access("SVID"=1)
   6 - filter(LEVEL&lt;=2)
  10 - access("connect$_by$_pump$_002"."prior dvid "="SVID")
</pre><p>To extend from 1 hop to multiple hops, change 1 in the preceding example to another integer. For example, to change it to 2 hops, specify: <code class="codeph">level &lt;= 2</code></p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09__GUID-C848A824-CDA0-4758-B46D-467E3F9E7C54">
                     <p class="titleinexample">Example 4-16 Parallel Recursion</p>
                     <p>The following SQL statement uses recursion within the WITH clause to perform navigation up to 4 hops away, a using recursively defined graph expansion: <code class="codeph">g_exp</code> references <code class="codeph">g_exp</code> in the query, and that defines the recursion. The example also uses the PARALLEL optimizer hint for parallel execution.
                     </p><pre class="pre codeblock"><code>SQL&gt; WITH <span class="bold">g_exp</span>(svid, dvid, depth) as
  ( 
    select svid as svid, dvid as dvid, 0 as depth
      from connectionsGE$
     where svid=1
   union all
     select g2.svid,  g1.dvid, g2.depth + 1
       from <span class="bold">g_exp</span> g2, connectionsGE$ g1
      where g2.dvid=g1.svid
        and g2.depth &lt;= 3
  )   
select  /*+ parallel(4) */ dvid, depth
  from  g_exp
 where svid=1
;
</code></pre><p>The example's output and execution plan may be as follows. Note that <code class="codeph">CURSOR DURATION MEMORY</code> is chosen in the execution, which indicates the graph expansion stores the intermediate data in memory.
                     </p><pre class="oac_no_warn" dir="ltr">        22          4
        25          4
        24          4
         1          4

        23          4
        33          4
        22          4
        22          4
       ...         ...


Execution Plan
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Operation                                    | Name                       | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |    TQ  |IN-OUT| PQ Distrib |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                             |                            |   801 | 31239 |   147   (0)| 00:00:01 |       |       |        |      |            |
|   1 |  TEMP TABLE TRANSFORMATION                   |                            |       |       |            |          |       |       |        |      |            |
|   2 |   LOAD AS SELECT (<span class="bold">CURSOR DURATION MEMORY</span>)    | SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |        |      |            |
|   3 |    UNION ALL (RECURSIVE WITH) BREADTH FIRST  |                            |       |       |            |          |       |       |        |      |            |
|   4 |     PX COORDINATOR                           |                            |       |       |            |          |       |       |        |      |            |
|   5 |      PX SEND QC (RANDOM)                     | :TQ20000                   |     2 |    12 |     0   (0)| 00:00:01 |       |       |  Q2,00 | P-&gt;S | QC (RAND)  |
|   6 |       LOAD AS SELECT (CURSOR DURATION MEMORY)| SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |  Q2,00 | PCWP |            |
|   7 |        PX PARTITION HASH ALL                 |                            |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q2,00 | PCWC |            |
|*  8 |         INDEX RANGE SCAN                     | CONNECTIONSXSE$            |     2 |    12 |     0   (0)| 00:00:01 |     1 |     8 |  Q2,00 | PCWP |            |
|   9 |     PX COORDINATOR                           |                            |       |       |            |          |       |       |        |      |            |
|  10 |      PX SEND QC (RANDOM)                     | :TQ10000                   |   799 |    12M|    12   (0)| 00:00:01 |       |       |  Q1,00 | P-&gt;S | QC (RAND)  |
|  11 |       LOAD AS SELECT (CURSOR DURATION MEMORY)| SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |  Q1,00 | PCWP |            |
|* 12 |        HASH JOIN                             |                            |   799 |    12M|    12   (0)| 00:00:01 |       |       |  Q1,00 | PCWP |            |
|  13 |         BUFFER SORT (REUSE)                  |                            |       |       |            |          |       |       |  Q1,00 | PCWP |            |
|  14 |          PARTITION HASH ALL                  |                            |   164 |   984 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWC |            |
|  15 |           INDEX FAST FULL SCAN               | CONNECTIONSXDE$            |   164 |   984 |     2   (0)| 00:00:01 |     1 |     8 |  Q1,00 | PCWP |            |
|  16 |         PX BLOCK ITERATOR                    |                            |       |       |            |          |       |       |  Q1,00 | PCWC |            |
|* 17 |          TABLE ACCESS FULL                   | SYS_TEMP_0FD9D6614_11CB2D2 |       |       |            |          |       |       |  Q1,00 | PCWP |            |
|  18 |   PX COORDINATOR                             |                            |       |       |            |          |       |       |        |      |            |
|  19 |    PX SEND QC (RANDOM)                       | :TQ30000                   |   801 | 31239 |   135   (0)| 00:00:01 |       |       |  Q3,00 | P-&gt;S | QC (RAND)  |
|* 20 |     VIEW                                     |                            |   801 | 31239 |   135   (0)| 00:00:01 |       |       |  Q3,00 | PCWP |            |
|  21 |      PX BLOCK ITERATOR                       |                            |   801 |    12M|   135   (0)| 00:00:01 |       |       |  Q3,00 | PCWC |            |
|  22 |       TABLE ACCESS FULL                      | SYS_TEMP_0FD9D6614_11CB2D2 |   801 |    12M|   135   (0)| 00:00:01 |       |       |  Q3,00 | PCWP |            |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   8 - access("SVID"=1)
  12 - access("G2"."DVID"="G1"."SVID")
  17 - filter("G2"."INTERNAL_ITERS$"=LEVEL AND "G2"."DEPTH"&lt;=3)
  20 - filter("SVID"=1)
</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734" name="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734"></a><h3 id="SPGDG-GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734" class="sect3"><span class="enumeration_section">4.5 </span>Pivot
               </h3>
               <div>
                  <p>The PIVOT clause lets you dynamically add columns to a table to create a new table.</p>
                  <p>The schema design (VT$ and GE$) of the property graph is narrow ("skinny") rather than wide ("fat"). This means that if a vertex or edge has multiple properties, those property keys, values, data types, and so on will be stored using multiple rows instead of multiple columns. Such a design is very flexible in the sense that you can add properties dynamically without having to worry about adding too many columns or even reaching the physical maximum limit of number of columns a table may have. However, for some applications you may prefer to have a wide table if the properties are somewhat homogeneous.</p>
                  <div class="example" id="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734__PARALLELRECURSION-3744C9CA">
                     <p class="titleinexample">Example 4-17 Pivot</p>
                     <p>The following CREATE TABLE ... AS SELECT statement uses PIVOT to add four columns: ‘company’,’ occupation’,’ name’, and ‘religion’.</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE table pg_wide
as
 with G AS (select vid, k, t, v
              from connectionsVT$
           )
 select *
   from G
  pivot (
    min(v) for k in ('company', 'occupation', 'name', 'religion')
  );

Table created.
</code></pre><p>The following DESCRIBE statement shows the definition of the new table, including the four added columns. (The output is reformatted for readability.)</p><pre class="pre codeblock"><code>SQL&gt; DESCRIBE pg_wide;
 Name                                                  Null?    Type
--------------------------------------------------- -------- --------------------
 VID                                                   NOT NULL NUMBER
 T                                                              NUMBER(38)
 'company'                                                      NVARCHAR2(15000)
 'occupation'                                                   NVARCHAR2(15000)
 'name'                                                         NVARCHAR2(15000)
 'religion'                                                     NVARCHAR2(15000)
</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" name="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6"></a><h3 id="SPGDG-GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" class="sect3"><span class="enumeration_section">4.6 </span>SQL-Based Property Graph Analytics
               </h3>
               <div>
                  <p>In addition to the analytical functions offered by the in-memory analyst, the property graph feature in Oracle Spatial and Graph supports several native, SQL-based property graph analytics.</p>
                  <p>SQL-based analytics are especially useful if:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The computation is not bound by the physical memory. </p>
                     </li>
                     <li>
                        <p>There is no need to move the graph data outside the database.</p>
                     </li>
                     <li>
                        <p>Computation is easily done against the latest snapshot of a property graph.</p>
                     </li>
                     <li>
                        <p>There is no need to 'sync up' (synchronize) data inside and outside the database.</p>
                     </li>
                  </ul>
                  <p>However, when a graph (or a subgraph) fits in memory, then running analytics provided by the in-memory analyst usually provides better better performance than using SQL-based analytics. Because many of the analytics implementation require using intermediate data structures, most SQL- (PL/SQL-) based analytics APIs have parameters for working tables (wt). A typical flow has the following steps:</p>
                  <ol>
                     <li>
                        <p>Prepare the working table or tables.</p>
                     </li>
                     <li>
                        <p>Perform analytics (one or multiple calls).</p>
                     </li>
                     <li>
                        <p>Perform cleanup</p>
                     </li>
                  </ol>
                  <div class="example" id="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6__PIVOT-3749698E">
                     <p class="titleinexample">Example 4-18 Shortest Path</p>
                     <p>Consider shortest path, for example. Internally, Oracle Database uses the bidirectional Dijkstra algorithm. The following code snippet shows an end-to-end flow.</p><pre class="pre codeblock"><code>set serveroutput on
  
DECLARE   
  wt1 varchar2(100);  -- intermediate working tables
  n number;
  path    varchar2(1000);
  weights varchar2(1000);
BEGIN
  -- prepare
  opg_apis.find_sp_prep('connectionsGE$', wt1);
  dbms_output.put_line('working table name    ' || wt1);

  -- compute
  opg_apis.find_sp(
     'connectionsGE$',
      1,                          -- start vertex ID
      53,                         -- destination vertex ID
      wt1,                        -- working table (for Dijkstra expansion)
      dop =&gt; 1,                   -- degree of parallelism
      stats_freq=&gt;1000,           -- frequency to collect statistics
      path_output =&gt; path,        -- shortest path (a sequence of vertices)
      weights_output =&gt; weights,  -- edge weights
      options =&gt; null
      );
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  -- cleanup (commented out here; see text after the example)
  -- opg_apis.find_sp_cleanup('connectionsGE$', wt1);
END;
/
</code></pre><p>This example may produce the following output. Note that if <span class="bold"><span class="italic">no </span></span>working table name is provided, the preparation step will automatically generate a temporary table name and create it. Because the temporary working table name uses the session ID, your output will probably be different.
                     </p><pre class="oac_no_warn" dir="ltr">working table name    "CONNECTIONSGE$$TWFS12"
path    1 3    52 53
weights 4 3 1    1 1

PL/SQL procedure successfully completed.
</pre><p>If you want to know the definition of the working table or tables, then skip the cleanup phase (as shown in the preceding example that comments out the call to <code class="codeph">find_sp_cleanup</code>). After the computation is done, you can describe the working table or tables.
                     </p><pre class="pre codeblock"><code>SQL&gt; describe "CONNECTIONSGE$$TWFS12"
 Name                Null?    Type
 --------- -------- ----------------------------
 NID                            NUMBER
 D2S                            NUMBER
 P2S                            NUMBER
 D2T                            NUMBER
 P2T                            NUMBER
 F                            NUMBER(38)
 B                            NUMBER(38)
</code></pre><p>For advanced users who want to try different table creation options, such as using inmemory or advanced compression, you can pre-create the preceding working table and pass the name in.</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6__GUID-00B8293E-B672-43C6-A1C3-809E4E3F78BF">
                     <p class="titleinexample">Example 4-19 Create Working Table and Perform Analytics</p>
                     <p>The following statements first create a working table with the same column structure and basic compression enabled, then pass it to the computation.</p><pre class="pre codeblock"><code>create table connections<span class="bold">$MY_EXP</span>(
 NID                            NUMBER,
 D2S                            NUMBER,
 P2S                            NUMBER,
 D2T                            NUMBER,
 P2T                            NUMBER,
 F                            NUMBER(38),
 B                            NUMBER(38)
) <span class="bold">compress</span> nologging;


DECLARE
  wt1 varchar2(100) := '<span class="bold">connections$MY_EXP</span>';
  n number;
  path    varchar2(1000);
  weights varchar2(1000);
BEGIN
  dbms_output.put_line('working table name    ' || wt1);

  -- compute
  opg_apis.find_sp(
     'connectionsGE$',
      1,
      53,
      wt1,
      dop =&gt; 1,
      stats_freq=&gt;1000,
      path_output =&gt; path,
      weights_output =&gt; weights,
      options =&gt; null
      );
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  -- cleanup
  -- opg_apis.find_sp_cleanup('connectionsGE$', wt1);
END;
/
</code></pre><p>At the end of the computation, if the working table has not been dropped or truncated, you can check the content of the working table, as follows. Note that the working table structure may vary between releases.</p><pre class="pre codeblock"><code>SQL&gt; select * from connections$MY_EXP;
       NID        D2S        P2S        D2T        P2T          F          B
---------- ---------- ---------- ---------- ---------- ---------- ----------
         1          0            1.000E+100                     1         -1
        53 1.000E+100                     0                    -1          1
        54 1.000E+100                     1         53         -1          1
        52 1.000E+100                     1         53         -1          1
         5          1          1 1.000E+100                     0         -1
        26          1          1 1.000E+100                     0         -1
         8       1000          1 1.000E+100                     0         -1
         3          1          1          2         52          0          0
        15          1          1 1.000E+100                     0         -1
        21          1          1 1.000E+100                     0         -1
        19          1          1 1.000E+100                     0         -1
       ...
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6__GUID-5E486DA6-DCC4-4AC7-A236-05B4380B6B23">
                     <p class="titleinexample">Example 4-20 Multiple Calls to Same Graph</p>
                     <p>To perform multiple calls to the same graph, only <span class="italic">a single call</span> to the preparation step is needed. The following shows an example of computing shortest path for multiple pairs of vertices.
                     </p><pre class="pre codeblock"><code>DECLARE
  wt1 varchar2(100);  -- intermediate working tables
  n number;
  path    varchar2(1000);
  weights varchar2(1000);
BEGIN
  -- prepare
  opg_apis.find_sp_prep('connectionsGE$', wt1);
  dbms_output.put_line('working table name    ' || wt1);

  <span class="bold">-- find shortest path from vertex 1 to vertex 53</span>
  opg_apis.find_sp( 'connectionsGE$', 1, 53,
      wt1, dop =&gt; 1, stats_freq=&gt;1000, path_output =&gt; path, weights_output =&gt; weights, options =&gt; null);
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  <span class="bold">-- find shortest path from vertex 2 to vertex 36</span>
  opg_apis.find_sp( 'connectionsGE$', 2, 36,
      wt1, dop =&gt; 1, stats_freq=&gt;1000, path_output =&gt; path, weights_output =&gt; weights, options =&gt; null);
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  <span class="bold">-- find shortest path from vertex 30 to vertex 4
</span>  opg_apis.find_sp( 'connectionsGE$', 30, 4,
      wt1, dop =&gt; 1, stats_freq=&gt;1000, path_output =&gt; path, weights_output =&gt; weights, options =&gt; null);
  dbms_output.put_line('path    ' || path);
  dbms_output.put_line('weights ' || weights);

  -- cleanup
  opg_apis.find_sp_cleanup('connectionsGE$', wt1);
END;
/
</code></pre><p>The example's output may be as follows: three shortest paths have been found for the multiple pairs of vertices provided.</p><pre class="oac_no_warn" dir="ltr">working table name    "CONNECTIONSGE$$TWFS12"
path    1 3    52 53
weights 4 3 1   1 1
path    2    36
weights 2 1   1
path    30 21    1 4
weights 4 3 1   1 1

PL/SQL procedure successfully completed.
</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>