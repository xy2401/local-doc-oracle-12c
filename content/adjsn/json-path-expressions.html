<!DOCTYPE html
  SYSTEM "about:legacy-compat">

<!-- saved from url=(0023)https://docs.oracle.com -->

<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">
      <meta name="description" content="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">
      <title>SQL/JSON Path Expressions</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="JSON Developer's Guide">
      <meta property="og:description" content="Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="JSON Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 17.8.1">
      <link rel="alternate" href="json-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2017-10-16T10:10:51-07:00">
      <meta name="dcterms.title" content="JSON Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="2015, 2017">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E85668-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/12.2">
      <meta name="dcterms.release" content="Release 12.2">
      <link rel="prev" href="simple-dot-notation-access-to-json-data.html" title="Previous" type="text/html">
      <link rel="next" href="clauses-used-in-functions-and-conditions-for-json.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">
            {
                "primary":
                {
                    "category":{
                      "short_name":"database",
                      "element_name":"Database",
                      "display_in_url":true
                    },
                    "suite":{
                      "short_name":"oracle",
                      "element_name":"Oracle",
                      "display_in_url":true
                    },
                    "product_group":{
                      "short_name":"not-applicable",
                      "element_name":"Not applicable",
                      "display_in_url":false
                    },
                    "product":{
                      "short_name":"oracle-database",
                      "element_name":"Oracle Database",
                      "display_in_url":true
                    },
                    "release":{
                      "short_name":"12.2",
                      "element_name":"Release 12.2",
                      "display_in_url":true
                    },
                    "platform":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    },
                    "component":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    }
                }
            }
            </script>
      
    <meta name="dcterms.isVersionOf" content="ADJSN">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="simple-dot-notation-access-to-json-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="clauses-used-in-functions-and-conditions-for-json.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JSON Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-json-data.html" property="item" typeof="WebPage"><span property="name">Query JSON Data</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL/JSON Path Expressions</li>
            </ol>
            <a id="GUID-2DC05D71-3D62-4A14-855F-76E054032494" name="GUID-2DC05D71-3D62-4A14-855F-76E054032494"></a>
            
            <h2 id="ADJSN-GUID-2DC05D71-3D62-4A14-855F-76E054032494" class="sect2"><span class="enumeration_chapter">12 </span>SQL/JSON Path Expressions
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.</p>
               <div class="section"></div>
               <!-- class="section" -->
            </div>
            <div>
               <p><strong>Topics:</strong></p>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F">Overview of SQL/JSON Path Expressions</a><br>Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.
                  </li>
                  <li class="ulchildlink"><a href="json-path-expressions.html#GUID-7B610884-39CD-4910-85E7-C251D342D879">SQL/JSON Path Expression Syntax</a><br>SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.
                  </li>
               </ul>
            </div>
            <a id="ADXDB6254"></a><div class="props_rev_3"><a id="GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" name="GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F"></a><h3 id="ADJSN-GUID-11006CA4-91CA-4D22-AB14-8F25508CFC5F" class="sect3"><span class="enumeration_section">12.1 </span>Overview of SQL/JSON Path Expressions
               </h3>
               <div>
                  <p>Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.</p>
                  <p>JSON is a notation for JavaScript values. When JSON data is stored in the database you can query it using path expressions that are somewhat analogous to XQuery or XPath expressions for XML data. Similar to the way that SQL/XML allows SQL access to XML data using XQuery expressions, Oracle Database provides SQL access to JSON data using SQL/JSON path expressions.</p>
                  <p>SQL/JSON path expressions have a simple syntax. A path expression selects zero or more JSON values that match, or satisfy, it.</p>
                  <p>SQL/JSON condition <code class="codeph">json_exists</code> returns true if at least one value matches, and false if no value matches. If a single value matches, then SQL/JSON function <code class="codeph">json_value</code> returns that value if it is scalar and raises an error if it is non-scalar. If no value matches the path expression then <code class="codeph">json_value</code> returns SQL <code class="codeph">NULL</code>.
                  </p>
                  <p>SQL/JSON function <code class="codeph">json_query</code> returns all of the matching values, that is, it can return multiple values. You can think of this behavior as returning a sequence of values, as in XQuery, or you can think of it as returning multiple values. (No user-visible sequence is manifested.)
                  </p>
                  <p>In all cases, path-expression matching attempts to match each <span class="italic">step</span> of the path expression, in turn. If matching any step fails then no attempt is made to match the subsequent steps, and matching of the path expression fails. If matching each step succeeds then matching of the path expression succeeds.
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="json-path-expressions.html#GUID-7B610884-39CD-4910-85E7-C251D342D879" title="SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.">SQL/JSON Path Expression Syntax</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="ADXDB6255"></a><div class="props_rev_3"><a id="GUID-7B610884-39CD-4910-85E7-C251D342D879" name="GUID-7B610884-39CD-4910-85E7-C251D342D879"></a><h3 id="ADJSN-GUID-7B610884-39CD-4910-85E7-C251D342D879" class="sect3"><span class="enumeration_section">12.2 </span>SQL/JSON Path Expression Syntax
               </h3>
               <div>
                  <p>SQL/JSON path expressions are matched by SQL/JSON functions and conditions against JSON data, to select portions of it. Path expressions can use wildcards and array ranges. Matching is case-sensitive.</p>
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>You pass a SQL/JSON path expression and some JSON data to a SQL/JSON function or condition. The path expression is matched against the data, and the matching data is processed by the particular SQL/JSON function or condition. You can think of this matching process in terms of the path expression <span class="italic">returning</span> the matched data to the function or condition.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <p><strong>Topics:</strong></p>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618">Basic SQL/JSON Path Expression Syntax</a><br>The basic syntax of a SQL/JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item, followed optionally by a function step. Examples are provided.
                     </li>
                     <li class="ulchildlink"><a href="json-path-expressions.html#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77">SQL/JSON Path Expression Syntax Relaxation</a><br>The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="conditions-is-json-and-is-not-json.html#GUID-1B6CFFBE-85FE-41DD-BA14-DD1DE73EAB20" title="The Oracle default syntax for JSON is lax. In particular: it reflects the JavaScript syntax for object fields; the Boolean and null values are not case-sensitive; and it is more permissive with respect to numerals, whitespace, and escaping of Unicode characters.">About Strict and Lax JSON Syntax</a></li>
                        <li><a href="diagrams-basic-sql-json-path-expression-syntax.html" title="Syntax diagrams and corresponding Backus-Naur Form (BNF) syntax descriptions are presented for the basic SQL/JSON path expression syntax.">Diagrams for Basic SQL/JSON Path Expression Syntax</a></li>
                     </ul>
                  </div>
               </div>
               <a id="ADXDB6372"></a><div class="props_rev_3"><a id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" name="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618"></a><h4 id="ADJSN-GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" class="sect4"><span class="enumeration_section">12.2.1 </span>Basic SQL/JSON Path Expression Syntax
                  </h4>
                  <div>
                     <p>The basic syntax of a SQL/JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item, followed optionally by a function step. Examples are provided.</p>
                     <div class="section">
                        <p>However, this basic syntax is extended by relaxing the matching of arrays and non-arrays against non-array and array patterns, respectively — see <a href="json-path-expressions.html#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">SQL/JSON Path Expression Syntax Relaxation</a>.
                        </p>
                        <p>Matching of data against SQL/JSON path expressions is case-sensitive.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A SQL/JSON <span class="bold"><strong class="term">basic path expression</strong></span> (also called just a <span class="italic">path expression</span> here) is an <span class="italic">absolute simple path expression</span>, followed by an optional <span class="italic">filter expression</span>.
                              </p>
                              <p>The optional filter expression can be present <span class="italic">only</span> when the path expression is used in SQL condition <code class="codeph">json_exists</code>. No steps can follow the filter expression. (This is not allowed, for example: <code class="codeph">$.a?(@.b == 2).c</code>.)
                              </p>
                           </li>
                           <li>
                              <p>An <span class="bold"><strong class="term">absolute simple path expression</strong></span> begins with a dollar sign (<code class="codeph"><span class="bold">$</span></code>), which represents the path-expression <span class="bold"><strong class="term">context item</strong></span>, that is, the JSON data to be matched. That data is the result of evaluating a SQL expression that is passed as argument to the SQL/JSON function.
                              </p> 
                              <p>The dollar sign is followed by zero or more path <span class="bold"><strong class="term">steps</strong></span>. Each step can be an <span class="italic">object step</span> or an <span class="italic">array step</span>, depending on whether the context item represents a JSON object or a JSON array. The last step of a simple path expression can be a single, optional <span class="italic">function step</span>.
                              </p>
                           </li>
                           <li>
                              <p>An <span class="bold"><strong class="term">object step</strong></span> is a period (<span class="bold"><code class="codeph">.</code></span>), sometimes read as "dot", followed by an object field name (object property name) or an asterisk (<span class="bold"><code class="codeph">*</code></span>) wildcard, which stands for (the values of) <span class="italic">all</span> fields. A field name can be <span class="italic">empty</span>, in which case it <span class="italic">must</span> be written as <code class="codeph"><span class="bold">""</span></code>. A nonempty field name must start with an uppercase or lowercase letter A to Z and contain only such letters or decimal digits (0-9), or else it must be enclosed in double quotation marks (<span class="bold"><code class="codeph">"</code></span>). An object step returns the <span class="italic">value</span> of the field that is specified. If a wildcard is used for the field then the step returns the <span class="italic">values</span> of all fields, in no special order.
                              </p>
                           </li>
                           <li>
                              <p>An <span class="bold"><strong class="term">array step</strong></span> is a left bracket (<span class="bold"><code class="codeph">[</code></span>) followed by <span class="italic">either</span> an asterisk (<span class="bold"><code class="codeph">*</code></span>) wildcard, which stands for <span class="italic">all</span> array elements, <span class="italic">or</span> one or more specific array indexes or range specifications separated by commas, followed by a right bracket (<span class="bold"><code class="codeph">]</code></span>). In a path expression, array indexing is zero-based (0, 1, 2,...), as in the JavaScript convention for arrays. A range specification has the form <span class="italic"><code class="codeph">N</code></span> to <span class="italic"><code class="codeph">M</code></span>, where <span class="italic"><code class="codeph">N</code></span> and <span class="italic"><code class="codeph">M</code></span> are array indexes and <span class="italic"><code class="codeph">N</code></span> is strictly less than <span class="italic"><code class="codeph">M</code></span>. (An error is raised at query compilation time if <span class="italic"><code class="codeph">N</code></span> is not less than <span class="italic"><code class="codeph">M</code></span>.) An error is raised if you use both an asterisk and either an array index or range specification.
                              </p>
                              <p>When indexes or range specifications are used, the array elements they collectively specify must be specified in ascending order, without repetitions, or else a compile-time error is raised. For example, an error is raised for each of <code class="codeph">[3, 1 to 4]</code>, <code class="codeph">[4, 2]</code>, <code class="codeph">[2, 3 to 3]</code>, and <code class="codeph">[2, 3, 3]</code>. Errors are raised on the first two because the order is not ascending, Errors are raised on the last two because of the repetition of element number <code class="codeph">3</code> (the fourth element, because of zero-based indexing).
                              </p>
                              <p>Similarly, the elements in the array value that results from matching are in ascending order, with no repetitions. If an asterisk is used in the path expression then all of the array elements are returned, in array order. </p>
                           </li>
                           <li>
                              <p>A single <span class="bold"><strong class="term">function step</strong></span> is <span class="italic">optional</span>. If present, it is the last step of the path expression. It is a dot (<span class="bold"><code class="codeph">.</code></span>), followed by a SQL/JSON <span class="bold"><strong class="term">item method</strong></span>. It is followed by a left parenthesis (<code class="codeph"><span class="bold">(</span></code>) and then a right parenthesis (<code class="codeph"><span class="bold">)</span></code>). The parentheses can have whitespace between them (such whitespace is insignificant). The function is applied to the data that is targeted by the rest of the same path expression, which precedes it. It is used to transform that data. The function or condition that is passed the path expression uses the transformed data in place of the targeted data.
                              </p>
                              <div class="infoboxnote" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__GUID-1F32E68E-7627-4CFE-87DB-40BAD7D05A1E">
                                 <p class="notep1">Note:</p>
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>If an item method is applied to an array, it is in effect applied to each of the array elements. For example, <code class="codeph">$.a.<span class="codeinlineitalic">fun</span>()</code> applies item-method <code class="codeph"><span class="codeinlineitalic">fun()</span></code> to each element of array <code class="codeph">a</code>, to convert it. The resulting array of converted values is then used for matching, in place of <code class="codeph">a</code>.
                                       </p>
                                    </li>
                                    <li>
                                       <p>If an item-method conversion fails for any reason, such as its argument being of the wrong type, then the path cannot be matched (it refers to no data), and <span class="italic">no error is raised</span>. In particular, this means that such an error is not handled by an error clause in the SQL/JSON function or condition to which the path expression is passed.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                              <p>The available item methods are the following. </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">abs()</code>: The absolute value of the targeted JSON number. Corresponds to the use of SQL function <code class="codeph">ABS</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ceiling()</code>: The targeted JSON number, rounded up to the nearest integer. Corresponds to the use of SQL function <code class="codeph">CEIL</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">date()</code>: The SQL <code class="codeph">DATE</code> value that corresponds to the targeted JSON string. The string data must be in one of the ISO date formats.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">double()</code>: The SQL <code class="codeph">BINARY_DOUBLE</code> numeric value that corresponds to the targeted JSON string or number.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">floor()</code>: The targeted JSON number, rounded down to the nearest integer. Corresponds to the use of SQL function <code class="codeph">FLOOR</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">length()</code>: The number of characters in the targeted JSON string, as a SQL <code class="codeph">NUMBER</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">lower()</code>: The lowercase string that corresponds to the characters in the targeted JSON string.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">number()</code>: The SQL <code class="codeph">NUMBER</code> value that corresponds to the targeted JSON string or number.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">string()</code>: A string representation of the targeted JSON value. The representation is the same as that used for the <code class="codeph">RETURNING</code> clause of a SQL/JSON function with return type <code class="codeph">VARCHAR2</code>. (A Boolean value is represented by the string <code class="codeph">"true"</code> or <code class="codeph">"false"</code>; a <code class="codeph">null</code> value is represented by the string <code class="codeph">"null"</code>; and a number is represented in a canonical form.) Any error that occurs during serialization to the string representation is ignored.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">timestamp()</code>: The SQL <code class="codeph">TIMESTAMP</code> value that corresponds to the targeted JSON string. The string data must be in one of the ISO date formats. 
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">upper()</code>: The uppercase string that corresponds to the characters in the targeted JSON string.
                                    </p>
                                 </li>
                              </ul>
                              <p>Item methods <code class="codeph">date()</code>, <code class="codeph">length()</code>, <code class="codeph">lower()</code>, <code class="codeph">number()</code>, <code class="codeph">string()</code>, <code class="codeph">timestamp(</code>), and <code class="codeph">upper()</code> are Oracle extensions to the SQL/JSON standard. The other item methods are part of the standard.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">filter expression</strong></span> (<span class="bold"><strong class="term">filter</strong></span>, for short) is a question mark (<code class="codeph"><span class="bold">?</span></code>) followed by a <span class="italic">filter condition</span> enclosed in parentheses (<code class="codeph"><span class="bold">()</span></code>). A filter is satisfied if its condition is satisfied, that is, returns true.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">filter condition</strong></span> applies a predicate (Boolean function) to its arguments and is one of the following, where each of <code class="codeph"><span class="codeinlineitalic">cond</span></code>, <code class="codeph"><span class="codeinlineitalic">cond1</span></code>, and <code class="codeph"><span class="codeinlineitalic">cond2</span></code> stands for a filter condition.
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph"><span class="bold">(</span> <span class="codeinlineitalic">cond</span> <span class="bold">)</span></code>: Parentheses are used for grouping, separating filter condition <code class="codeph"><span class="codeinlineitalic">cond</span></code> as a unit from other filter conditions that may precede or follow it.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="codeinlineitalic">cond1</span> <span class="bold">&amp;&amp;</span> <span class="codeinlineitalic">cond2</span></code>: The conjunction (<span class="italic">and</span>) of <code class="codeph"><span class="codeinlineitalic">cond1</span></code> and <code class="codeph"><span class="codeinlineitalic">cond2</span></code>, requiring that both be satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="codeinlineitalic">cond1</span> <span class="bold">||</span> <span class="codeinlineitalic">cond2</span></code>: The inclusive disjunction (<span class="italic">or</span>) of <code class="codeph"><span class="codeinlineitalic">cond1</span></code> and <code class="codeph"><span class="codeinlineitalic">cond2</span></code>, requiring that <code class="codeph"><span class="codeinlineitalic">cond1</span></code>, <code class="codeph"><span class="codeinlineitalic">cond2</span></code>, or both, be satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="bold">! (</span> <span class="codeinlineitalic">cond</span> <span class="bold">)</span></code>: The negation of <code class="codeph"><span class="codeinlineitalic">cond</span></code>, meaning that <code class="codeph"><span class="codeinlineitalic">cond</span></code> must <span class="italic">not</span> be satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph"><span class="bold">exists (</span></code>, followed by a <span class="italic">relative simple path expression</span>, followed by <code class="codeph"><span class="bold">)</span></code>: The targeted data exists.
                                    </p>
                                 </li>
                                 <li>
                                    <p>A <span class="bold"><strong class="term">comparison</strong></span>, which is one of the following: 
                                    </p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>A <span class="italic">relative simple path expression</span>, followed by a <span class="italic">comparison predicate</span>, followed by either a JSON scalar value or a <span class="italic">SQL/JSON variable</span>.
                                          </p>
                                       </li>
                                       <li>
                                          <p>Either a JSON scalar value or a <span class="italic">SQL/JSON variable</span>, followed by a  <span class="italic">comparison predicate</span>, followed by a <span class="italic">relative simple path expression</span>.
                                          </p>
                                       </li>
                                       <li>
                                          <p>A JSON scalar value, followed by a <span class="italic">comparison predicate</span>, followed by another JSON scalar value.
                                          </p>
                                       </li>
                                    </ul>
                                    <p>A <span class="bold"><strong class="term">comparison predicate</strong></span> is <code class="codeph"><span class="bold">==</span></code>, <code class="codeph"><span class="bold">!=</span></code>, <code class="codeph"><span class="bold">&lt;</span></code>, <code class="codeph"><span class="bold">&lt;=</span></code>, <code class="codeph"><span class="bold">&gt;=</span></code>, or <code class="codeph"><span class="bold">&gt;</span></code>.
                                    </p>
                                    <p>A <span class="bold"><strong class="term">SQL/JSON variable</strong></span> is a dollar sign (<code class="codeph"><span class="bold">$</span></code>) followed by the name of a SQL identifier that is bound in a <code class="codeph">PASSING</code> clause for <code class="codeph">json_exists</code>.
                                    </p>
                                 </li>
                              </ul>
                              <p>The predicates that you can use in filter conditions are thus <code class="codeph">&amp;&amp;</code>, <code class="codeph">||</code>, <code class="codeph">!</code>, <code class="codeph">exists</code>, <code class="codeph">==</code>, <code class="codeph">!=</code>, <code class="codeph">&lt;</code>, <code class="codeph">&lt;=</code>,<code class="codeph"> &gt;=</code>, and <code class="codeph">&gt;</code>.
                              </p>
                              <p>As an example, the filter condition <code class="codeph">(a || b) &amp;&amp; (!(c) || d &lt; 42)</code> is satisfied if both of the following criteria are met:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>At least one of the filter conditions <code class="codeph">a</code> and <code class="codeph">b</code> is satisfied: <code class="codeph">(a || b)</code>.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Filter condition <code class="codeph">c</code> is <span class="italic">not</span> satisfied or the number <code class="codeph">d</code> is less than or equal to 42, or both are true: <code class="codeph">(!(c) || d &lt; 42)</code>.
                                    </p>
                                 </li>
                              </ul>
                              <p>Comparison predicate <code class="codeph">!</code> has precedence over <code class="codeph">&amp;&amp;</code>, which has precedence over <code class="codeph">||</code>. You can always use parentheses to control grouping.
                              </p>
                              <p>Without parentheses for grouping, the preceding example would be <code class="codeph">a || b &amp;&amp; !(c) || d &lt; 42</code>, which would be satisfied if at least one of the following criteria is met:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Condition <code class="codeph">b &amp;&amp; !(c)</code> is satisfied, which means that each of the conditions <code class="codeph">b</code> and <code class="codeph">!(c)</code> is satisfied (which in turn means that condition <code class="codeph">c</code> is not satisfied).
                                    </p>
                                 </li>
                                 <li>
                                    <p>Condition <code class="codeph">a</code> is satisfied.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Condition <code class="codeph">d &lt; 42</code> is satisfied.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">relative simple path expression</strong></span> is an at sign (<code class="codeph"><span class="bold">@</span></code>) followed by zero or more path steps. The at sign represents the path-expression <span class="bold"><strong class="term">current filter item</strong></span>, that is, the JSON data that matches the part of the (surrounding) path expression that precedes the filter. The simple path expression is matched against the current filter item in the same way that a path expression is matched against the context item.
                              </p>
                           </li>
                           <li>
                              <p>A <span class="bold"><strong class="term">simple path expression</strong></span> is either an <span class="italic">absolute simple path expression</span> or a <span class="italic">relative simple path expression</span>. (The former begins with <code class="codeph">$</code>; the latter begins with <code class="codeph">@</code>.)
                              </p>
                           </li>
                        </ul>
                        <p>Here are some examples of path expressions, with their meanings spelled out in detail.</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">$</code> &#x2013; The context item.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends</code> &#x2013; The value of field <code class="codeph">friends</code> of a context-item object. The dot (<code class="codeph"><span class="bold">.</span></code>) immediately after the dollar sign (<code class="codeph"><span class="bold">$</span></code>) indicates that the context item is a JSON <span class="italic">object</span>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[0]</code> &#x2013; An object that is the first element of an array that is the value of field <code class="codeph">friends</code> of a context-item object. The bracket notation indicates that the value of field <code class="codeph">friends</code> is an <span class="italic">array</span>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[0].name</code> &#x2013; Value of field <code class="codeph">name</code> of an object that is the first element of an array that is the value of field <code class="codeph">friends</code> of a context-item object. The second dot (<code class="codeph"><span class="bold">.</span></code>) indicates that the first element of array <code class="codeph">friends</code> is an object (with a <code class="codeph">name</code> field).
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[*].name</code> &#x2013; Value of field <code class="codeph">name</code> of <span class="italic">each</span> object in an array that is the value of field <code class="codeph">friends</code> of a context-item object.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.*[*].name</code> &#x2013; Field <code class="codeph">name</code> values for each object in an array value of a field of a context-item object.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3, 8 to 10, 12]</code> &#x2013; The fourth, ninth through eleventh, and thirteenth elements of an array <code class="codeph">friends</code> (field of a context-item object). The elements must be specified in <span class="italic">ascending order</span>, and they are returned in that order: fourth, ninth, tenth, eleventh, thirteenth.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars</code> &#x2013; The value of field <code class="codeph">cars</code> of an object that is the fourth element of an array <code class="codeph">friends</code>. The dot (<code class="codeph"><span class="bold">.</span></code>) indicates that the fourth element is an object (with a <code class="codeph">cars</code> field).
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].*</code> &#x2013; The values of <span class="italic">all</span> of the fields of an object that is the fourth element of an array <code class="codeph">friends</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars[0].year</code> &#x2013; The value of field <code class="codeph">year</code> of an object that is the first element of an array that is the value of field <code class="codeph">cars</code> of an object that is the fourth element of an array <code class="codeph">friends</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].cars[0]?(@.year &gt; 2014)</code> &#x2013; The first object of an array <code class="codeph">cars</code> (field of an object that is the fourth element of an array <code class="codeph">friends</code>), <span class="italic">provided that</span> the value of its field <code class="codeph">year</code> is greater than 2014.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3]?(@.addresses.city == "San Francisco")</code> &#x2013; An object that is the fourth element of an array <code class="codeph">friends</code>, provided that it has an <code class="codeph">addresses</code> field whose value is an object with a field <code class="codeph">city</code> whose value is the string <code class="codeph">"San Francisco"</code>.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3]?(@.addresses.city == "San Francisco" &amp;&amp; @.addresses.state == "Nevada")</code> &#x2013; Objects that are the fourth element of an array <code class="codeph">friends</code>, provided that there is a match for an address with a <code class="codeph">city</code> of <code class="codeph">"San Francisco"</code> and there is a match for an address with a <code class="codeph">state</code> of <code class="codeph">"Nevada"</code>. 
                              </p>
                              <p>Note: The filter conditions in the conjunction do <span class="italic">not</span> necessarily apply to the same object — the filter tests for the existence of an object with city San Francisco and for the existence of an object with state Nevada. It does <span class="italic">not</span> test for the existence of an object with both city San Francisco and state Nevada. See <a href="condition-JSON_EXISTS.html#GUID-8A0043D5-95F8-4918-9126-F86FB0E203F0" title="You can use SQL/JSON condition json_exists with a path expression that has one or more filter expressions, to select documents that contain matching data. Filters let you test for the existence of documents that have particular fields that satisfy various conditions.">Using Filters with JSON_EXISTS</a>. 
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$.friends[3].addresses?(@.city == "San Francisco" &amp;&amp; @.state == "Nevada")</code> &#x2013; An object that is the fourth element of array <code class="codeph">friends</code>, provided that object has a match for <code class="codeph">city</code> of <code class="codeph">"San Francisco"</code> and a match for <code class="codeph">state</code> of <code class="codeph">"Nevada"</code>. 
                              </p>
                              <p>Unlike the preceding example, in this case the filter conditions in the conjunction, for fields <code class="codeph">city</code> and <code class="codeph">state</code>, apply to the <span class="italic">same</span> <code class="codeph">addresses</code> object. The filter applies to a given <code class="codeph">addresses</code> object, which is outside it.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="condition-JSON_EXISTS.html#GUID-8A0043D5-95F8-4918-9126-F86FB0E203F0" title="You can use SQL/JSON condition json_exists with a path expression that has one or more filter expressions, to select documents that contain matching data. Filters let you test for the existence of documents that have particular fields that satisfy various conditions.">Using Filters with JSON_EXISTS</a></li>
                           <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="SQL/JSON query functions json_value and json_query accept an optional RETURNING clause, which specifies the data type of the value returned by the function. This clause and the default behavior (no RETURNING clause) are described here.">RETURNING Clause for SQL/JSON Query Functions</a></li>
                           <li><a href="json-path-expressions.html#GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" title="The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.">SQL/JSON Path Expression Syntax Relaxation</a></li>
                           <li><a href="diagrams-basic-sql-json-path-expression-syntax.html" title="Syntax diagrams and corresponding Backus-Naur Form (BNF) syntax descriptions are presented for the basic SQL/JSON path expression syntax.">Diagrams for Basic SQL/JSON Path Expression Syntax</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-AEBAD813-99AB-418A-93AB-F96BC1658618__GUID-F6FF8FF6-3773-4E1A-BDEA-6DAE47639138">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/12.2/adjsn&amp;id=wikipedia_iso8601">ISO 8601</a>  for information about the ISO date formats
                        </p>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6373"></a><div class="props_rev_3"><a id="GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" name="GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77"></a><h4 id="ADJSN-GUID-951A61D5-EDC2-4E30-A20C-AE2AE7605C77" class="sect4"><span class="enumeration_section">12.2.2 </span>SQL/JSON Path Expression Syntax Relaxation
                  </h4>
                  <div>
                     <p>The basic SQL/JSON path-expression syntax is relaxed to allow implicit array wrapping and unwrapping. This means that you need not change a path expression in your code if your data evolves to replace a JSON value with an array of such values, or vice versa. Examples are provided.</p>
                     <p><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a> defines the basic SQL/JSON path-expression syntax. The actual path expression syntax supported relaxes that definition as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If a path-expression step targets (expects) an array but the actual data presents no array then the data is implicitly wrapped in an array.</p>
                        </li>
                        <li>
                           <p>If a path-expression step targets (expects) a non-array but the actual data presents an array then the array is implicitly unwrapped.</p>
                        </li>
                     </ul>
                     <p>This relaxation allows for the following abbreviation: <span class="bold"><code class="codeph">[*]</code></span> can be elided whenever it precedes the object accessor, <span class="bold"><code class="codeph">.</code></span>, followed by an object field name, with no change in effect. The reverse is also true: <span class="bold"><code class="codeph">[*]</code></span> can always be inserted in front of the object accessor,<span class="bold"><code class="codeph"> .</code></span>, with no change in effect.
                     </p>
                     <p>This means that the object step <code class="codeph">[*].</code><span class="italic"><code class="codeph">prop</code></span>, which stands for the value of field <span class="italic"><code class="codeph">prop</code></span> of each element of a given array of objects, can be abbreviated as <span class="italic"><code class="codeph">.prop</code></span>, and the object step <span class="italic"><code class="codeph">.prop</code></span>, which looks as though it stands for the <span class="italic"><code class="codeph">prop</code></span> value of a single object, stands also for the <span class="italic"><code class="codeph">prop</code></span> value of each element of an array to which the object accessor is applied.
                     </p>
                     <p>This is an important feature, because it means that you need not change a path expression in your code if your data evolves to replace a given JSON value with an array of such values, or vice versa.</p>
                     <p>For example, if your data originally contains objects that have field <code class="codeph">Phone</code> whose value is a single object with fields <code class="codeph">type</code> and <code class="codeph">number</code>, the path expression <code class="codeph">$.Phone.number</code>, which matches a single phone number, can still be used if the data evolves to represent an array of phones. Path expression <code class="codeph">$.Phone.number</code> matches either a single phone object, selecting its number, or an array of phone objects, selecting the number of each.
                     </p>
                     <p>Similarly, if your data mixes both kinds of representation — there are some data entries that use a single phone object and some that use an array of phone objects, or even some entries that use both — you can use the same path expression to access the phone information from these different kinds of entry.</p>
                     <p>Here are some example path expressions from section <a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a>, together with an explanation of equivalences.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">$.friends</code> &#x2013; The value of field <code class="codeph">friends</code> of <span class="italic">either</span>:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The (single) context-item object.</p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$[*].friends</code>) Each object in the context-item array.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">$.friends[0].name</code> &#x2013; Value of field <code class="codeph">name</code> for <span class="italic">any</span> of these objects:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p> The first element of the array that is the value of field <code class="codeph">friends</code> of the context-item object.
                                 </p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$.friends.name</code>) The value of field <code class="codeph">friends</code> of the context-item object.
                                 </p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$[*].friends.name</code>) The value of field <code class="codeph">friends</code> of each object in the context-item array.
                                 </p>
                              </li>
                              <li>
                                 <p> (equivalent to <code class="codeph">$[*].friends[0].name</code>) The first element of each array that is the value of field <code class="codeph">friends</code> of each object in the context-item array.
                                 </p>
                              </li>
                           </ul>
                           <p>The context item can be an object or an array of objects. In the latter case, each object in the array is matched for a field <code class="codeph">friends</code>.
                           </p>
                           <p>The value of field <code class="codeph">friends</code> can be an object or an array of objects. In the latter case, the first object in the array is used.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">$.*[*].name</code> &#x2013; Value of field <code class="codeph">name</code> for <span class="italic">any</span> of these objects:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>An element of an array value of a field of the context-item object.</p>
                              </li>
                              <li>
                                 <p>(equivalent to <code class="codeph">$.*.name</code>) The value of a field of the context-item object.
                                 </p>
                              </li>
                              <li>
                                 <p>(equivalent to <code class="codeph">$[*].*.name</code>) The value of a field of an object in the context-item array.
                                 </p>
                              </li>
                              <li>
                                 <p>(equivalent to <code class="codeph">$[*].*[*].name</code>) Each object in an array value of a field of an object in the context-item array.
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="json-path-expressions.html#GUID-AEBAD813-99AB-418A-93AB-F96BC1658618" title="The basic syntax of a SQL/JSON path expression is presented. It is composed of a context item followed by zero or more object or array steps, depending on the nature of the context item, followed optionally by a function step. Examples are provided.">Basic SQL/JSON Path Expression Syntax</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>