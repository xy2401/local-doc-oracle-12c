<!DOCTYPE html
  SYSTEM "about:legacy-compat">

<!-- saved from url=(0023)https://docs.oracle.com -->

<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Tuning Oracle Text</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Application Developer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Application Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 17.8.1">
      <link rel="alternate" href="text-application-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2017-10-10T16:34:47-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2017">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E85649-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/12.2">
      <meta name="dcterms.release" content="Release 12.2">
      <link rel="prev" href="classifying-documents-in-oracle-text.html" title="Previous" type="text/html">
      <link rel="next" href="searching-document-sections-in-oracle-text.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">
            {
                "primary":
                {
                    "category":{
                      "short_name":"database",
                      "element_name":"Database",
                      "display_in_url":true
                    },
                    "suite":{
                      "short_name":"oracle",
                      "element_name":"Oracle",
                      "display_in_url":true
                    },
                    "product_group":{
                      "short_name":"not-applicable",
                      "element_name":"Not applicable",
                      "display_in_url":false
                    },
                    "product":{
                      "short_name":"oracle-database",
                      "element_name":"Oracle Database",
                      "display_in_url":true
                    },
                    "release":{
                      "short_name":"12.2",
                      "element_name":"Release 12.2",
                      "display_in_url":true
                    },
                    "platform":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    },
                    "component":{
                      "short_name":"",
                      "element_name":"",
                      "display_in_url":false
                    }
                }
            }
            </script>
      
    <meta name="dcterms.title" content="Text Application Developer's Guide">
    <meta name="dcterms.isVersionOf" content="CCAPP">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="classifying-documents-in-oracle-text.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="searching-document-sections-in-oracle-text.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Application Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Tuning Oracle Text </li>
            </ol>
            <a id="GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF" name="GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF"></a><a id="CCAPP0500"></a>
            
            <h2 id="CCAPP-GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF" class="sect2"><span class="enumeration_chapter">7 </span> Tuning Oracle Text 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Text provides ways to improve your query and indexing performance. </p>
               <p>This chapter contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-6F920664-89E8-4CF5-A974-225F51E276EF">Optimizing Queries with Statistics</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D">Optimizing Queries for Response Time</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-21432876-BCE4-4250-A67F-C6E76017B872">Optimizing Queries for Throughput</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29">Composite Domain Index (CDI) in Oracle Text</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA">Performance Tuning with CDI</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF">Solving Index and Query Bottlenecks Using Tracing</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A">Using Parallel Queries</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8">Tuning Queries with Blocking Operations</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3">Frequently Asked Questions About Query Performance</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9">Frequently Asked Questions About Indexing Performance</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3">Frequently Asked Questions About Updating the Index</a></p>
                  </li>
               </ul>
            </div><a id="CCAPP9633"></a><div class="props_rev_3"><a id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF" name="GUID-6F920664-89E8-4CF5-A974-225F51E276EF"></a><h3 id="CCAPP-GUID-6F920664-89E8-4CF5-A974-225F51E276EF" class="sect3"><span class="enumeration_section">7.1 </span>Optimizing Queries with Statistics
               </h3>
               <div>
                  <p>Query optimization with statistics uses the collected statistics on the tables and indexes in a query to select an execution plan that can process the query in the most efficient manner. As a general rule, Oracle recommends that you collect statistics on your base table if you are interested in improving your query performance. Optimizing with statistics enables a more accurate estimation of the selectivity and costs of the <code class="codeph">CONTAINS</code> predicate and thus a better execution plan.
                  </p>
                  <p>The optimizer attempts to choose the best execution plan based on the following parameters:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The selectivity on the <code class="codeph">CONTAINS</code> predicate
                        </p>
                     </li>
                     <li>
                        <p>The selectivity of other predicates in the query</p>
                     </li>
                     <li>
                        <p>The CPU and I/O costs of processing the <code class="codeph">CONTAINS</code> predicates
                        </p>
                     </li>
                  </ul>
                  <p>The following topics discuss how to use statistics with the extensible query optimizer.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730">Collecting Statistics</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-A2137127-9B0D-48EE-962F-2408F49FA244">Query Optimization with Statistics Example</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-763C6A28-275A-4C6F-A740-5A02F9E13575">Re-Collecting Statistics</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-225089FD-7E86-4DB0-8D37-D04213D1D053">Deleting Statistics</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF__GUID-38AC436F-535D-4E4A-BA59-5DA54E2BC1D1">
                     <p class="notep1">Note:</p>
                     <p>Importing and exporting of statistics on domain indexes, including Oracle Text indexes, is not supported with the <code class="codeph">DBMS_STATS</code> package. For more information on importing and exporting statistics, see the <a href="../arpls/DBMS_STATS.html#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF__GUID-EE16CCEF-1071-4816-8DF6-2F23D7724EC4">
                     <p class="notep1">See Also:</p>
                     <p><a href="../ccref/oracle-text-CONTAINS-query-operators.html#CCREF0300"><span class="italic">Oracle Text Reference</span></a> for information on the <code class="codeph">CONTAINS</code> query operator
                     </p>
                  </div>
               </div><a id="CCAPP9634"></a><div class="props_rev_3"><a id="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730" name="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730"></a><h4 id="CCAPP-GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730" class="sect4"><span class="enumeration_section">7.1.1 </span>Collecting Statistics
                  </h4>
                  <div>
                     <p>By default, Oracle Text uses the cost-based optimizer (CBO) to determine the best execution plan for a query. </p>
                     <p>To enable the optimizer to better estimate costs, you can calculate the statistics on the table you query as follows:</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; COMPUTE STATISTICS;
</pre><p>Alternatively, you can estimate the statistics on a sample of the table as follows:</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; ESTIMATE STATISTICS 1000 ROWS;
</pre><p>or</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; ESTIMATE STATISTICS 50 PERCENT;
</pre><p>You can also collect statistics in parallel with the <code class="codeph">DBMS_STATS.GATHER_TABLE_STATS</code> procedure:
                     </p><pre class="oac_no_warn" dir="ltr">begin
 
DBMS_STATS.GATHER_TABLE_STATS('owner', 'table_name',
                                       estimate_percent=&gt;50,
                                       block_sample=&gt;TRUE,
                                       degree=&gt;4) ;
 
end  ;
</pre><p>These statements collect statistics on all the objects associated with <code class="codeph">table_name</code>, including the table columns and any indexes (b-tree, bitmap, or Text domain) associated with the table.
                     </p>
                     <p>To re-collect the statistics on a table, enter the <code class="codeph">ANALYZE</code> statement as many times as necessary or use the <code class="codeph">DBMS_STATS</code> package.
                     </p>
                     <p>By collecting statistics on the Text domain index, the cost-based optimizer in Oracle Database is able to perform the following tasks:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Estimate the selectivity of the <code class="codeph">CONTAINS</code> predicate
                           </p>
                        </li>
                        <li>
                           <p>Estimate the I/O and CPU costs of using the Text index, that is, the cost of processing the <code class="codeph">CONTAINS</code> predicate using the domain index
                           </p>
                        </li>
                        <li>
                           <p>Estimate the I/O and CPU costs of each invocation of <code class="codeph">CONTAINS</code></p>
                        </li>
                     </ul>
                     <p>Knowing the selectivity of a <code class="codeph">CONTAINS</code> predicate is useful for queries that contain more than one predicate, such as in structured queries. This way the cost-based optimizer can better decide whether to use the domain index to evaluate <code class="codeph">CONTAINS</code> or to apply the <code class="codeph">CONTAINS</code> predicate as a post filter.
                     </p>
                     <div class="infoboxnotealso" id="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730__GUID-58EA9CED-2938-41B3-8FC7-8F7E5D6B147F">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../sqlrf/ANALYZE.html#SQLRF-GUID-535CE98E-2359-4147-839F-DCB3772C1B0E"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">ANALYZE</code> statement
                              </p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_STATS.html#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code class="codeph">DBMS_STATS</code> package
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9635"></a><div class="props_rev_3"><a id="GUID-A2137127-9B0D-48EE-962F-2408F49FA244" name="GUID-A2137127-9B0D-48EE-962F-2408F49FA244"></a><h4 id="CCAPP-GUID-A2137127-9B0D-48EE-962F-2408F49FA244" class="sect4"><span class="enumeration_section">7.1.2 </span>Query Optimization with Statistics Example
                  </h4>
                  <div>
                     <p>The following structured query provides an example for optimizing statistics.</p><pre class="oac_no_warn" dir="ltr">select score(1) from tab where contains(txt, 'freedom', 1)  &gt; 0 and author = 'King' and year &gt; 1960;
</pre><p>Assume the author column is of type <code class="codeph">VARCHAR2</code> and the year column is of type <code class="codeph">NUMBER</code>. Assume that there is a b-tree index on the <code class="codeph">author</code> column.
                     </p>
                     <p>Also assume that the structured <code class="codeph">author</code> predicate is highly selective with respect to the <code class="codeph">CONTAINS</code> predicate and the <code class="codeph">year</code> predicate. That is, the structured predicate (author = 'King') returns a much smaller number of rows with respect to the <code class="codeph">year</code> and <code class="codeph">CONTAINS</code> predicates individually, say 5 rows returned versus 1000 and 1500 rows respectively.
                     </p>
                     <p>In this situation, Oracle Text can execute this query more efficiently by first doing a b-tree index range scan on the structured predicate (author = 'King'), followed by a table access by rowid, and then applying the other two predicates to the rows returned from the b-tree table access.</p>
                     <div class="infoboxnote" id="GUID-A2137127-9B0D-48EE-962F-2408F49FA244__GUID-1B6F57EE-ED6A-42F9-89FD-172E7FD1BE09">
                        <p class="notep1">Note:</p>
                        <p>When statistics are not collected for a Text index, the cost-based optimizer assumes low selectivity and index costs for the <code class="codeph">CONTAINS</code> predicate.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9636"></a><div class="props_rev_3"><a id="GUID-763C6A28-275A-4C6F-A740-5A02F9E13575" name="GUID-763C6A28-275A-4C6F-A740-5A02F9E13575"></a><h4 id="CCAPP-GUID-763C6A28-275A-4C6F-A740-5A02F9E13575" class="sect4"><span class="enumeration_section">7.1.3 </span>Re-Collecting Statistics
                  </h4>
                  <div>
                     <p>After synchronizing your index, you can re-collect statistics on a single index to update the cost estimates.</p>
                     <p>If your base table has been re-analyzed before the synchronization, it is sufficient to analyze the index after the synchronization without re-analyzing the entire table.</p>
                     <p>To do so, enter any of the following statements:</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; COMPUTE STATISTICS;
</pre><p>or</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; ESTIMATE STATISTICS SAMPLE 50 PERCENT;</pre></div>
               </div><a id="CCAPP9637"></a><div class="props_rev_3"><a id="GUID-225089FD-7E86-4DB0-8D37-D04213D1D053" name="GUID-225089FD-7E86-4DB0-8D37-D04213D1D053"></a><h4 id="CCAPP-GUID-225089FD-7E86-4DB0-8D37-D04213D1D053" class="sect4"><span class="enumeration_section">7.1.4 </span>Deleting Statistics
                  </h4>
                  <div>
                     <p>You can delete the statistics associated with a table by issuing:</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; DELETE STATISTICS;
</pre><p>You can delete statistics on one index by issuing the following statement:</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; DELETE STATISTICS;</pre></div>
               </div>
            </div><a id="CCAPP9234"></a><div class="props_rev_3"><a id="GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D" name="GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D"></a><h3 id="CCAPP-GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D" class="sect3"><span class="enumeration_section">7.2 </span>Optimizing Queries for Response Time
               </h3>
               <div>
                  <p>By default, Oracle Text optimizes queries for throughput. This results in queries returning all rows in shortest time possible. </p>
                  <p>However, in many cases, especially in a Web application scenario, queries must be optimized for response time, when you are only interested in obtaining the first few hits of a potentially large hitlist in the shortest time possible. </p>
                  <p>The following sections describe some ways to optimize <code class="codeph">CONTAINS</code> queries for response time:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5">Other Factors that Influence Query Response Time</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2">Improved Response Time with FIRST_ROWS(n) Hint for ORDER BY Queries</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013">Improved Response Time Using the DOMAIN_INDEX_SORT Hint</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370">Improved Response Time using Local Partitioned CONTEXT Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D">Improved Response Time with Local Partitioned Index for Order by Score</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542">Improved Response Time with Query Filter Cache</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08">Improved Response Time using BIG_IO Option of CONTEXT Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-8D3C30AE-D466-46C1-A281-916B7D48994C">Improved Response Time using SEPARATE_OFFSETS Option of CONTEXT Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-54F2466B-7D05-45AC-A64E-04717F75C507">Improved Response Time Using STAGE_ITAB, STAGE_ITAB_MAX_ROWS, STAGE_ITAB_PARALLEL Options of CONTEXT Index</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9235"></a><div class="props_rev_3"><a id="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5" name="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5"></a><h4 id="CCAPP-GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5" class="sect4"><span class="enumeration_section">7.2.1 </span>Other Factors that Influence Query Response Time
                  </h4>
                  <div>
                     <p>There are other factors that can influence query response time such as:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Collection of table statistics</p>
                        </li>
                        <li>
                           <p>Memory allocation</p>
                        </li>
                        <li>
                           <p>Sorting</p>
                        </li>
                        <li>
                           <p>Presence of LOB columns in your base table</p>
                        </li>
                        <li>
                           <p>Partitioning</p>
                        </li>
                        <li>
                           <p>Parallelism</p>
                        </li>
                        <li>
                           <p>The number term expansions in your query</p>
                           <div class="infoboxnotealso" id="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5__GUID-C047BD97-E42F-4D4E-B5BF-1A4BB689F0F1">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="tuning-oracle-text.html#GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3">Frequently Asked Questions About Query Performance</a>"</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9236"></a><div class="props_rev_3"><a id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2" name="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2"></a><h4 id="CCAPP-GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2" class="sect4"><span class="enumeration_section">7.2.2 </span>Improved Response Time with FIRST_ROWS(n) Hint for ORDER BY Queries
                  </h4>
                  <div>
                     <p>When you need the first rows of an <code class="codeph">ORDER BY</code> query, Oracle recommends that you use the cost-based <code class="codeph">FIRST_ROWS(n)</code> hint.
                     </p>
                     <div class="infoboxnote" id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2__GUID-739F64F7-3668-4882-B311-FEE094A854F5">
                        <p class="notep1">Note:</p>
                        <p>As the <code class="codeph">FIRST_ROWS(n)</code> hint is cost-based, Oracle recommends that you collect statistics on your tables before you use this hint. 
                        </p>
                     </div>
                     <p>You use the <code class="codeph">FIRST_ROWS(n)</code> hint in cases where you want the first number (<span class="italic">n</span>) of rows in the shortest possible time. For example, consider the following PL/SQL block that uses a cursor to retrieve the first 10 hits of a query and uses the <code class="codeph">FIRST_ROWS(n)</code> hint to optimize the response time:
                     </p><pre class="oac_no_warn" dir="ltr">declare
cursor c is 

select /*+ FIRST_ROWS(10) */ article_id from articles_tab
   where contains(article, 'Omophagia')&gt;0 order by pub_date desc;

begin</pre><pre class="oac_no_warn" dir="ltr">for i in c
loop
insert into t_s values(i.pk, i.col);
exit when c%rowcount &gt; 11;
end loop;</pre><pre class="oac_no_warn" dir="ltr">end;
/
</pre><p>The cursor <code class="codeph">c</code> is a <code class="codeph">SELECT</code> statement that returns the rowids that contain the word <span class="italic">omophagia</span> in sorted order. The code loops through the cursor to extract the first 10 rows. These rows are stored in the temporary table <code class="codeph">t_s</code>. 
                     </p>
                     <p>With the <code class="codeph">FIRST_ROWS(n)</code> hint, the optimizer instructs the Text index to return rowids in score-sorted order when the cost of returning the top-N hits is lower.
                     </p>
                     <p>Without the hint, Oracle Database sorts the rowids after the Text index has returned <span class="italic">all</span> the rows in unsorted order that satisfy the <code class="codeph">CONTAINS</code> predicate. Retrieving the entire result set this way takes time.
                     </p>
                     <p>Because only the first 10 hits are needed in this query, using the hint results in better performance.</p>
                     <div class="infoboxnote" id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2__GUID-3E358C4E-6E9E-4043-92F4-9C6D089D77BB">
                        <p class="notep1">Note:</p>
                        <p>Use the <code class="codeph">FIRST_ROWS(n)</code> hint when you need only the first few hits of a query. When you need the entire result set, do not use this hint as it might result in poor performance. 
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9237"></a><div class="props_rev_3"><a id="GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013" name="GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013"></a><h4 id="CCAPP-GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013" class="sect4"><span class="enumeration_section">7.2.3 </span>Improved Response Time Using the DOMAIN_INDEX_SORT Hint
                  </h4>
                  <div>
                     <p>You can also optimize for response time using the related <code class="codeph">DOMAIN_INDEX_SORT</code> hint. Like <code class="codeph">FIRST_ROWS(n)</code>, when queries are optimized for response time, Oracle Text returns the first rows in the shortest time possible.
                     </p>
                     <p>For example, you can use this hint as follows</p><pre class="oac_no_warn" dir="ltr">select /*+ DOMAIN_INDEX_SORT */ pk, score(1), col from ctx_tab 
            where contains(txt_col, 'test', 1) &gt; 0 order by score(1) desc;
</pre><p>However, this hint is only rule-based. This means that Oracle Text always chooses the index which satisfies the <code class="codeph">ORDER BY</code> clause. This might result in sub-optimal performance for queries in which the <code class="codeph">CONTAINS</code> clause is very selective. In these cases, Oracle recommends that you use the <code class="codeph">FIRST_ROWS(n)</code> hint, which is fully cost-based.
                     </p>
                  </div>
               </div><a id="CCAPP9238"></a><div class="props_rev_3"><a id="GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370" name="GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370"></a><h4 id="CCAPP-GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370" class="sect4"><span class="enumeration_section">7.2.4 </span>Improved Response Time using Local Partitioned CONTEXT Index
                  </h4>
                  <div>
                     <p>Partitioning your data and creating local partitioned indexes can improve your query performance. On a partitioned table, each partition has its own set of index tables. Effectively, there are multiple indexes, but the results from each are combined as necessary to produce the final result set. </p>
                     <p>You create the <code class="codeph">CONTEXT</code> index using the <code class="codeph">LOCAL</code> keyword as follows: 
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name (column_name) 
INDEXTYPE IS ctxsys.context
PARAMETERS ('...')
LOCAL
</pre><p>With partitioned tables and indexes, you can improve performance of the following types of queries:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="tuning-oracle-text.html#GUID-11DC7D61-E6FB-4775-8427-8DF0C462CBEF">Range Search on Partition Key Column</a></p>
                        </li>
                        <li>
                           <p><a href="tuning-oracle-text.html#GUID-DAA9ED42-32AE-4DD8-B1A8-2E1F04136399">ORDER BY Partition Key Column</a></p>
                        </li>
                     </ul>
                  </div><a id="CCAPP9239"></a><div class="props_rev_3"><a id="GUID-11DC7D61-E6FB-4775-8427-8DF0C462CBEF" name="GUID-11DC7D61-E6FB-4775-8427-8DF0C462CBEF"></a><h5 id="CCAPP-GUID-11DC7D61-E6FB-4775-8427-8DF0C462CBEF" class="sect5"><span class="enumeration_section">7.2.4.1 </span>Range Search on Partition Key Column
                     </h5>
                     <div>
                        <p>This is a query that restricts the search to a particular range of values on a column that is also the partition key. For example, consider a query on a date range:</p><pre class="oac_no_warn" dir="ltr">SELECT storyid FROM storytab WHERE CONTAINS(story, 'oliver')&gt;0 and pub_date BETWEEN '1-OCT-93' AND '1-NOV-93';</pre><p></p>
                        <p>If the date range is quite restrictive, it is very likely that the query can be satisfied by only looking in a single partition.</p>
                     </div>
                  </div><a id="CCAPP9240"></a><div class="props_rev_3"><a id="GUID-DAA9ED42-32AE-4DD8-B1A8-2E1F04136399" name="GUID-DAA9ED42-32AE-4DD8-B1A8-2E1F04136399"></a><h5 id="CCAPP-GUID-DAA9ED42-32AE-4DD8-B1A8-2E1F04136399" class="sect5"><span class="enumeration_section">7.2.4.2 </span>ORDER BY Partition Key Column
                     </h5>
                     <div>
                        <p>This is a query that requires only the first <code class="codeph">n</code> hits, and that the <code class="codeph">ORDER BY</code> clause names the partition key. Consider an <code class="codeph">ORDER BY</code> query on a <code class="codeph">price</code> column to fetch the first 20 hits such as:
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM (</pre><pre class="oac_no_warn" dir="ltr">SELECT itemid FROM item_tab WHERE CONTAINS(item_desc, 'cd player')
  &gt;0 ORDER BY price)
  WHERE ROWNUM &lt; 20;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>In this example, with the table partitioned by price, the query might only need to get hits from the first partition to satisfy the query. </p>
                     </div>
                  </div>
               </div><a id="CCAPP9241"></a><div class="props_rev_3"><a id="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D" name="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D"></a><h4 id="CCAPP-GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D" class="sect4"><span class="enumeration_section">7.2.5 </span>Improved Response Time with Local Partitioned Index for Order by Score
                  </h4>
                  <div>
                     <p>Using the <code class="codeph">DOMAIN_INDEX_SORT</code> hint on a local partitioned index might result in poor performance, especially when you order by score. This is because all hits to the query across all partitions must be obtained before the results can be sorted.
                     </p>
                     <p>You can work around this by using an inline view when you use the <code class="codeph">DOMAIN_INDEX_SORT</code> hint. Specifically, you can use the <code class="codeph">DOMAIN_INDEX_SORT</code> hint to improve query performance on a local partitioned index under the following conditions:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The text query itself including the order by <code class="codeph">SCORE</code>() clause is expressed as an in-line view. 
                           </p>
                        </li>
                        <li>
                           <p>The text query inside the in-line view contains the <code class="codeph">DOMAIN_INDEX_SORT</code> hint. 
                           </p>
                        </li>
                        <li>
                           <p>The query on the in-line view has <code class="codeph">ROWNUM</code> predicate limiting number of rows to fetch from the view. 
                           </p>
                        </li>
                     </ul>
                     <p>For example, if you have the following text query and local text index created on a partitioned table <code class="codeph">doc_tab</code>: 
                     </p><pre class="oac_no_warn" dir="ltr">     select doc_id, score(1) from doc_tab 
        where contains(doc, 'oracle', 1)&gt;0 
        order by score(1) desc;
</pre><p>and you are only interested in fetching top 20 rows, you can rewrite the query to </p><pre class="oac_no_warn" dir="ltr">     select * from 
          (select /*+ DOMAIN_INDEX_SORT */ doc_id, score(1) from doc_tab 
              where contains(doc, 'oracle', 1)&gt;0 order by score(1) desc) 
      where rownum &lt; 21;</pre><div class="infoboxnotealso" id="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D__GUID-AA5F204B-8CE7-43D3-9DD9-EB184DF03B3B">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF-GUID-FD540872-4ED3-4936-96A2-362539931BA0"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">EXPLAIN PLAN</code> statement
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9551"></a><div class="props_rev_3"><a id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542" name="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542"></a><h4 id="CCAPP-GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542" class="sect4"><span class="enumeration_section">7.2.6 </span>Improved Response Time with Query Filter Cache
                  </h4>
                  <div>
                     <p>Oracle Text provides a cache layer called the query filter cache that can be used to cache the query results. The query filter cache is sharable across queries. Thus, the cached query results can be reused by multiple queries, improving the query response time.</p>
                     <p>The <a id="d26985e1394" class="indexterm-anchor"></a><code class="codeph">ctxfiltercache</code> operator should be used to specify which query results to cache. The following example uses the <code class="codeph">ctxfiltercache</code> operator to store the results of the <code class="codeph">common_predicate</code> query in the cache:
                     </p><pre class="oac_no_warn" dir="ltr">select * from docs where contains(txt, 'ctxfiltercache((common_predicate), FALSE)')&gt;0;</pre><p>In the following example, the cached results of the <code class="codeph">common_predicate</code> query are reused by the <code class="codeph">new_query</code> query, thus improving the query response time.
                     </p><pre class="oac_no_warn" dir="ltr">select * from docs where contains(txt, 'new_query &amp; ctxfiltercache((common_predicate), FALSE)')&gt;0; 
</pre><div class="infoboxnote" id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542__GUID-4A36AC7B-6A33-411A-80A2-4B368A6AB791">
                        <p class="notep1">Note:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You can specify the size of the query filter cache using the basic <a id="d26985e1423" class="indexterm-anchor"></a>storage attribute <code class="codeph">query_filter_cache_size</code></p>
                           </li>
                           <li>
                              <p>The <a id="d26985e1431" class="indexterm-anchor"></a>view <code class="codeph">ctx_filter_cache_statistics</code> provides various statistics about the query filter cache
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542__GUID-799CFE6F-3E8A-499D-B86A-DBF9E50A3145">
                        <p class="notep1">See Also:</p>
                        <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0245"><span class="italic">Oracle Text Reference</span></a> for more information about:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ctxfiltercache</code> operator
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">query_filter_cache_size</code> basic storage attribute
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ctx_filter_cache_statistics</code> view
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9552"></a><div class="props_rev_3"><a id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08" name="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08"></a><h4 id="CCAPP-GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08" class="sect4"><span class="enumeration_section">7.2.7 </span>Improved Response Time using BIG_IO Option of CONTEXT Index
                  </h4>
                  <div>
                     <p>Oracle Text provides the <a id="d26985e1515" class="indexterm-anchor"></a><code class="codeph">BIG_IO</code> option for improving the query performance for the <code class="codeph">CONTEXT</code> indexes that extensively use IO operations. The query performance improvement is mainly for data stored on rotating disks, and not for data stored on solid state disks.
                     </p>
                     <p>A <code class="codeph">CONTEXT</code> index with the <code class="codeph">BIG_IO</code> option enabled creates token type pairs with one LOB (large object datatype) for each unique token text. Thus, tokens with the same text but different token types correspond to different rows in the $I table. 
                     </p>
                     <p>The indexes with the <code class="codeph">BIG_IO</code> option enabled should have the token LOBs created as SecureFile LOBs. In the SecureFile lobs, the data is stored sequentially in multiple blocks. This improves the response time of the queries, as the queries can now perform longer sequential reads instead of performing many short reads.
                     </p>
                     <div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-7367A842-89FE-406B-8C89-5BF5553CCE01">
                        <p class="notep1">Note:</p>
                        <p>Using SecureFiles requires the <code class="codeph">COMPATIBLE</code> setting to be 11.0 or higher. In addition, the LOB must be created on an automatic segment space management (ASSM) tablespace. When migrating from the existing text indexes to SecureFiles, an ASSM tablespace should be used. To help in migrating the existing indexes to SecureFiles lobs, <code class="codeph">ALTER INDEX REBUILD</code> is extended to provide the replacement of storage preferences that only affect the $I table without performing reindex.
                        </p>
                     </div>
                     <p>To create a <code class="codeph">CONTEXT</code> index with the <code class="codeph">BIG_IO</code> index option, first create a basic storage preference by setting the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">YES</code>, and then specify this storage preference while creating the <code class="codeph">CONTEXT</code> index.
                     </p>
                     <p>The following example creates a basic storage preference <code class="codeph">mystore</code> and sets the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">YES</code>:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
exec ctx_ddl.set_attribute('mystore', 'BIG_IO', 'YES');</pre><p>To disable the <code class="codeph">BIG_IO</code> option, update the existing storage preference (<code class="codeph">mystore</code>) by setting the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">NO</code>, and then rebuild the index.
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'BIG_IO', 'NO');
alter index idx rebuild('replace storage mystore');</pre><div class="infoboxnotewarn" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-3601FAF1-231E-443D-86B0-1A2FBA23C585">
                        <p class="notep1">WARNING:</p>
                        <p>Do not use replace metadata operation to disable the <code class="codeph">BIG_IO</code> index option, as it can leave the index in an inconsistent state.
                        </p>
                     </div>
                     <p>To enable the <code class="codeph">BIG_IO</code> option for a partitioned index without rebuilding the index, modify the basic storage preference by setting the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">YES</code>, replace the global index metadata using <code class="codeph">ctx_ddl.replace_index_metadata</code>, and then call <code class="codeph">optimize_index</code> in <code class="codeph">REBUILD</code> mode for each of the partitions of the partitioned index table.
                     </p>
                     <p>The following example enables the <code class="codeph">BIG_IO</code> option for the partitioned index <code class="codeph">idx</code>:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'BIG_IO', 'YES');
exec ctx_ddl.replace_index_metadata('idx', 'replace storage mystore');
exec ctx_ddl.optimize_index('idx', 'rebuild', part_name=&gt;'part1');</pre><div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-D93129AE-B590-419D-8725-EBC75474D978">
                        <p class="notep1">Note:</p>
                        <p>If a procedure modifies the existing index tables with only the <code class="codeph">BIG_IO</code> option enabled, then it will not result in reindexing of the data.
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-87E28EC3-6C71-4BD2-B6DF-2D2A88CBEB45">
                        <p class="notep1">Note:</p>
                        <p>Since the <code class="codeph">BIG_IO</code> index option performs longer sequential reads, the queries that use the <code class="codeph">BIG_IO</code> index option require a large program global area (PGA) memory.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9553"></a><div class="props_rev_3"><a id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C" name="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C"></a><h4 id="CCAPP-GUID-8D3C30AE-D466-46C1-A281-916B7D48994C" class="sect4"><span class="enumeration_section">7.2.8 </span>Improved Response Time using SEPARATE_OFFSETS Option of CONTEXT Index
                  </h4>
                  <div>
                     <p>Oracle Text provides the <a id="d26985e1699" class="indexterm-anchor"></a><code class="codeph">SEPARATE_OFFSETS</code> option for improving the query performance for the <code class="codeph">CONTEXT</code> indexes that extensively use IO operations, and whose queries are mainly single-word or Boolean queries.
                     </p>
                     <p>The <code class="codeph">SEPARATE_OFFSETS</code> option creates a different postings list structure for the tokens of type <code class="codeph">TEXT</code>. Instead of interspersing docids, frequencies, info-length (length of the offsets information), and the offsets in the postings list, the <code class="codeph">SEPARATE_OFFSETS</code> option stores all the docids and the frequencies together at the beginning of the postings list, and all the info-lengths and the offsets at the end of the postings list. The header at the beginning of the posting contains the information about the boundary points between the docids and the offsets. This separation of the docids and the offsets reduces the time for the queries to read the data, thus improving the query response time.
                     </p>
                     <p>The performance of the <code class="codeph">SEPARATE_OFFSETS</code> option is best realized when it is used in conjunction with the <code class="codeph">BIG_IO</code> option, and is used for the tokens with very long posting.
                     </p>
                     <p>To create a <code class="codeph">CONTEXT</code> index with the <code class="codeph">SEPARATE_OFFSETS</code> index option, first create a basic storage preference by setting the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">T</code>, and then specify this storage preference while creating the <code class="codeph">CONTEXT</code> index.
                     </p>
                     <p>The following example creates a basic storage preference <code class="codeph">mystore</code> and sets the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">T</code>:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
exec ctx_ddl.set_attribute('mystore', 'SEPARATE_OFFSETS', 'T');</pre><p>To disable the <code class="codeph">SEPARATE_OFFSETS</code> option, update the existing storage preference (<code class="codeph">mystore</code>) by setting the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">F</code>, and then rebuild the index.
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'SEPARATE_OFFSETS', 'F');
alter index idx rebuild('replace storage mystore');</pre><div class="infoboxnotewarn" id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C__GUID-A8158A06-5648-4AD9-BEA0-2321746BD819">
                        <p class="notep1">WARNING:</p>
                        <p>Do not use replace metadata operation to disable the <code class="codeph">SEPARATE_OFFSETS</code> index option, as it can leave the index in an inconsistent state.
                        </p>
                     </div>
                     <p>To enable the <code class="codeph">SEPARATE_OFFSETS</code> option for a partitioned index without rebuilding the index, modify the basic storage preference by setting the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">T</code>, replace the global index metadata using <code class="codeph">ctx_ddl.replace_index_metadata</code>, and then call <code class="codeph">optimize_index</code> in REBUILD mode for each of the partitions of the partitioned index table.
                     </p>
                     <p>The following example enables the <code class="codeph">SEPARATE_OFFSETS</code> option for the partitioned index <code class="codeph">idx</code>:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'SEPARATE_OFFSETS', 'T');
exec ctx_ddl.replace_index_metadata('idx', 'replace storage mystore');
exec ctx_ddl.optimize_index('idx', 'rebuild', part_name=&gt;'part1');</pre><div class="infoboxnote" id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C__GUID-A378A48E-AC57-4955-89BE-3CE72B574A28">
                        <p class="notep1">Note:</p>
                        <p>If a procedure modifies the existing index tables with only the <code class="codeph">SEPARATE_OFFSETS</code> option enabled, then it will not result in reindexing of the data.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9554"></a><div class="props_rev_3"><a id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507" name="GUID-54F2466B-7D05-45AC-A64E-04717F75C507"></a><h4 id="CCAPP-GUID-54F2466B-7D05-45AC-A64E-04717F75C507" class="sect4"><span class="enumeration_section">7.2.9 </span>Improved Response Time Using STAGE_ITAB, STAGE_ITAB_MAX_ROWS, STAGE_ITAB_PARALLEL Options of CONTEXT Index
                  </h4>
                  <div>
                     <p>Oracle Text provides the <a id="d26985e1868" class="indexterm-anchor"></a>STAGE_ITAB option for improving the query performance for the CONTEXT indexes that extensively use DML operations for near real-time indexing.
                     </p>
                     <p>When the STAGE_ITAB index option is not used, whenever a new document is added to the CONTEXT index, SYNC_INDEX is called to make the documents searchable. This creates new rows in the $I table, thus increasing the fragmentation in the $I table. This leads to the deterioration of the query performance.</p>
                     <p>When the STAGE_ITAB index option is enabled, the information about the new documents is stored in the $G staging table, and not in the $I table. This ensures that the $I table does not get fragmented, and thus not deteriorating the query performance.</p>
                     <p>When the STAGE_ITAB index option is enabled, the $H b-tree index is also created on the $G table. The $G table and $H b-tree index are equivalent to the $I table and $X b-tree index.</p>
                     <p>Use the MERGE optimization mode to optimize the rows present in the $G table and move them to the $I table.</p>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-A43D5EC1-197B-483D-92D8-1F39FECCAEE9">
                        <p class="notep1">Note:</p>
                        <p>The $G table is stored in the KEEP pool. You should allocate sufficient KEEP pool memory and maintain a large enough $G table size using the new <code class="codeph">stage_itab_max_rows</code> option to provide improved query performance.
                        </p>
                     </div>
                     <p>To create a CONTEXT index with the STAGE_ITAB index option, first create a basic storage preference by setting the value of its <code class="codeph">STAGE_ITAB</code> storage attribute to <code class="codeph">YES</code>, and then specify this storage preference while creating the CONTEXT index.
                     </p>
                     <p>The following example creates a basic storage preference <code class="codeph">mystore</code> and sets the value of its <code class="codeph">STAGE_ITAB</code> storage attribute to <code class="codeph">YES</code>:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
exec ctx_ddl.set_attribute('mystore', 'STAGE_ITAB', 'YES');</pre><p>You can also enable the  STAGE_ITAB index option for an existing non-partitioned CONTEXT index by using the rebuild option of the ALTER INDEX statement.</p><pre class="oac_no_warn" dir="ltr">alter index IDX rebuild parameters('replace storage mystore');</pre><p>To disable the STAGE_ITAB option for a non-partitioned CONTEXT index, update the existing storage preference (<code class="codeph">mystore</code>) by setting the value of its <code class="codeph">STAGE_ITAB</code> storage attribute to <code class="codeph">NO</code>, and then rebuild the index.
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'STAGE_ITAB', 'NO');
alter index idx rebuild('replace storage mystore');</pre><p>This operation runs the optimization process using the MERGE optimization mode and then drops the $G table.</p>
                     <p>The rebuild option of the ALTER INDEX statement does not work with the partitioned CONTEXT index for enabling and disabling the STAGE_ITAB option. </p>
                     <p>The following example enables the STAGE_ITAB option for the partitioned CONTEXT index <code class="codeph">idx</code>:
                     </p><pre class="oac_no_warn" dir="ltr">alter index idx parameters('add stage_itab');</pre><p>The following example disables the STAGE_ITAB option for the partitioned CONTEXT index <code class="codeph">idx</code>:
                     </p><pre class="oac_no_warn" dir="ltr">alter index idx parameters('remove stage_itab');</pre><p>Starting with Oracle Database 12<span class="italic">c</span> Release 2 (12.2), the contents of $G are automatically moved to $I during index sync when $G has more than 1 million rows. This value is controlled by the <code class="codeph">STAGE_ITAB_MAX_ROWS</code> attribute of the STORAGE preference.
                     </p>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-9EDDF5DD-8229-4CB2-9AD8-989E1373FFC7">
                        <p class="notep1">Note:</p>
                        <p>If an occasional index synchronization is taking a long time, you can either reduce value of the <code class="codeph">STAGE_ITAB_MAX_ROWS</code> parameter or increase the degree of parallelism using the <code class="codeph">STAGE_ITAB_PARALLEL</code> attribute of the STORAGE preference. If the value of <code class="codeph">STAGE_ITAB_MAX_ROWS</code> is set to a very small value, then the contents of $G are moved to $I very frequently. So, it should not be set to a very low value either.
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-B7A48630-33B2-4C24-A338-7CBF6A4C937D">
                        <p class="notep1">Note:</p>
                        <p>To use the <code class="codeph">STAGE_ITAB</code> index option for a CONTEXT index, you must specify the BASIC_STORAGE preferences <code class="codeph">g_index_clause</code> and <code class="codeph">g_table_clause</code>.
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-96B52DC7-B82F-4977-8C3E-01DDFCD7DF62">
                        <p class="notep1">See Also:</p>
                        <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800"><span class="italic">Oracle Text Reference</span></a> for more information about BASIC_STORAGE
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9242"></a><div class="props_rev_3"><a id="GUID-21432876-BCE4-4250-A67F-C6E76017B872" name="GUID-21432876-BCE4-4250-A67F-C6E76017B872"></a><h3 id="CCAPP-GUID-21432876-BCE4-4250-A67F-C6E76017B872" class="sect3"><span class="enumeration_section">7.3 </span>Optimizing Queries for Throughput
               </h3>
               <div>
                  <p>Optimizing a query for throughput returns all hits in the shortest time possible. This is the default behavior.</p>
                  <p>The following sections describe how you can explicitly optimize for throughput.<a id="d26985e2040" class="indexterm-anchor"></a><a id="d26985e2044" class="indexterm-anchor"></a><a id="d26985e2048" class="indexterm-anchor"></a><a id="d26985e2052" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7C19933A-1859-4520-914C-0E5A03F93D54">CHOOSE and ALL ROWS Modes</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-04CD2DD4-F0F6-44E8-8243-F7D2FC2DCCDE">FIRST_ROWS(n) Mode</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9243"></a><div class="props_rev_3"><a id="GUID-7C19933A-1859-4520-914C-0E5A03F93D54" name="GUID-7C19933A-1859-4520-914C-0E5A03F93D54"></a><h4 id="CCAPP-GUID-7C19933A-1859-4520-914C-0E5A03F93D54" class="sect4"><span class="enumeration_section">7.3.1 </span>CHOOSE and ALL ROWS Modes
                  </h4>
                  <div>
                     <p>By default, queries are optimized for throughput under the <code class="codeph">CHOOSE</code> and <code class="codeph">ALL_ROWS</code> modes. When queries are optimized for throughput, Oracle Text returns <span class="italic">all</span> rows in the shortest time possible. 
                     </p>
                  </div>
               </div><a id="CCAPP9244"></a><div class="props_rev_3"><a id="GUID-04CD2DD4-F0F6-44E8-8243-F7D2FC2DCCDE" name="GUID-04CD2DD4-F0F6-44E8-8243-F7D2FC2DCCDE"></a><h4 id="CCAPP-GUID-04CD2DD4-F0F6-44E8-8243-F7D2FC2DCCDE" class="sect4"><span class="enumeration_section">7.3.2 </span>FIRST_ROWS(n) Mode
                  </h4>
                  <div>
                     <p>In <code class="codeph">FIRST_ROWS(n)</code> mode, the optimizer in Oracle Database optimizes for fast response time by having the Text domain index return score-sorted rows, if possible. This is the default behavior when you use the <code class="codeph">FIRST_ROWS(n)</code> hint. 
                     </p>
                     <p>If you want to optimize for better throughput under <code class="codeph">FIRST_ROWS(n)</code>, you can use the <code class="codeph">DOMAIN_INDEX_NO_SORT</code> hint. Better throughput means you are interested in getting all the rows to a query in the shortest time.
                     </p>
                     <p>The following example achieves better throughput by not using the Text domain index to return score-sorted rows. Instead, Oracle Text sorts the rows after all the rows that satisfy the <code class="codeph">CONTAINS</code> predicate are retrieved from the index: 
                     </p><pre class="oac_no_warn" dir="ltr">select /*+ FIRST_ROWS(10) DOMAIN_INDEX_NO_SORT */ pk, score(1), col from ctx_tab 
            where contains(txt_col, 'test', 1) &gt; 0 order by score(1) desc;</pre><div class="infoboxnotealso" id="GUID-04CD2DD4-F0F6-44E8-8243-F7D2FC2DCCDE__GUID-0B29664A-4BD4-493B-83BA-EA6037D57C6F">
                        <p class="notep1">See Also:</p>
                        <p> <a href="../tgsql/query-optimizer-concepts.html#TGSQL-GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for more information about the query optimizer and using hints such as <code class="codeph">FIRST_ROWS(n)</code> and <code class="codeph">CHOOSE</code></p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9245"></a><div class="props_rev_3"><a id="GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29" name="GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29"></a><h3 id="CCAPP-GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29" class="sect3"><span class="enumeration_section">7.4 </span>Composite Domain Index (CDI) in Oracle Text
               </h3>
               <div>
                  <p>The Composite Domain Index feature of the Extensibility Framework in Oracle Database enables structured columns to be indexed by Oracle Text. Therefore, both text and one or more structured criteria can be satisfied by one single Oracle Text index row source. Performance for the following types of query are improved:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Text query with structured criteria in the SQL <code class="codeph">WHERE</code> clause.
                        </p>
                     </li>
                     <li>
                        <p>Text query with structured <code class="codeph">ORDER</code> <code class="codeph">BY</code> criteria.
                        </p>
                     </li>
                     <li>
                        <p>Combination of both of the previous two query types.</p>
                     </li>
                  </ul>
                  <p>As with concatenated b-tree indexes or bitmap indexes, applications will experience slow-down in DML performance as the number of <code class="codeph">FILTER</code> <code class="codeph">BY</code> and <code class="codeph">ORDER</code> <code class="codeph">BY</code> columns increases. Where <code class="codeph">SCORE</code>-sort push-down is optimized for response time, the structured sort or combination of <code class="codeph">SCORE</code> and structured sort push-down are also optimized for response time, and not for throughput. However, using <code class="codeph">DOMAIN_INDEX_SORT</code> or <code class="codeph">FIRST_ROWS</code><code class="codeph">(n)</code> hints to force the sort to be pushed into CDI while fetching the entire hitlist may result in poor query response time.
                  </p>
               </div>
            </div><a id="CCAPP9513"></a><a id="CCAPP9246"></a><div class="props_rev_3"><a id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA" name="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA"></a><h3 id="CCAPP-GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA" class="sect3"><span class="enumeration_section">7.5 </span>Performance Tuning with CDI
               </h3>
               <div>
                  <p>Support for mapping a <code class="codeph">FILTER</code> <code class="codeph">BY</code> column to <code class="codeph">MDATA</code> enables query performance to be optimized for equality searches by restricting supported functionality of <code class="codeph">RANGE</code> and <code class="codeph">LIKE</code>. However, mapping a <code class="codeph">FILTER</code> <code class="codeph">BY</code> column to <code class="codeph">MDATA</code> is not recommended if the <code class="codeph">FILTER</code> <code class="codeph">BY</code> column contains sequential values, or has very high cardinality. Doing so can result in a very long and narrow <code class="codeph">$I</code> table and reduced <code class="codeph">$X</code> performance. One example of such a sequential column might be one that uses <code class="codeph">DATE</code> stamp. For such sequential columns, mapping to <code class="codeph">SDATA</code> is recommended.
                  </p>
                  <p>The following hints can be used to push or not push the <code class="codeph">SORT</code> and <code class="codeph">FILTER</code> <code class="codeph">BY</code> predicates into the CDI:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_SORT</code>. The query optimizer will try to push the applicable sorting criteria into the specified composite domain index.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_NO_SORT</code>. The query optimizer will try NOT to push sorting criteria into the specified composite domain index.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_FILTER</code>(<span class="italic">table name</span> <span class="italic">index name</span>). The query optimizer will try to push the applicable <code class="codeph">FILTER</code> <code class="codeph">BY</code> predicate(s) into the specified composite domain index.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_NO_FILTER</code>(<span class="italic">table name</span> <span class="italic">index name</span>). The query optimizer will not try to push the applicable <code class="codeph">FILTER</code> <code class="codeph">BY</code> predicate(s) into the specified composite domain index.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA__GUID-A07D0C51-E53C-4FE5-842A-EFDC900126AD">
                     <p class="notep1">Note:</p>
                     <p>The <code class="codeph">domain_index_filter</code> hint does not force the query optimizer to use CDI. Instead, if the cost-based optimizer chooses to use the CDI, then it should also push the filter predicate into the index. To force the query optimizer to choose CDI index, you additionally need to use the <code class="codeph">INDEX</code> hint.
                     </p>
                  </div>
                  <div class="example" id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA__GUID-C727C451-D842-423D-83BD-7F17AB4C3295">
                     <p class="titleinexample">Example 7-1 Performance Tuning a Text Query with CDI Hints</p>
                     <p>The following example performs an optimized query on the table <code class="codeph">books</code>.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT bookid, pub_date, source FROM
  (SELECT /*+ domain_index_sort domain_index_filter(books books_ctxcdi) */ bookid, pub_date, source
      FROM books
      WHERE CONTAINS(text, 'aaa',1)&gt;0 AND bookid &gt;= 80
      ORDER BY PUB_DATE desc nulls last, SOURCE asc  nulls last, score(1) desc)
 WHERE rownum &lt; 20;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="CCAPP9247"></a><div class="props_rev_3"><a id="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF" name="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF"></a><h3 id="CCAPP-GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF" class="sect3"><span class="enumeration_section">7.6 </span>Solving Index and Query Bottlenecks Using Tracing
               </h3>
               <div>
                  <p>Oracle Text includes a <span class="italic">tracing</span> facility that enables you to identify bottlenecks in indexing and querying.
                  </p>
                  <p>Oracle Text provides a set of predefined <span class="italic">traces</span>. Each trace is identified by a unique number. There is also a symbol in <code class="codeph">CTX_OUTPUT</code> for this number.
                  </p>
                  <p>Each trace measures a specific numeric quantity—for instance, the number of <code class="codeph">$I</code> rows selected during text queries. 
                  </p>
                  <p>Traces are cumulative counters, so usage is as follows:</p>
                  <ol>
                     <li>
                        <p>The user enables a trace.</p>
                     </li>
                     <li>
                        <p>The user performs one or more operations. Oracle Text measures activities and accumulates the results in the trace.</p>
                     </li>
                     <li>
                        <p>The user retrieves the trace value, which is the total value across all operations done in step 2.</p>
                     </li>
                     <li>
                        <p>The user resets the trace to 0.</p>
                     </li>
                     <li>
                        <p>The user starts over at Step 2.</p>
                     </li>
                  </ol>
                  <p>So, for instance, if in step 2 the user runs two queries, and query 1 selects 15 rows from <code class="codeph">$I</code>, and query 2 selects 17 rows from <code class="codeph">$I</code>, then in step 3 the value of the trace would be 32 (15 + 17).
                  </p>
                  <p>Traces are associated with a session—they can measure operations that take place within a single session, and, conversely, cannot make measurements across sessions.</p>
                  <p>During parallel sync or optimize, the trace profile will be copied to the slave sessions if and only if tracing is currently enabled. Each slave will accumulate its own traces and implicitly write all trace values to the slave logfile before termination.</p>
                  <div class="infoboxnotealso" id="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF__GUID-4E830C0B-461E-44DD-AB0E-FF5F0AEB006B">
                     <p class="notep1">See Also:</p>
                     <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
               </div>
            </div><a id="CCAPP9248"></a><div class="props_rev_3"><a id="GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A" name="GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A"></a><h3 id="CCAPP-GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A" class="sect3"><span class="enumeration_section">7.7 </span>Using Parallel Queries
               </h3>
               <div>
                  <p>In general, parallel queries are optimal for DSS, OLAP, or analytical systems with large data collection, multiple CPUs with a low number of concurrent users, or <a id="d26985e2683" class="indexterm-anchor"></a><a id="d26985e2687" class="indexterm-anchor"></a>parallelized across Oracle Real Application Clusters (Oracle RAC) nodes.
                  </p>
                  <p>Oracle Text supports parallel queries as follows:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018">Parallel Queries on a Local Context Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C">Parallelizing Queries Across Oracle RAC Nodes</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9249"></a><div class="props_rev_3"><a id="GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018" name="GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018"></a><h4 id="CCAPP-GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018" class="sect4"><span class="enumeration_section">7.7.1 </span>Parallel Queries on a Local Context Index
                  </h4>
                  <div>
                     <p><span class="italic">Parallel query</span> refers to the parallelized processing of a local <code class="codeph">CONTEXT</code> index. Based on the parallel degree of the index and various system attributes, Oracle determines the number of parallel query slaves to be spawned to process the index. Each parallel query slave processes one or more index partitions. This is the default query behavior for local indexes created in parallel.
                     </p>
                     <p>However, for heavily loaded systems with high numbers of concurrent users, query throughput will generally be worse with parallel query because top-N hits can usually be satisfied by the first few partitions, if the query is run serially. For example, typical top-N text queries with an <code class="codeph">ORDER</code> <code class="codeph">BY</code> partition key column, such as:
                     </p><pre class="oac_no_warn" dir="ltr">select * from (
        select story_id from stories_tab where contains(...)&gt;0 order by 
publication_date desc)
    where rownum &lt;= 10;
</pre><p>will generally perform <span class="italic">worse</span> with a parallel query.
                     </p>
                     <p>You can disable parallel querying after a parallel index operation with an <code class="codeph">ALTER INDEX</code> statement as follows:
                     </p><pre class="oac_no_warn" dir="ltr">Alter index &lt;text index name&gt; NOPARALLEL;
Alter index &lt;text index name&gt; PARALLEL 1;
</pre><p>You can also enable or increase the parallel degree by specifying:</p><pre class="oac_no_warn" dir="ltr">Alter index &lt;text index name&gt; parallel &lt; parallel degree &gt;;</pre></div>
               </div><a id="CCAPP9471"></a><div class="props_rev_3"><a id="GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C" name="GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C"></a><h4 id="CCAPP-GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C" class="sect4"><span class="enumeration_section">7.7.2 </span>Parallelizing Queries Across Oracle RAC Nodes
                  </h4>
                  <div>
                     <p>Oracle Real Application Clusters (Oracle RAC) provides an excellent solution for improving query throughput. If you can get good performance from Oracle Text with a light query load, then you can expect to get excellent scalability from Oracle RAC as the query load increases.</p>
                     <p>Further improvements in Oracle Text performance in an Oracle RAC environment may be achieved by physically partitioning the text data and text indexes (using local partitioned indexes), and ensuring that partitions are handled by separate Oracle RAC nodes. This way, you avoid duplication of the cache contents across multiple nodes and, therefore, maximize the benefit of Oracle RAC cache fusion.</p>
                     <p>In Oracle 10g Release 1, each Oracle Text index partition must be forced into a separate database file when the index is created. This enables the use of the "re-mastering" feature in Oracle RAC to force database file affinity, in which each node concentrates on a particular database file and, therefore, a particular Oracle Text index partition.</p>
                     <p>In Oracle 10<span class="italic">g</span> Release 2 and forward, Oracle supports database object-level affinity, which makes it much easier to allocate index objects (<code class="codeph">$I</code> and <code class="codeph">$R</code> tables) to particular nodes.
                     </p>
                     <p>While Oracle RAC offers solutions for improving query throughput and performance, is not a "magic bullet," and it will not necessarily enable you to continue to get the same performance improvements as you scale up the data volumes. You are more likely to see improvements by increasing the amounts of memory available to the SGA cache, or by partitioning your data in such a way that queries will normally not need to hit all of the partitions of a table in order to provide the required set of query results.</p>
                  </div>
               </div>
            </div><a id="CCAPP9251"></a><div class="props_rev_3"><a id="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8" name="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8"></a><h3 id="CCAPP-GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8" class="sect3"><span class="enumeration_section">7.8 </span>Tuning Queries with Blocking Operations
               </h3>
               <div>
                  <p>Issuing a query with more than one predicate can cause a blocking operation in the execution plan. For example, consider the following mixed query:</p><pre class="oac_no_warn" dir="ltr">select docid from mytab where contains(text, 'oracle', 1) &gt; 0 
  AND colA &gt; 5 
  AND colB &gt; 1 
  AND colC &gt; 3; 
</pre><p>Assume that all predicates are unselective and colA, colB, and colC have bitmap indexes. The cost-based optimizer in Oracle Database chooses the following execution plan:</p><pre class="oac_no_warn" dir="ltr">TABLE ACCESS BY ROWIDS
  BITMAP CONVERSION TO ROWIDS
    BITMAP AND
      BITMAP INDEX COLA_BMX
      BITMAP INDEX COLB_BMX
      BITMAP INDEX COLC_BMX
      BITMAP CONVERSION FROM ROWIDS
        SORT ORDER BY
          DOMAIN INDEX MYINDEX
</pre><p>Because the <code class="codeph">BITMAP</code> <code class="codeph">AND</code> is a blocking operation, Oracle Text must temporarily save the rowid and score pairs returned from the Oracle Text domain index before running the <code class="codeph">BITMAP</code> <code class="codeph">AND</code> operation.
                  </p>
                  <p>Oracle Text attempts to save these rowid and score pairs in memory. However, when the size of the result set containing these rowid and score pairs exceeds the <code class="codeph">SORT_AREA_SIZE</code> initialization parameter, Oracle Text spills these results to temporary segments on disk.
                  </p>
                  <p>Because saving results to disk causes extra overhead, you can improve performance by increasing the <code class="codeph">SORT_AREA_SIZE</code> parameter using <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> as follows:
                  </p><pre class="oac_no_warn" dir="ltr">alter session set SORT_AREA_SIZE = &lt;new memory size in bytes&gt;;
</pre><p>For example, to set the buffer to approximately 8 megabytes, enter:</p><pre class="oac_no_warn" dir="ltr">alter session set SORT_AREA_SIZE = 8300000;</pre><div class="infoboxnotealso" id="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8__GUID-80052CB4-1040-4D63-8C76-F09014CE5458">
                     <p class="notep1">See Also:</p>
                     <p><a href="../tgdba/managing-operating-system-resources.html#TGDBA-GUID-1C9C8D2D-AEB3-46C8-94D3-0BF24551870E"><span class="italic">Oracle Database Performance Tuning Guide</span></a> and <a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7"><span class="italic">Oracle Database Reference</span></a> for more information on <code class="codeph">SORT_AREA_SIZE</code></p>
                  </div>
               </div>
            </div><a id="CCAPP9252"></a><div class="props_rev_3"><a id="GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3" name="GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3"></a><h3 id="CCAPP-GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3" class="sect3"><span class="enumeration_section">7.9 </span>Frequently Asked Questions About Query Performance
               </h3>
               <div>
                  <p>This section answers some of the frequently asked questions about query performance. </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE">What is Query Performance?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-124913E6-83D6-4525-8856-2EF87B32FD8F">What is the fastest type of text query?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9896CBA2-946B-4202-952F-A891DA944DF9">Should I collect statistics on my tables?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-461B30DE-424D-40D8-A25F-5EF08A24D670">How does the size of my data affect queries?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8">How does the format of my data affect queries?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BAC89AA2-829C-4A96-8266-85960EE837E4">What is a functional versus an indexed lookup?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7">What tables are involved in queries?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3">How is $R contention reduced?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A">Does sorting the results slow a text-only query?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1">How do I make an ORDER BY score query faster?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD">Which memory settings affect querying?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B">Does out-of-line LOB storage of wide base table columns improve performance?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5">How can I make a CONTAINS query on more than one column faster?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502">Is it OK to have many expansions in a query?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8">How can local partition indexes help?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-D278E686-664A-4083-AF02-F3F27DE973E1">Should I query in parallel?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906">Should I index themes?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F">When should I use a CTXCAT index?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375">When is a CTXCAT index NOT suitable?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9">What optimizer hints are available, and what do they do?</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9253"></a><div class="props_rev_3"><a id="GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE" name="GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE"></a><h4 id="CCAPP-GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE" class="sect4"><span class="enumeration_section">7.9.1 </span>What is Query Performance?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> There are generally two measures of query performance:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Response time, the time to get an answer to an individual query, and </p>
                        </li>
                        <li>
                           <p>Throughput, the number of queries that can be run in any time period; for example, queries each second.</p>
                        </li>
                     </ul>
                     <p>These two are related, but are not the same. In a heavily loaded system, you normally want maximum throughput, whereas in a relatively lightly loaded system, you probably want minimum response time. Also, some applications require a query to deliver all its hits to the user, whereas others might only require the first 20 hits from an ordered set. It is important to distinguish between these two scenarios. </p>
                  </div>
               </div><a id="CCAPP9254"></a><div class="props_rev_3"><a id="GUID-124913E6-83D6-4525-8856-2EF87B32FD8F" name="GUID-124913E6-83D6-4525-8856-2EF87B32FD8F"></a><h4 id="CCAPP-GUID-124913E6-83D6-4525-8856-2EF87B32FD8F" class="sect4"><span class="enumeration_section">7.9.2 </span>What is the fastest type of text query?
                  </h4>
                  <div>
                     <p><span class="bold">Answer: </span>The fastest type of query will meet the following conditions: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Single <code class="codeph">CONTAINS</code> clause 
                           </p>
                        </li>
                        <li>
                           <p>No other conditions in the <code class="codeph">WHERE</code> clause 
                           </p>
                        </li>
                        <li>
                           <p>No <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause at all
                           </p>
                        </li>
                        <li>
                           <p>Only the first page of results is returned (for example, the first 10 or 20 hits). </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9255"></a><div class="props_rev_3"><a id="GUID-9896CBA2-946B-4202-952F-A891DA944DF9" name="GUID-9896CBA2-946B-4202-952F-A891DA944DF9"></a><h4 id="CCAPP-GUID-9896CBA2-946B-4202-952F-A891DA944DF9" class="sect4"><span class="enumeration_section">7.9.3 </span>Should I collect statistics on my tables?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Yes. Collecting statistics on your tables enables Oracle Text to do cost-based analysis. This helps Oracle Text choose the most efficient execution plan for your queries. 
                     </p>
                     <p>If your queries are always pure text queries (no structured predicate and no joins), you should delete statistics on your Oracle Text index.</p>
                  </div>
               </div><a id="CCAPP9256"></a><div class="props_rev_3"><a id="GUID-461B30DE-424D-40D8-A25F-5EF08A24D670" name="GUID-461B30DE-424D-40D8-A25F-5EF08A24D670"></a><h4 id="CCAPP-GUID-461B30DE-424D-40D8-A25F-5EF08A24D670" class="sect4"><span class="enumeration_section">7.9.4 </span>How does the size of my data affect queries?
                  </h4>
                  <div>
                     <p><span class="bold">Answer: </span>The speed at which the text index can deliver ROWIDs is not affected by the actual size of the data. Text query speed will be related to the number of rows that must be fetched from the index table, number of hits requested, number of hits produced by the query, and the presence or absence of sorting. 
                     </p>
                  </div>
               </div><a id="CCAPP9257"></a><div class="props_rev_3"><a id="GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8" name="GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8"></a><h4 id="CCAPP-GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8" class="sect4"><span class="enumeration_section">7.9.5 </span>How does the format of my data affect queries?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The format of the documents (plain ASCII text, HTML or Microsoft Word) should make no difference to query speed. The documents are filtered to plain text at indexing time, not query time. 
                     </p>
                     <p>The cleanliness of the data will make a difference. Spell-checked and sub-edited text for publication tends to have a much smaller total vocabulary (and therefore size of the index table) than informal text such as e-mails, which will contain many spelling errors and abbreviations. For a given index memory setting, the extra text takes up more memory, which can lead to more fragmented rows than in the cleaner text, which can adversely affect query response time. </p>
                  </div>
               </div><a id="CCAPP9258"></a><div class="props_rev_3"><a id="GUID-BAC89AA2-829C-4A96-8266-85960EE837E4" name="GUID-BAC89AA2-829C-4A96-8266-85960EE837E4"></a><h4 id="CCAPP-GUID-BAC89AA2-829C-4A96-8266-85960EE837E4" class="sect4"><span class="enumeration_section">7.9.6 </span>What is a <span class="italic">functional</span> versus an <span class="italic">indexed</span> lookup?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> There are two ways the kernel can query the text index. In the first and most common case, the kernel asks the text index for all the rowids that satisfy a particular text search. These rowids are returned in batches. In the second, the kernel passes individual rowids to the text index, and asks whether that particular rowid satisfies a certain text criterion. 
                     </p>
                     <p>The second is known as a functional lookup, and is most commonly done where there is a very selective structured clause, so that only a few rowids must be checked against the text index. An example of a search where a functional lookup may be used: </p><pre class="oac_no_warn" dir="ltr">SELECT ID, SCORE(1), TEXT FROM MYTABLE</pre><pre class="oac_no_warn" dir="ltr">WHERE START_DATE = '21 Oct 1992'         &lt;- highly selective
AND CONTAINS (TEXT, 'commonword') &gt; 0    &lt;- unselective
</pre><p>Functional invocation is also used for text query ordered by structured column (for example date, price) and text query is unselective.</p>
                  </div>
               </div><a id="CCAPP9259"></a><div class="props_rev_3"><a id="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7" name="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7"></a><h4 id="CCAPP-GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7" class="sect4"><span class="enumeration_section">7.9.7 </span>What tables are involved in queries?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> All queries look at the index token table. Its name has the form <code class="codeph">DR$indexname$I</code>. This table contains the list of tokens (column <code class="codeph">TOKEN_TEXT</code>) and the information about the row and word positions where the token occurs (column <code class="codeph">TOKEN_INFO</code>). 
                     </p>
                     <p>The row information is stored as internal DOCID values. These must be translated into external ROWID values. The table used for this depends on the type of lookup: For functional lookups, the <code class="codeph">$K</code> table, <code class="codeph">DR$indexname$K</code>, is used. This is a simple Index Organized Table (IOT) which contains a row for each DOCID/ROWID pair. 
                     </p>
                     <p>For indexed lookups, the <code class="codeph">$R</code> table, <code class="codeph">DR$indexname$R</code>, is used. This holds the complete list of ROWIDs in a BLOB column.
                     </p>
                     <p>Starting with Oracle Database 12<span class="italic">c</span> Release 2 (12.2), a new storage attribute, <code class="codeph">SMALL_R_ROW</code> is introduced to reduce the size of <code class="codeph">$R</code> row. It populates <code class="codeph">$R</code> rows on demand instead of creating 22 static rows, thereby reducing the DML contention. The contention happens when parallel DML processes try to lock the same <code class="codeph">$R</code> row for insert or delete operations. 
                     </p>
                     <p>Hence, we can easily find out whether a functional or indexed lookup is being used by examining a SQL trace, and looking for the $K or $R tables.</p>
                     <div class="infoboxnote" id="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7__GUID-8BD69135-5AA9-4FE5-AB2C-E11D0DA0B729">
                        <p class="notep1">Note:</p>
                        <p>These internal index tables are subject to change from release to release. Oracle recommends that you do not directly access these tables in your application.</p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3" name="GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3"></a><h4 id="CCAPP-GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3" class="sect4"><span class="enumeration_section">7.9.8 </span>How is $R table contention reduced?
                  </h4>
                  <div>
                     <div class="p"><code class="codeph">$R</code> contention during base table delete and update operations has become a recurring theme over the past few years. Currently, each <code class="codeph">$R</code> index table has 22 static rows, and each row can contain up to 200 million rowids. The contention happens when the parallel DML processes try to lock the same <code class="codeph">$R</code> row for insert or delete operations. The following enhancements made during this release reduce the contention:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The maximum number of rowids that each <code class="codeph">$R</code> row can contain is 70,000 which translates to 1MB of data stored on each row. You must set the <code class="codeph">SMALL_R_ROW</code> storage attribute to use this feature.
                              </p>
                           </li>
                           <li>
                              <p>The $R rows are created on demand now instead of just populating a pre-determined number of rows. </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9260"></a><div class="props_rev_3"><a id="GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A" name="GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A"></a><h4 id="CCAPP-GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A" class="sect4"><span class="enumeration_section">7.9.9 </span>Does sorting the results slow a text-only query?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Yes, it certainly does. 
                     </p>
                     <p>If there is no sorting, then Oracle Text can return results as it finds them, which is quicker in the common case where the application needs to display only a page of results at a time. </p>
                  </div>
               </div><a id="CCAPP9261"></a><div class="props_rev_3"><a id="GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1" name="GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1"></a><h4 id="CCAPP-GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1" class="sect4"><span class="enumeration_section">7.9.10 </span>How do I make an ORDER BY score query faster?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Sorting by relevance (<code class="codeph">SCORE(n)</code>) can be extremely quick if the <code class="codeph">FIRST_ROWS(n)</code> hint is used. In this case, Oracle Text performs a high speed internal sort when fetching from the text index tables. 
                     </p>
                     <p>An example of such a query: </p><pre class="oac_no_warn" dir="ltr">              SELECT /*+ FIRST_ROWS(10) */ ID, SCORE(1), TEXT FROM mytable
                WHERE CONTAINS (TEXT, 'searchterm', 1) &gt; 0
                ORDER BY SCORE(1) DESC;
</pre><p>Note that for this to work efficiently, there must be no other criteria in the <code class="codeph">WHERE</code> clause other than a single <code class="codeph">CONTAINS</code>. 
                     </p>
                  </div>
               </div><a id="CCAPP9262"></a><div class="props_rev_3"><a id="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD" name="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD"></a><h4 id="CCAPP-GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD" class="sect4"><span class="enumeration_section">7.9.11 </span>Which memory settings affect querying?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> For querying, you want to strive for a large system global area (SGA). You can set these parameters related to SGA in your Oracle Database initialization file. You can also set these parameters dynamically. 
                     </p>
                     <p>The <code class="codeph">SORT_AREA_SIZE</code> parameter controls the memory available for sorting for <code class="codeph">ORDER BY</code> queries. You should increase the size of this parameter if you frequently order by structured columns.
                     </p>
                     <div class="infoboxnotealso" id="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD__GUID-A7175F29-6BD8-4A4F-9D2C-4DA29B181E06">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN-GUID-BEABE53D-8058-4834-B99B-5C80A8AD5B06"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on setting SGA related parameters
                              </p>
                           </li>
                           <li>
                              <p><a href="../tgdba/database-memory-allocation.html#TGDBA-GUID-E9265077-B296-485A-BC2C-0AF55762D1EC"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information on memory allocation
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7"><span class="italic">Oracle Database Reference</span></a> for more information on setting the <code class="codeph">SORT_AREA_SIZE</code> parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9263"></a><div class="props_rev_3"><a id="GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B" name="GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B"></a><h4 id="CCAPP-GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B" class="sect4"><span class="enumeration_section">7.9.12 </span>Does out-of-line LOB storage of wide base table columns improve performance?
                  </h4>
                  <div>
                     <p><span class="bold">Answer: </span>Yes. Typically, a <code class="codeph">SELECT</code> statement selects more than one column from your base table. Because Oracle Text fetches columns to memory, it is more efficient to store wide base table columns such as LOBs out of line, especially when these columns are rarely updated but frequently selected. 
                     </p>
                     <p>When LOBs are stored out of line, only the LOB locators need to be fetched to memory during querying. Out of line storage reduces the effective size of the base table making it easier for Oracle Text to cache the entire table to memory. This reduces the cost of selecting columns from the base table, and hence speeds up text queries.</p>
                     <p>In addition, having smaller base tables cached in memory enables more index table data to be cached during querying, which improves performance.</p>
                  </div>
               </div><a id="CCAPP9264"></a><div class="props_rev_3"><a id="GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5" name="GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5"></a><h4 id="CCAPP-GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5" class="sect4"><span class="enumeration_section">7.9.13 </span>How can I make a CONTAINS query on more than one column faster?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The fastest type of query is one where there is only a single <code class="codeph">CONTAINS</code> clause, and no other conditions in the <code class="codeph">WHERE</code> clause. 
                     </p>
                     <p>Consider the following multiple <code class="codeph">CONTAINS</code> query: 
                     </p><pre class="oac_no_warn" dir="ltr">              SELECT title, isbn FROM booklist
                WHERE CONTAINS (title, 'horse') &gt; 0
                  AND CONTAINS (abstract, 'racing') &gt; 0
</pre><p>We can obtain the same result with section searching and the <code class="codeph">WITHIN</code> operator as follows:
                     </p><pre class="oac_no_warn" dir="ltr">              SELECT title, isbn FROM booklist
                WHERE CONTAINS (alltext, 
                  'horse WITHIN title AND racing WITHIN abstract')&gt;0
</pre><p>This query completes more quickly. To use a query like this, we must copy all the data into a single text column for indexing, with section tags around each column's data. This can be done with PL/SQL procedures before indexing, or by making use of the <code class="codeph">USER_DATASTORE</code> datastore during indexing to synthesize structured columns with the text column into one document. 
                     </p>
                  </div>
               </div><a id="CCAPP9265"></a><div class="props_rev_3"><a id="GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502" name="GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502"></a><h4 id="CCAPP-GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502" class="sect4"><span class="enumeration_section">7.9.14 </span>Is it OK to have many expansions in a query?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Each distinct word used in a query requires at least one row to be fetched from the index table. It is therefore best to keep the number of expansions down as much as possible. 
                     </p>
                     <p>You should not use expansions such as wild cards, thesaurus, stemming and fuzzy matching unless they are necessary to the task. In general, a few expansions (for example, 10 to 20) does not cause difficulty, but avoid having large numbers of explansions (80 or 100) in a query. The query feedback mechanism can be used to determine the number of expansions for any particular query expression.</p>
                     <p>In addition for wildcard and stem queries, you can remove the cost of term expansion from query time to index time by creating prefix, substring or stem indexes. Query performance increases at the cost of longer indexing time and added disk space. </p>
                     <p>Prefix and substring indexes can improve wildcard performance. You enable prefix and substring indexing with the <code class="codeph">BASIC_WORDLIST</code> preference. The following example sets the wordlist preference for prefix and substring indexing. For prefix indexing, it specifies that Oracle Text create token prefixes between 3 and 4 characters long:
                     </p><pre class="oac_no_warn" dir="ltr">begin </pre><pre class="oac_no_warn" dir="ltr">ctx_ddl.create_preference('mywordlist', 'BASIC_WORDLIST'); 
ctx_ddl.set_attribute('mywordlist','PREFIX_INDEX','TRUE');
ctx_ddl.set_attribute('mywordlist','PREFIX_MIN_LENGTH', '3');
ctx_ddl.set_attribute('mywordlist','PREFIX_MAX_LENGTH', '4');
ctx_ddl.set_attribute('mywordlist','SUBSTRING_INDEX', 'YES');</pre><pre class="oac_no_warn" dir="ltr">end</pre><p></p>
                     <p>You enable stem indexing with the <code class="codeph">BASIC_LEXER</code> preference:
                     </p><pre class="oac_no_warn" dir="ltr">begin</pre><pre class="oac_no_warn" dir="ltr">ctx_ddl.create_preference('mylex', 'BASIC_LEXER');
ctx_ddl.set_attribute ( 'mylex', 'index_stems', 'ENGLISH');</pre><pre class="oac_no_warn" dir="ltr">end;</pre></div>
               </div><a id="CCAPP9266"></a><div class="props_rev_3"><a id="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8" name="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8"></a><h4 id="CCAPP-GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8" class="sect4"><span class="enumeration_section">7.9.15 </span>How can local partition indexes help?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can create local partitioned <code class="codeph">CONTEXT</code> indexes on partitioned tables. This means that on a partitioned table, each partition has its own set of index tables. Effectively, there are multiple indexes, but the results from each are combined as necessary to produce the final result set. 
                     </p>
                     <p>The index is created using the <code class="codeph">LOCAL</code> keyword: 
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name (column_name) 
INDEXTYPE IS ctxsys.context
PARAMETERS ('...')
LOCAL
</pre><p>With partitioned tables and local indexes, you can improve performance of the following types of <code class="codeph">CONTAINS</code> queries:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="tuning-oracle-text.html#GUID-11DC7D61-E6FB-4775-8427-8DF0C462CBEF">Range Search on Partition Key Column</a></p>
                           <p>This is a query that restricts the search to a particular range of values on a column that is also the partition key.</p>
                        </li>
                        <li>
                           <p><a href="tuning-oracle-text.html#GUID-DAA9ED42-32AE-4DD8-B1A8-2E1F04136399">ORDER BY Partition Key Column</a> 
                           </p>
                           <p>This is a query that requires only the first <code class="codeph">n</code> hits and the <code class="codeph">ORDER BY</code> clause names the partition key
                           </p>
                           <div class="infoboxnotealso" id="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8__GUID-DBF5C15E-932A-44E2-8C04-55EA59A9B0EE">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="tuning-oracle-text.html#GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370">Improved Response Time using Local Partitioned CONTEXT Index</a>"</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9267"></a><div class="props_rev_3"><a id="GUID-D278E686-664A-4083-AF02-F3F27DE973E1" name="GUID-D278E686-664A-4083-AF02-F3F27DE973E1"></a><h4 id="CCAPP-GUID-D278E686-664A-4083-AF02-F3F27DE973E1" class="sect4"><span class="enumeration_section">7.9.16 </span>Should I query in parallel?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> It depends on system load and server capacity. Even though parallel querying is the default behavior for indexes created in parallel, it usually results in degrading overall query throughput on heavily loaded systems.
                     </p>
                     <p>In general, parallel queries are particularly appropriate for DSS or analytical systems with large data collections, multiple CPUs, and low number of concurrent users.</p>
                     <div class="infoboxnotealso" id="GUID-D278E686-664A-4083-AF02-F3F27DE973E1__GUID-E7D43ECB-6788-49A4-8412-19C31BCCD9AF">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="tuning-oracle-text.html#GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A">Using Parallel Queries</a>"</span></p>
                     </div>
                  </div>
               </div><a id="CCAPP9268"></a><div class="props_rev_3"><a id="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906" name="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906"></a><h4 id="CCAPP-GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906" class="sect4"><span class="enumeration_section">7.9.17 </span>Should I index themes?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Indexing theme information with a <code class="codeph">CONTEXT</code> index takes longer and also increases the size of your index. However, theme indexes enable <code class="codeph">ABOUT</code> queries to be more precise by using the knowledge base. If your application uses <code class="codeph">ABOUT</code> queries heavily, it might be worthwhile to create a theme component to the index, despite the extra indexing time and extra storage space required.
                     </p>
                     <div class="infoboxnotealso" id="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906__GUID-6FBB9B06-ACD1-46E9-9B5F-568868F40775">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="querying-with-oracle-text.html#GUID-E3ED0880-E919-43BE-BC10-1837D76F0E8F">ABOUT Queries and Themes</a>"</span></p>
                     </div>
                  </div>
               </div><a id="CCAPP9269"></a><div class="props_rev_3"><a id="GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F" name="GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F"></a><h4 id="CCAPP-GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F" class="sect4"><span class="enumeration_section">7.9.18 </span>When should I use a CTXCAT index?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> <code class="codeph">CTXCAT</code> indexes work best when text is in small chunks, maybe a few lines maximum, and searches need to restrict or sort the result set according to certain structured criteria, usually numbers or dates. 
                     </p>
                     <p>For example, consider an on-line auction site. Each item for sale has a short description, a current bid price, and dates for the start and end of the auction. A user might want to see all the records with <span class="italic">antique cabinet</span> in the description, with a current bid price less than $500. Because he is particularly interested in newly posted items, he wants the results sorted by auction start time. 
                     </p>
                     <p>Such a search is not always efficient with a <code class="codeph">CONTAINS</code> structured query on a <code class="codeph">CONTEXT</code> index, where the response time can vary significantly depending on the structured and <code class="codeph">CONTAINS</code> clauses. This is because the intersection of structured and <code class="codeph">CONTAINS</code> clauses or the ordering of text query is computed during query time.
                     </p>
                     <p>By including structured information such as price and date within the <code class="codeph">CTXCAT</code> index, query response time is always in an optimal range regardless of search criteria. This is because the interaction between text and structured query is pre-computed during indexing. Consequently query response time is optimum.
                     </p>
                  </div>
               </div><a id="CCAPP9270"></a><div class="props_rev_3"><a id="GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375" name="GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375"></a><h4 id="CCAPP-GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375" class="sect4"><span class="enumeration_section">7.9.19 </span>When is a CTXCAT index NOT suitable?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> There are differences in the time and space needed to create the index. <code class="codeph">CTXCAT</code> indexes take a bit longer to create and use considerably more disk space than <code class="codeph">CONTEXT</code> indexes. If you are tight on disk space, you should consider carefully whether <code class="codeph">CTXCAT</code> indexes are appropriate for you.
                     </p>
                     <p>With respect to query operators, you can now use the richer <code class="codeph">CONTEXT</code> grammar in <code class="codeph">CATSEARCH</code> queries with query templates. The older restriction of a single <code class="codeph">CATSEARCH</code> query grammar no longer holds.
                     </p>
                  </div>
               </div><a id="CCAPP9271"></a><div class="props_rev_3"><a id="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9" name="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9"></a><h4 id="CCAPP-GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9" class="sect4"><span class="enumeration_section">7.9.20 </span>What optimizer hints are available, and what do they do?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The optimizer hint <code class="codeph">INDEX(table column) </code>can be used in the usual way to drive the query with a text or b-tree index. 
                     </p>
                     <p>You can also use the <code class="codeph">NO_INDEX(table column)</code> hint to disable a specific index.
                     </p>
                     <p>Additionally, the <code class="codeph">FIRST_ROWS(n)</code> hint has a special meaning for text queries and should be used when you need the first <code class="codeph">n</code> hits to a query. Use of the <code class="codeph">DOMAIN_INDEX_SORT</code> hint in conjunction with <code class="codeph">ORDER BY SCORE(n) DESC</code> tells the Oracle optimizer to accept a sorted set from the text index, and not to do a further sort.
                     </p>
                     <div class="infoboxnotealso" id="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9__GUID-8288AFDF-74A9-407C-B349-9A322DAA1274">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="tuning-oracle-text.html#GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D">Optimizing Queries for Response Time</a>"</span></p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9272"></a><div class="props_rev_3"><a id="GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9" name="GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9"></a><h3 id="CCAPP-GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9" class="sect3"><span class="enumeration_section">7.10 </span>Frequently Asked Questions About Indexing Performance
               </h3>
               <div>
                  <p>This section answers some of the frequently asked questions about indexing performance. </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1">How long should indexing take?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BBF8E750-E6C9-4149-AB88-8403EC583536">Which index memory settings should I use?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4">How much disk overhead will indexing require?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-24EF49DB-AFFB-499C-BC57-000941C6833F">How does the format of my data affect indexing?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5">Can parallel indexing improve performance?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561">How can I improve index performance for creating local partitioned index?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF">How can I tell how much indexing has completed?</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9273"></a><div class="props_rev_3"><a id="GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1" name="GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1"></a><h4 id="CCAPP-GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1" class="sect4"><span class="enumeration_section">7.10.1 </span>How long should indexing take?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Indexing text is a resource-intensive process. The speed of indexing will depend on the power of the hardware involved. Indexing speed depends on CPU and I/O capacity.  Given sufficient I/O capacity to read in the original data and write out index entries, then CPU will be the limiting factor.
                     </p>
                     <p>Tests with Intel x86 (Core 2 architecture, 2.5GHz)  CPUs have shown that Oracle Text can index around 100GB of text per CPU core, per day. This would be expected to increase as CPU clock speeds increase and/or CPU architectures become more efficient.</p>
                     <p>Other factors such as your document format, location of your data, and the calls to user-defined datastores, filters, and lexers can have an impact on your indexing speed. </p>
                  </div>
               </div><a id="CCAPP9274"></a><div class="props_rev_3"><a id="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536" name="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536"></a><h4 id="CCAPP-GUID-BBF8E750-E6C9-4149-AB88-8403EC583536" class="sect4"><span class="enumeration_section">7.10.2 </span>Which index memory settings should I use?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can set your index memory with the system parameters <code class="codeph">DEFAULT_INDEX_MEMORY</code> and <code class="codeph">MAX_INDEX_MEMORY</code>. You can also set your index memory at run time with the <code class="codeph">CREATE INDEX</code> <code class="codeph">memory</code> parameter in the parameter string.
                     </p>
                     <p>You should aim to set the <code class="codeph">DEFAULT_INDEX_MEMORY</code> value as high as possible, without causing paging. 
                     </p>
                     <p>You can also improve Indexing performance by increasing the <code class="codeph">SORT_AREA_SIZE</code> system parameter.
                     </p>
                     <p>Oracle recommends that you use a large index memory setting. Large settings, even up to hundreds of megabytes, can improve the speed of indexing, and reduce the fragmentation of the final indexes. However, if you set the index memory setting too high, then memory paging can occur that will reduce indexing speed.</p>
                     <p>With parallel indexing, each stream requires its own index memory. When dealing with very large tables, you can tune your database system global area (SGA) differently for indexing and retrieval. For querying, you want to get as much information cached in the system global area's (SGA) block buffer cache as possible. So you should allocate a large amount of memory to the block buffer cache. But this will not make any difference to indexing, so you would be better off reducing the size of the SGA to make more room for a large index memory settings during indexing.</p>
                     <p>You set the size of SGA in your Oracle Database initialization file.</p>
                     <div class="infoboxnotealso" id="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536__GUID-D9908D9A-EBDC-4258-A538-AED03646C7B4">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0245"><span class="italic">Oracle Text Reference</span></a> to learn more about Oracle Text system parameters
                              </p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN-GUID-BEABE53D-8058-4834-B99B-5C80A8AD5B06"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on setting SGA related parameters
                              </p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/12.2/ccapp&amp;id=TGDBA-GUID-E9265077-B296-485A-BC2C-0AF55762D1EC"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information on memory allocation
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7"><span class="italic">Oracle Database Reference</span></a> for more information on setting the <code class="codeph">SORT_AREA_SIZE</code> parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9275"></a><div class="props_rev_3"><a id="GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4" name="GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4"></a><h4 id="CCAPP-GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4" class="sect4"><span class="enumeration_section">7.10.3 </span>How much disk overhead will indexing require?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The overhead, the amount of space needed for the index tables, varies between about 50% of the original text volume and 200%. Generally, the larger the total amount of text, the smaller the overhead, but many small records will use more overhead than fewer large records. Also, clean data (such as published text) will require less overhead than dirty data such as e-mails or discussion notes, because the dirty data is likely to include many unique words from mis-spellings and abbreviations.
                     </p>
                     <p>A text-only index is smaller than a combined text and theme index. A prefix and substring index makes the index significantly larger.</p>
                  </div>
               </div><a id="CCAPP9276"></a><div class="props_rev_3"><a id="GUID-24EF49DB-AFFB-499C-BC57-000941C6833F" name="GUID-24EF49DB-AFFB-499C-BC57-000941C6833F"></a><h4 id="CCAPP-GUID-24EF49DB-AFFB-499C-BC57-000941C6833F" class="sect4"><span class="enumeration_section">7.10.4 </span>How does the format of my data affect indexing?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can expect much lower storage overhead for formatted documents such as Microsoft Word files because such documents tend to be very large compared to the actual text held in them. So 1GB of Word documents might only require 50MB of index space, whereas 1GB of plain text might require 500MB, because there is ten times as much plain text in the latter set. 
                     </p>
                     <p>Indexing time is less clear-cut. Although the reduction in the amount of text to be indexed will have an obvious effect, you must balance this out against the cost of filtering the documents with the <code class="codeph">AUTO_FILTER</code> filter or other user-defined filters.
                     </p>
                  </div>
               </div><a id="CCAPP9277"></a><div class="props_rev_3"><a id="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5" name="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5"></a><h4 id="CCAPP-GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5" class="sect4"><span class="enumeration_section">7.10.5 </span>Can parallel indexing improve performance?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Parallel indexing can improve index performance when you have a large amount of data, and have multiple CPUs.
                     </p>
                     <p>You use the <code class="codeph">PARALLEL</code> keyword when creating the index: 
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name (column_name) 
INDEXTYPE IS ctxsys.context PARAMETERS ('...') PARALLEL 3;
</pre><p>This will create the index with up to three separate indexing processes depending on your resources. </p>
                     <p>Parallel indexing can also be used to create local partitioned indexes on partitioned tables. However, indexing performance only improves when you have multiple CPUs.</p>
                     <div class="infoboxnote" id="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5__GUID-CCAE3B53-7729-4E68-8A52-9CF4D35A5954">
                        <p class="notep1">Note:</p>
                        <p>Using <code class="codeph">PARALLEL</code> to create a local partitioned index enables parallel queries. (Creating a non-partitioned index in parallel does not turn on parallel query processing.)
                        </p>
                        <p>Parallel querying degrades query throughput especially on heavily loaded systems. Because of this, Oracle recommends that you disable parallel querying after parallel indexing. To do so, use <code class="codeph">ALTER INDEX NOPARALLEL</code>.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9278"></a><div class="props_rev_3"><a id="GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561" name="GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561"></a><h4 id="CCAPP-GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561" class="sect4"><span class="enumeration_section">7.10.6 </span>How can I improve index performance for creating local partitioned index?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> When you have multiple CPUs, you can improve indexing performance by creating a local index in parallel. There are two ways to index in parallel:
                     </p>
                     <p>You can create a local partitioned index in parallel in two ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use the <code class="codeph">PARALLEL</code> clause with the <code class="codeph">LOCAL</code> clause in <code class="codeph">CREATE INDEX.</code>In this case, the maximum parallel degree is limited to the number of partitions you have.
                           </p>
                        </li>
                        <li>
                           <p>Create an unusable index first, then run the <code class="codeph">DBMS_PCLXUTIL.BUILD_PART_INDEX</code> utility. This method can result in a higher degree of parallelism, especially if you have more CPUs than partitions.
                           </p>
                        </li>
                     </ul>
                     <p>The following is an example for the second method. In this example, the base table has three partitions. We create a local partitioned unusable index first, the run the <code class="codeph">DBMS_PCLUTIL.BUILD_PART_INDEX</code>, which builds the 3 partitions in parallel (inter-partition parallelism). Also inside each partition, index creation is done in parallel (intra-partition parallelism) with a parallel degree of 2.
                     </p><pre class="oac_no_warn" dir="ltr">create index tdrbip02bx on tdrbip02b(text) 
indextype is ctxsys.context local (partition tdrbip02bx1, 
                                   partition tdrbip02bx2, 
                                   partition tdrbip02bx3) 
unusable; 

exec dbms_pclxutil.build_part_index(3,2,'TDRBIP02B','TDRBIP02BX',TRUE); </pre></div>
               </div><a id="CCAPP9279"></a><div class="props_rev_3"><a id="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF" name="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF"></a><h4 id="CCAPP-GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF" class="sect4"><span class="enumeration_section">7.10.7 </span>How can I tell how much indexing has completed?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can use the <code class="codeph">CTX_OUTPUT.START_LOG </code>procedure to log output from the indexing process. Filename will normally be written to <code class="codeph">$ORACLE_HOME/ctx/log</code>, but you can change the directory using the <code class="codeph">LOG_DIRECTORY</code> parameter in <code class="codeph">CTX_ADM.SET_PARAMETER</code>. 
                     </p>
                     <div class="infoboxnotealso" id="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF__GUID-45113A64-4C60-423E-B5D5-9F3753B6108B">
                        <p class="notep1">See Also:</p>
                        <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800"><span class="italic">Oracle Text Reference</span></a> to learn more about using this procedure
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9280"></a><div class="props_rev_3"><a id="GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3" name="GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3"></a><h3 id="CCAPP-GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3" class="sect3"><span class="enumeration_section">7.11 </span>Frequently Asked Questions About Updating the Index
               </h3>
               <div>
                  <p>This section answers some of the frequently asked questions about updating your index and related performance issues.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-995688F6-F94E-428E-8801-F8C9A9238E42">How often should I index new or updated records?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8">How can I tell when my indexes are getting fragmented?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-5F422D6F-6965-43F5-ABDF-AC449F539030">Does memory allocation affect index synchronization?</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9281"></a><div class="props_rev_3"><a id="GUID-995688F6-F94E-428E-8801-F8C9A9238E42" name="GUID-995688F6-F94E-428E-8801-F8C9A9238E42"></a><h4 id="CCAPP-GUID-995688F6-F94E-428E-8801-F8C9A9238E42" class="sect4"><span class="enumeration_section">7.11.1 </span>How often should I index new or updated records?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The less often you run reindexing with <code class="codeph">CTX_DDL.SYNC_INDEX</code>, the less fragmented your indexes will be, and the less you will need to optimize them.
                     </p>
                     <p>However, this means that your data will become progressively more out of date, which may be unacceptable for your users. </p>
                     <p>Overnight indexing is acceptable for many systems. In this case,  data that is less than a day old is not searchable. Other systems use hourly, ten minute, or five minute updates.</p>
                     <div class="infoboxnotealso" id="GUID-995688F6-F94E-428E-8801-F8C9A9238E42__GUID-DB5881A8-6AF8-4D4D-822B-093C37AFEFC8">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccref/CTX_DDL-package.html#CCREF0652"><span class="italic">Oracle Text Reference</span></a> to learn more about using <code class="codeph">CTX_DDL.SYNC_INDEX</code></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="indexing-with-oracle-text.html#GUID-4313B6A6-510F-41E8-9B5C-3559F42742D4">Managing DML Operations for a CONTEXT Index</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9282"></a><div class="props_rev_3"><a id="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8" name="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8"></a><h4 id="CCAPP-GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8" class="sect4"><span class="enumeration_section">7.11.2 </span>How can I tell when my indexes are getting fragmented?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The best way is to time some queries, run index optimization, then time the same queries (restarting the database to clear the SGA each time, of course). If the queries speed up significantly, then optimization was worthwhile. If they don't, you can wait longer next time.   
                     </p>
                     <p>You can also use <code class="codeph">CTX_REPORT.INDEX_STATS</code> to analyze index fragmentation.
                     </p>
                     <div class="infoboxnotealso" id="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8__GUID-E9A1BAE9-0FEE-4B06-9E92-00C5F7698BA1">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccref/CTX_REPORT-package.html#CCREF1100"><span class="italic">Oracle Text Reference</span></a> to learn more about using the <code class="codeph">CTX_REPORT</code> package
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="indexing-with-oracle-text.html#GUID-9960D8E4-0AE8-48B0-82D5-B203695463DE">Optimizing the Index</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9283"></a><div class="props_rev_3"><a id="GUID-5F422D6F-6965-43F5-ABDF-AC449F539030" name="GUID-5F422D6F-6965-43F5-ABDF-AC449F539030"></a><h4 id="CCAPP-GUID-5F422D6F-6965-43F5-ABDF-AC449F539030" class="sect4"><span class="enumeration_section">7.11.3 </span>Does memory allocation affect index synchronization?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Yes, the same way as for normal indexing. There are often far fewer records to be indexed during a synchronize operation, so it is not usually necessary to provide hundreds of megabytes of indexing memory. 
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>